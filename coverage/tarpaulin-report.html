<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","benches","benchmarks.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId, Throughput};\nuse std::io::{BufReader, Cursor};\n\nuse rawk::{Interpreter, Lexer, Parser};\n\nfn run_awk(program: \u0026str, input: \u0026str) -\u003e String {\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().unwrap();\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse().unwrap();\n\n    let mut interpreter = Interpreter::new(\u0026ast);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        interpreter.run(inputs, \u0026mut output).unwrap();\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        interpreter.run(inputs, \u0026mut output).unwrap();\n    }\n\n    String::from_utf8(output).unwrap()\n}\n\n// ============ Lexer Benchmarks ============\n\nfn bench_lexer(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"lexer\");\n\n    // Simple program\n    let simple = r#\"BEGIN { print \"hello\" }\"#;\n    group.bench_function(\"simple_program\", |b| {\n        b.iter(|| {\n            let mut lexer = Lexer::new(black_box(simple));\n            lexer.tokenize().unwrap()\n        })\n    });\n\n    // Complex program with many tokens\n    let complex = r#\"\n        BEGIN {\n            FS = \":\"\n            count = 0\n        }\n        /pattern/ {\n            for (i = 1; i \u003c= NF; i++) {\n                if ($i ~ /[0-9]+/) {\n                    sum += $i\n                    count++\n                }\n            }\n        }\n        END {\n            if (count \u003e 0) {\n                printf \"Average: %.2f\\n\", sum / count\n            }\n        }\n    \"#;\n    group.bench_function(\"complex_program\", |b| {\n        b.iter(|| {\n            let mut lexer = Lexer::new(black_box(complex));\n            lexer.tokenize().unwrap()\n        })\n    });\n\n    group.finish();\n}\n\n// ============ Parser Benchmarks ============\n\nfn bench_parser(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"parser\");\n\n    let program = r#\"\n        function factorial(n) {\n            if (n \u003c= 1) return 1\n            return n * factorial(n - 1)\n        }\n        BEGIN {\n            for (i = 1; i \u003c= 10; i++) {\n                print i, factorial(i)\n            }\n        }\n        { sum += $1 }\n        /error/ { errors++ }\n        END { print \"Total:\", sum, \"Errors:\", errors }\n    \"#;\n\n    // Pre-tokenize for parser benchmark\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().unwrap();\n\n    group.bench_function(\"parse_program\", |b| {\n        b.iter(|| {\n            let mut parser = Parser::new(black_box(tokens.clone()));\n            parser.parse().unwrap()\n        })\n    });\n\n    group.finish();\n}\n\n// ============ Interpreter Benchmarks ============\n\nfn bench_interpreter(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"interpreter\");\n\n    // Arithmetic operations\n    group.bench_function(\"arithmetic\", |b| {\n        b.iter(|| {\n            run_awk(black_box(\"BEGIN { x = 0; for (i = 1; i \u003c= 1000; i++) x += i * 2 - 1; print x }\"), \"\")\n        })\n    });\n\n    // String operations\n    group.bench_function(\"string_concat\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"\"; for (i = 1; i \u003c= 100; i++) s = s \"x\"; print length(s) }\"#), \"\")\n        })\n    });\n\n    // Field splitting\n    let input_line = \"field1 field2 field3 field4 field5 field6 field7 field8 field9 field10\";\n    group.bench_function(\"field_access\", |b| {\n        b.iter(|| {\n            run_awk(black_box(\"{ print $1, $5, $10 }\"), black_box(input_line))\n        })\n    });\n\n    // Pattern matching\n    let pattern_input = (0..100).map(|i| {\n        if i % 10 == 0 { format!(\"error line {}\", i) }\n        else { format!(\"normal line {}\", i) }\n    }).collect::\u003cVec\u003c_\u003e\u003e().join(\"\\n\");\n\n    group.bench_function(\"pattern_matching\", |b| {\n        b.iter(|| {\n            run_awk(black_box(\"/error/ { count++ } END { print count }\"), black_box(\u0026pattern_input))\n        })\n    });\n\n    // Array operations\n    group.bench_function(\"array_operations\", |b| {\n        b.iter(|| {\n            run_awk(\n                black_box(\"BEGIN { for (i = 1; i \u003c= 100; i++) arr[i] = i * 2; for (k in arr) sum += arr[k]; print sum }\"),\n                \"\"\n            )\n        })\n    });\n\n    // Printf formatting\n    group.bench_function(\"printf_formatting\", |b| {\n        b.iter(|| {\n            run_awk(\n                black_box(r#\"BEGIN { for (i = 1; i \u003c= 100; i++) printf \"%05d: %-20s %8.2f\\n\", i, \"test\", i * 3.14 }\"#),\n                \"\"\n            )\n        })\n    });\n\n    group.finish();\n}\n\n// ============ End-to-End Benchmarks ============\n\nfn bench_e2e_throughput(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"throughput\");\n\n    // Generate input of various sizes\n    for size in [100, 1000, 10000] {\n        let input: String = (0..size)\n            .map(|i| format!(\"{} {} {} {}\", i, i * 2, i * 3, i % 100))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\");\n\n        group.throughput(Throughput::Bytes(input.len() as u64));\n        group.bench_with_input(\n            BenchmarkId::new(\"sum_column\", size),\n            \u0026input,\n            |b, input| {\n                b.iter(|| {\n                    run_awk(black_box(\"{ sum += $1 } END { print sum }\"), black_box(input))\n                })\n            }\n        );\n    }\n\n    group.finish();\n}\n\nfn bench_builtin_functions(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"builtins\");\n\n    group.bench_function(\"length\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"hello world\"; for (i = 1; i \u003c= 1000; i++) x += length(s) }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"substr\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"hello world test string\"; for (i = 1; i \u003c= 1000; i++) x = substr(s, 5, 10) }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"index\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"hello world test string\"; for (i = 1; i \u003c= 1000; i++) x = index(s, \"test\") }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"split\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"a:b:c:d:e:f:g:h:i:j\"; for (i = 1; i \u003c= 100; i++) n = split(s, arr, \":\") }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"gsub\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"hello world hello world\"; for (i = 1; i \u003c= 100; i++) { t = s; gsub(/hello/, \"hi\", t) } }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"sprintf\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { for (i = 1; i \u003c= 1000; i++) s = sprintf(\"%d %.2f %s\", i, i * 3.14, \"test\") }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"math_functions\", |b| {\n        b.iter(|| {\n            run_awk(black_box(\"BEGIN { for (i = 1; i \u003c= 1000; i++) x = sin(i) + cos(i) + sqrt(i) }\"), \"\")\n        })\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_lexer,\n    bench_parser,\n    bench_interpreter,\n    bench_e2e_throughput,\n    bench_builtin_functions,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","fuzz","fuzz_targets","fuzz_interpreter.rs"],"content":"#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse rawk::{Interpreter, Lexer, Parser};\nuse std::io::{BufReader, Cursor};\n\nfuzz_target!(|data: \u0026[u8]| {\n    // Split the data into program and input\n    // First 1/3 is the program, rest is input\n    let split_point = data.len() / 3;\n    let (program_bytes, input_bytes) = data.split_at(split_point);\n\n    let program = match std::str::from_utf8(program_bytes) {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return,\n    };\n\n    let input = match std::str::from_utf8(input_bytes) {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return,\n    };\n\n    // Limit input sizes to prevent hangs\n    if program.len() \u003e 10000 || input.len() \u003e 100000 {\n        return;\n    }\n\n    // Try to lex\n    let mut lexer = Lexer::new(program);\n    let tokens = match lexer.tokenize() {\n        Ok(t) =\u003e t,\n        Err(_) =\u003e return,\n    };\n\n    // Try to parse\n    let mut parser = Parser::new(tokens);\n    let ast = match parser.parse() {\n        Ok(a) =\u003e a,\n        Err(_) =\u003e return,\n    };\n\n    // Try to run with a timeout simulation (limit iterations)\n    let mut interpreter = Interpreter::new(\u0026ast);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        let _ = interpreter.run(inputs, \u0026mut output);\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        let _ = interpreter.run(inputs, \u0026mut output);\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","fuzz","fuzz_targets","fuzz_lexer.rs"],"content":"#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse rawk::Lexer;\n\nfuzz_target!(|data: \u0026str| {\n    // Fuzz the lexer with arbitrary input strings\n    let mut lexer = Lexer::new(data);\n    // We don't care if it fails, just that it doesn't panic or hang\n    let _ = lexer.tokenize();\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","fuzz","fuzz_targets","fuzz_parser.rs"],"content":"#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse rawk::{Lexer, Parser};\n\nfuzz_target!(|data: \u0026str| {\n    // Try to lex the input\n    let mut lexer = Lexer::new(data);\n    if let Ok(tokens) = lexer.tokenize() {\n        // Try to parse if lexing succeeds\n        let mut parser = Parser::new(tokens);\n        let _ = parser.parse();\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","ast.rs"],"content":"use crate::error::SourceLocation;\n\n/// A complete AWK program\n#[derive(Debug, Clone)]\npub struct Program {\n    pub rules: Vec\u003cRule\u003e,\n    pub functions: Vec\u003cFunctionDef\u003e,\n}\n\nimpl Program {\n    pub fn new() -\u003e Self {\n        Self {\n            rules: Vec::new(),\n            functions: Vec::new(),\n        }\n    }\n}\n\nimpl Default for Program {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A pattern-action rule\n#[derive(Debug, Clone)]\npub struct Rule {\n    pub pattern: Option\u003cPattern\u003e,\n    pub action: Option\u003cBlock\u003e,\n    pub location: SourceLocation,\n}\n\n/// Pattern types that can trigger a rule\n#[derive(Debug, Clone)]\npub enum Pattern {\n    /// BEGIN - runs before any input\n    Begin,\n    /// END - runs after all input\n    End,\n    /// BEGINFILE - runs at the start of each input file (gawk extension)\n    BeginFile,\n    /// ENDFILE - runs at the end of each input file (gawk extension)\n    EndFile,\n    /// Expression that evaluates to true/false\n    Expr(Expr),\n    /// Regex pattern: /pattern/\n    Regex(String),\n    /// Range pattern: /start/,/end/\n    Range {\n        start: Box\u003cPattern\u003e,\n        end: Box\u003cPattern\u003e,\n    },\n    /// Compound patterns with logical operators\n    And(Box\u003cPattern\u003e, Box\u003cPattern\u003e),\n    Or(Box\u003cPattern\u003e, Box\u003cPattern\u003e),\n    Not(Box\u003cPattern\u003e),\n}\n\n/// User-defined function\n#[derive(Debug, Clone)]\npub struct FunctionDef {\n    pub name: String,\n    pub params: Vec\u003cString\u003e,\n    pub body: Block,\n    pub location: SourceLocation,\n}\n\n/// A block of statements\n#[derive(Debug, Clone)]\npub struct Block {\n    pub statements: Vec\u003cStmt\u003e,\n    pub location: SourceLocation,\n}\n\nimpl Block {\n    pub fn new(statements: Vec\u003cStmt\u003e, location: SourceLocation) -\u003e Self {\n        Self { statements, location }\n    }\n\n    pub fn empty(location: SourceLocation) -\u003e Self {\n        Self {\n            statements: Vec::new(),\n            location,\n        }\n    }\n}\n\n/// Statement types\n#[derive(Debug, Clone)]\npub enum Stmt {\n    /// Expression statement (e.g., function call, assignment)\n    Expr(Expr),\n\n    /// Print statement: print expr, expr, ...\n    Print {\n        args: Vec\u003cExpr\u003e,\n        output: Option\u003cOutputRedirect\u003e,\n        location: SourceLocation,\n    },\n\n    /// Printf statement: printf format, expr, ...\n    Printf {\n        format: Expr,\n        args: Vec\u003cExpr\u003e,\n        output: Option\u003cOutputRedirect\u003e,\n        location: SourceLocation,\n    },\n\n    /// If statement\n    If {\n        condition: Expr,\n        then_branch: Box\u003cStmt\u003e,\n        else_branch: Option\u003cBox\u003cStmt\u003e\u003e,\n        location: SourceLocation,\n    },\n\n    /// While loop\n    While {\n        condition: Expr,\n        body: Box\u003cStmt\u003e,\n        location: SourceLocation,\n    },\n\n    /// Do-while loop\n    DoWhile {\n        body: Box\u003cStmt\u003e,\n        condition: Expr,\n        location: SourceLocation,\n    },\n\n    /// For loop (C-style)\n    For {\n        init: Option\u003cBox\u003cStmt\u003e\u003e,\n        condition: Option\u003cExpr\u003e,\n        update: Option\u003cExpr\u003e,\n        body: Box\u003cStmt\u003e,\n        location: SourceLocation,\n    },\n\n    /// For-in loop (array iteration)\n    ForIn {\n        var: String,\n        array: String,\n        body: Box\u003cStmt\u003e,\n        location: SourceLocation,\n    },\n\n    /// Block of statements\n    Block(Block),\n\n    /// Break statement\n    Break { location: SourceLocation },\n\n    /// Continue statement\n    Continue { location: SourceLocation },\n\n    /// Next statement (skip to next record)\n    Next { location: SourceLocation },\n\n    /// Nextfile statement (skip to next file)\n    Nextfile { location: SourceLocation },\n\n    /// Exit statement\n    Exit {\n        code: Option\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Return statement\n    Return {\n        value: Option\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Delete statement: delete array[index]\n    Delete {\n        array: String,\n        index: Vec\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Getline statement (various forms)\n    Getline {\n        var: Option\u003cString\u003e,\n        input: Option\u003cGetlineInput\u003e,\n        location: SourceLocation,\n    },\n\n    /// Empty statement (just a semicolon)\n    Empty,\n}\n\n/// Output redirection for print/printf\n#[derive(Debug, Clone)]\npub enum OutputRedirect {\n    /// \u003e file\n    Truncate(Expr),\n    /// \u003e\u003e file\n    Append(Expr),\n    /// | command\n    Pipe(Expr),\n}\n\n/// Input source for getline\n#[derive(Debug, Clone)]\npub enum GetlineInput {\n    /// \u003c file\n    File(Box\u003cExpr\u003e),\n    /// command |\n    Pipe(Box\u003cExpr\u003e),\n}\n\n/// Expression types\n#[derive(Debug, Clone)]\npub enum Expr {\n    /// Numeric literal\n    Number(f64, SourceLocation),\n\n    /// String literal\n    String(String, SourceLocation),\n\n    /// Regex literal\n    Regex(String, SourceLocation),\n\n    /// Variable reference\n    Var(String, SourceLocation),\n\n    /// Field access: $expr\n    Field(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Array access: arr[index] or arr[i,j]\n    ArrayAccess {\n        array: String,\n        indices: Vec\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Binary operation\n    Binary {\n        left: Box\u003cExpr\u003e,\n        op: BinaryOp,\n        right: Box\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Unary operation\n    Unary {\n        op: UnaryOp,\n        operand: Box\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Assignment\n    Assign {\n        target: Box\u003cExpr\u003e,\n        op: AssignOp,\n        value: Box\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Pre-increment: ++x\n    PreIncrement(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Pre-decrement: --x\n    PreDecrement(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Post-increment: x++\n    PostIncrement(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Post-decrement: x--\n    PostDecrement(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Ternary: cond ? then : else\n    Ternary {\n        condition: Box\u003cExpr\u003e,\n        then_expr: Box\u003cExpr\u003e,\n        else_expr: Box\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Function call\n    Call {\n        name: String,\n        args: Vec\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Array membership: (key) in array\n    InArray {\n        key: Vec\u003cExpr\u003e,\n        array: String,\n        location: SourceLocation,\n    },\n\n    /// Regex match: expr ~ /regex/ or expr !~ /regex/\n    Match {\n        expr: Box\u003cExpr\u003e,\n        pattern: Box\u003cExpr\u003e,\n        negated: bool,\n        location: SourceLocation,\n    },\n\n    /// Concatenation (implicit when expressions are adjacent)\n    Concat(Vec\u003cExpr\u003e, SourceLocation),\n\n    /// Getline as expression (returns status)\n    Getline {\n        var: Option\u003cString\u003e,\n        input: Option\u003cGetlineInput\u003e,\n        location: SourceLocation,\n    },\n\n    /// Grouping parentheses (for precedence)\n    Group(Box\u003cExpr\u003e, SourceLocation),\n}\n\nimpl Expr {\n    pub fn location(\u0026self) -\u003e SourceLocation {\n        match self {\n            Expr::Number(_, loc)\n            | Expr::String(_, loc)\n            | Expr::Regex(_, loc)\n            | Expr::Var(_, loc)\n            | Expr::Field(_, loc)\n            | Expr::ArrayAccess { location: loc, .. }\n            | Expr::Binary { location: loc, .. }\n            | Expr::Unary { location: loc, .. }\n            | Expr::Assign { location: loc, .. }\n            | Expr::PreIncrement(_, loc)\n            | Expr::PreDecrement(_, loc)\n            | Expr::PostIncrement(_, loc)\n            | Expr::PostDecrement(_, loc)\n            | Expr::Ternary { location: loc, .. }\n            | Expr::Call { location: loc, .. }\n            | Expr::InArray { location: loc, .. }\n            | Expr::Match { location: loc, .. }\n            | Expr::Concat(_, loc)\n            | Expr::Getline { location: loc, .. }\n            | Expr::Group(_, loc) =\u003e *loc,\n        }\n    }\n}\n\n/// Binary operators\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum BinaryOp {\n    // Arithmetic\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Mod,\n    Pow,\n\n    // Comparison\n    Lt,\n    Le,\n    Gt,\n    Ge,\n    Eq,\n    Ne,\n\n    // Logical\n    And,\n    Or,\n\n    // String\n    Concat,\n}\n\n/// Unary operators\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum UnaryOp {\n    Neg,    // -x\n    Pos,    // +x\n    Not,    // !x\n}\n\n/// Assignment operators\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum AssignOp {\n    Assign,     // =\n    AddAssign,  // +=\n    SubAssign,  // -=\n    MulAssign,  // *=\n    DivAssign,  // /=\n    ModAssign,  // %=\n    PowAssign,  // ^=\n}\n","traces":[{"line":11,"address":[3114784,3114928,3114934],"length":1,"stats":{"Line":11}},{"line":13,"address":[3114798],"length":1,"stats":{"Line":44}},{"line":14,"address":[2369933],"length":1,"stats":{"Line":11}},{"line":20,"address":[3135440],"length":1,"stats":{"Line":0}},{"line":21,"address":[3146712],"length":1,"stats":{"Line":0}},{"line":76,"address":[3125888],"length":1,"stats":{"Line":4}},{"line":80,"address":[2369792],"length":1,"stats":{"Line":0}},{"line":82,"address":[2369825],"length":1,"stats":{"Line":0}},{"line":318,"address":[2369328],"length":1,"stats":{"Line":2}},{"line":319,"address":[3114377,3114434,3114488,3114263,3114504,3114552,3114584,3114396,3114339,3114282,3114218,3114301,3114536,3114320,3114358,3114568,3114453,3114472,3114520,3114415],"length":1,"stats":{"Line":11}},{"line":320,"address":[3114591,3114600],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":11},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","error.rs"],"content":"use std::fmt;\nuse thiserror::Error;\n\n/// Location in source code for error reporting\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct SourceLocation {\n    pub line: usize,\n    pub column: usize,\n}\n\nimpl SourceLocation {\n    pub fn new(line: usize, column: usize) -\u003e Self {\n        Self { line, column }\n    }\n}\n\nimpl fmt::Display for SourceLocation {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"line {}, column {}\", self.line, self.column)\n    }\n}\n\n/// All error types for rawk\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"lexer error at {location}: {message}\")]\n    Lexer {\n        message: String,\n        location: SourceLocation,\n    },\n\n    #[error(\"parser error at {location}: {message}\")]\n    Parser {\n        message: String,\n        location: SourceLocation,\n    },\n\n    #[error(\"runtime error: {message}\")]\n    Runtime { message: String },\n\n    #[error(\"runtime error at {location}: {message}\")]\n    RuntimeWithLocation {\n        message: String,\n        location: SourceLocation,\n    },\n\n    #[error(\"I/O error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"regex error: {0}\")]\n    Regex(#[from] regex::Error),\n}\n\nimpl Error {\n    pub fn lexer(message: impl Into\u003cString\u003e, line: usize, column: usize) -\u003e Self {\n        Self::Lexer {\n            message: message.into(),\n            location: SourceLocation::new(line, column),\n        }\n    }\n\n    pub fn parser(message: impl Into\u003cString\u003e, line: usize, column: usize) -\u003e Self {\n        Self::Parser {\n            message: message.into(),\n            location: SourceLocation::new(line, column),\n        }\n    }\n\n    pub fn runtime(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Runtime {\n            message: message.into(),\n        }\n    }\n\n    pub fn runtime_at(message: impl Into\u003cString\u003e, line: usize, column: usize) -\u003e Self {\n        Self::RuntimeWithLocation {\n            message: message.into(),\n            location: SourceLocation::new(line, column),\n        }\n    }\n}\n\n/// Result type alias for rawk operations\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_source_location() {\n        let loc = SourceLocation::new(10, 5);\n        assert_eq!(loc.line, 10);\n        assert_eq!(loc.column, 5);\n        assert_eq!(format!(\"{}\", loc), \"line 10, column 5\");\n    }\n\n    #[test]\n    fn test_lexer_error() {\n        let err = Error::lexer(\"unexpected character\", 1, 5);\n        assert!(matches!(err, Error::Lexer { .. }));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"lexer error\"));\n        assert!(msg.contains(\"unexpected character\"));\n    }\n\n    #[test]\n    fn test_parser_error() {\n        let err = Error::parser(\"expected expression\", 2, 10);\n        assert!(matches!(err, Error::Parser { .. }));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"parser error\"));\n    }\n\n    #[test]\n    fn test_runtime_error() {\n        let err = Error::runtime(\"division by zero\");\n        assert!(matches!(err, Error::Runtime { .. }));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"runtime error\"));\n        assert!(msg.contains(\"division by zero\"));\n    }\n\n    #[test]\n    fn test_runtime_error_with_location() {\n        let err = Error::runtime_at(\"undefined variable\", 5, 3);\n        assert!(matches!(err, Error::RuntimeWithLocation { .. }));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"runtime error\"));\n        assert!(msg.contains(\"line 5\"));\n    }\n\n    #[test]\n    fn test_io_error() {\n        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, \"file not found\");\n        let err: Error = io_err.into();\n        assert!(matches!(err, Error::Io(_)));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"I/O error\"));\n    }\n\n    #[test]\n    fn test_regex_error() {\n        let re_err = regex::Regex::new(\"[invalid\").unwrap_err();\n        let err: Error = re_err.into();\n        assert!(matches!(err, Error::Regex(_)));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"regex error\"));\n    }\n}\n","traces":[{"line":11,"address":[1252160],"length":1,"stats":{"Line":0}},{"line":12,"address":[2537408],"length":1,"stats":{"Line":32}},{"line":17,"address":[1252128],"length":1,"stats":{"Line":0}},{"line":18,"address":[2539872],"length":1,"stats":{"Line":2}},{"line":19,"address":[6401008,6400808,6402447],"length":1,"stats":{"Line":2}},{"line":54,"address":[1326288],"length":1,"stats":{"Line":0}},{"line":55,"address":[3056288,3056496,3056471,3056689,3056695],"length":1,"stats":{"Line":2}},{"line":57,"address":[1326356],"length":1,"stats":{"Line":2}},{"line":58,"address":[2735546,2735328],"length":1,"stats":{"Line":2}},{"line":62,"address":[3302232],"length":1,"stats":{"Line":1}},{"line":64,"address":[2749841,2750059],"length":1,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[6354396],"length":1,"stats":{"Line":3}},{"line":71,"address":[6664085],"length":1,"stats":{"Line":3}},{"line":75,"address":[2735025,2735056,2734832,2735031,2735239],"length":1,"stats":{"Line":3}},{"line":77,"address":[2748987,2749201],"length":1,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":2}}],"covered":14,"coverable":17},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","interpreter","builtins.rs"],"content":"use std::io::Write;\n\nuse crate::ast::Expr;\nuse crate::error::{Error, Result, SourceLocation};\nuse crate::value::Value;\n\nuse super::Interpreter;\n\nimpl\u003c'a\u003e Interpreter\u003c'a\u003e {\n    /// Call a function with special handling for builtins that need AST access\n    pub fn call_function\u003cW: Write\u003e(\n        \u0026mut self,\n        name: \u0026str,\n        args: \u0026[Expr],\n        location: SourceLocation,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        // Check for built-in functions that need special argument handling\n        match name {\n            \"sub\" | \"gsub\" =\u003e return self.call_regex_sub(name, args, location),\n            \"match\" =\u003e return self.call_match(args, location),\n            \"split\" =\u003e return self.call_split(args, location),\n            \"patsplit\" =\u003e return self.call_patsplit(args, location),\n            \"asort\" | \"asorti\" =\u003e return self.call_asort(name == \"asorti\", args, location),\n            \"getline\" =\u003e return self.call_getline(args, location),\n            \"close\" =\u003e return self.call_close(args, location),\n            \"fflush\" =\u003e return self.call_fflush(args, location, output),\n            _ =\u003e {}\n        }\n\n        // Evaluate all arguments for other functions\n        let arg_values: Result\u003cVec\u003cValue\u003e\u003e = args.iter().map(|e| self.eval_expr(e)).collect();\n        let arg_values = arg_values?;\n\n        // Check for other built-in functions\n        if let Some(result) = self.call_builtin(name, \u0026arg_values)? {\n            return Ok(result);\n        }\n\n        // Check for user-defined functions\n        if let Some(func) = self.functions.get(name).cloned() {\n            // Extract array names from arguments for pass-by-reference\n            let array_refs: Vec\u003cOption\u003cString\u003e\u003e = args.iter().map(|e| {\n                if let Expr::Var(name, _) = e {\n                    if self.arrays.contains_key(name) {\n                        return Some(name.clone());\n                    }\n                }\n                None\n            }).collect();\n            return self.call_user_function(\u0026func, arg_values, array_refs, output);\n        }\n\n        Err(Error::runtime_at(\n            format!(\"undefined function: {}\", name),\n            location.line,\n            location.column,\n        ))\n    }\n\n    /// Extract regex pattern from an expression (handles both regex literals and strings)\n    fn extract_pattern(\u0026mut self, expr: \u0026Expr) -\u003e Result\u003cString\u003e {\n        match expr {\n            Expr::Regex(pattern, _) =\u003e Ok(pattern.clone()),\n            other =\u003e Ok(self.eval_expr(other)?.to_string_val()),\n        }\n    }\n\n    /// Call sub or gsub with proper regex and target handling\n    fn call_regex_sub(\u0026mut self, name: \u0026str, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        let global = name == \"gsub\";\n\n        let pattern = args.first()\n            .map(|e| self.extract_pattern(e))\n            .transpose()?\n            .unwrap_or_default();\n\n        let replacement = args.get(1)\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        // Get the target (third argument or $0)\n        let (target_value, target_expr) = if let Some(target_arg) = args.get(2) {\n            (self.eval_expr(target_arg)?.to_string_val(), Some(target_arg))\n        } else {\n            (self.record.clone(), None)\n        };\n\n        let re = regex::Regex::new(\u0026pattern).map_err(|e| {\n            Error::runtime_at(format!(\"invalid regex: {}\", e), location.line, location.column)\n        })?;\n\n        let (new_str, count) = regex_sub_helper(\u0026re, \u0026replacement, \u0026target_value, global);\n\n        // Assign the result back to the target\n        if let Some(target_arg) = target_expr {\n            self.assign_to_lvalue(target_arg, Value::from_string(new_str))?;\n        } else {\n            self.set_record(\u0026new_str);\n        }\n\n        Ok(Value::Number(count as f64))\n    }\n\n    /// Call match with proper regex handling\n    fn call_match(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        let s = args.first()\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        let pattern = args.get(1)\n            .map(|e| self.extract_pattern(e))\n            .transpose()?\n            .unwrap_or_default();\n\n        let re = regex::Regex::new(\u0026pattern).map_err(|e| {\n            Error::runtime_at(format!(\"invalid regex: {}\", e), location.line, location.column)\n        })?;\n\n        if let Some(m) = re.find(\u0026s) {\n            self.rstart = m.start() + 1;\n            self.rlength = m.len() as i32;\n            Ok(Value::Number(self.rstart as f64))\n        } else {\n            self.rstart = 0;\n            self.rlength = -1;\n            Ok(Value::Number(0.0))\n        }\n    }\n\n    /// Call split with proper array name handling\n    fn call_split(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        let s = args.first()\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        // Get array name from second argument (must be a variable name)\n        let array_name = match args.get(1) {\n            Some(Expr::Var(name, _)) =\u003e name.clone(),\n            Some(Expr::ArrayAccess { array, .. }) =\u003e array.clone(),\n            Some(_) =\u003e {\n                return Err(Error::runtime_at(\n                    \"split: second argument must be an array\",\n                    location.line,\n                    location.column,\n                ));\n            }\n            None =\u003e {\n                return Err(Error::runtime_at(\n                    \"split: missing array argument\",\n                    location.line,\n                    location.column,\n                ));\n            }\n        };\n\n        // Get separator (third argument or default FS)\n        let sep = if let Some(sep_expr) = args.get(2) {\n            self.extract_pattern(sep_expr)?\n        } else {\n            self.fs.clone()\n        };\n\n        // Clear the array\n        self.arrays.remove(\u0026array_name);\n\n        // Split and populate array\n        let parts: Vec\u003c\u0026str\u003e = if sep == \" \" {\n            s.split_whitespace().collect()\n        } else if sep.len() == 1 {\n            s.split(\u0026sep).collect()\n        } else {\n            // Use regex split for multi-char separators\n            let re = regex::Regex::new(\u0026sep).map_err(|e| {\n                Error::runtime_at(format!(\"invalid regex: {}\", e), location.line, location.column)\n            })?;\n            re.split(\u0026s).collect()\n        };\n\n        for (i, part) in parts.iter().enumerate() {\n            let key = (i + 1).to_string();\n            self.set_array_element(\u0026array_name, \u0026key, Value::from_string(part.to_string()));\n        }\n\n        Ok(Value::Number(parts.len() as f64))\n    }\n\n    /// asort(source [, dest]) - sort array values\n    /// asorti(source [, dest]) - sort array indices\n    fn call_asort(\u0026mut self, sort_indices: bool, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        // Get source array name\n        let source_name = match args.first() {\n            Some(Expr::Var(name, _)) =\u003e name.clone(),\n            _ =\u003e {\n                return Err(Error::runtime_at(\n                    if sort_indices { \"asorti: first argument must be an array\" }\n                    else { \"asort: first argument must be an array\" },\n                    location.line,\n                    location.column,\n                ));\n            }\n        };\n\n        // Get optional destination array name\n        let dest_name = match args.get(1) {\n            Some(Expr::Var(name, _)) =\u003e Some(name.clone()),\n            None =\u003e None,\n            _ =\u003e {\n                return Err(Error::runtime_at(\n                    if sort_indices { \"asorti: second argument must be an array\" }\n                    else { \"asort: second argument must be an array\" },\n                    location.line,\n                    location.column,\n                ));\n            }\n        };\n\n        // Get values to sort\n        let items: Vec\u003cString\u003e = if let Some(arr) = self.arrays.get(\u0026source_name) {\n            if sort_indices {\n                arr.keys().cloned().collect()\n            } else {\n                arr.values().map(|v| v.to_string_val()).collect()\n            }\n        } else {\n            Vec::new()\n        };\n\n        let mut sorted = items;\n        sorted.sort();\n\n        let count = sorted.len();\n\n        // Store in destination (or source if no dest)\n        let target = dest_name.unwrap_or_else(|| source_name.clone());\n        self.arrays.remove(\u0026target);\n\n        for (i, item) in sorted.iter().enumerate() {\n            let key = (i + 1).to_string();\n            self.set_array_element(\u0026target, \u0026key, Value::from_string(item.clone()));\n        }\n\n        Ok(Value::Number(count as f64))\n    }\n\n    /// patsplit(string, array, fieldpat [, seps]) - split by pattern matches\n    fn call_patsplit(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        // Get string to split\n        let s = args.first()\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        // Get array name\n        let array_name = match args.get(1) {\n            Some(Expr::Var(name, _)) =\u003e name.clone(),\n            _ =\u003e {\n                return Err(Error::runtime_at(\n                    \"patsplit: second argument must be an array\",\n                    location.line,\n                    location.column,\n                ));\n            }\n        };\n\n        // Get field pattern\n        let fieldpat = if let Some(pat_expr) = args.get(2) {\n            self.extract_pattern(pat_expr)?\n        } else {\n            return Err(Error::runtime_at(\n                \"patsplit: missing fieldpat argument\",\n                location.line,\n                location.column,\n            ));\n        };\n\n        // Optional separator array\n        let seps_name = match args.get(3) {\n            Some(Expr::Var(name, _)) =\u003e Some(name.clone()),\n            None =\u003e None,\n            _ =\u003e None,\n        };\n\n        // Clear destination arrays\n        self.arrays.remove(\u0026array_name);\n        if let Some(ref name) = seps_name {\n            self.arrays.remove(name);\n        }\n\n        // Compile regex and find all matches\n        let re = self.get_regex(\u0026fieldpat)?;\n        let matches: Vec\u003cregex::Match\u003e = re.find_iter(\u0026s).collect();\n\n        // Store matches in array\n        for (i, mat) in matches.iter().enumerate() {\n            let key = (i + 1).to_string();\n            self.set_array_element(\u0026array_name, \u0026key, Value::from_string(mat.as_str().to_string()));\n        }\n\n        // Store separators if requested\n        if let Some(ref name) = seps_name {\n            let mut last_end = 0;\n            for (i, mat) in matches.iter().enumerate() {\n                let sep = \u0026s[last_end..mat.start()];\n                let key = i.to_string();\n                self.set_array_element(name, \u0026key, Value::from_string(sep.to_string()));\n                last_end = mat.end();\n            }\n            // Final separator after last match\n            let key = matches.len().to_string();\n            self.set_array_element(name, \u0026key, Value::from_string(s[last_end..].to_string()));\n        }\n\n        Ok(Value::Number(matches.len() as f64))\n    }\n\n    /// Call getline with file/pipe/variable handling\n    fn call_getline(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        // getline returns: 1 (success), 0 (EOF), -1 (error)\n        // For now, just return 0 (EOF) for unsupported cases\n        // TODO: Implement proper getline with file/pipe support\n        let _ = args;\n        let _ = location;\n        Ok(Value::Number(0.0))\n    }\n\n    /// Call close to close a file or pipe\n    fn call_close(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        let filename = args.first()\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        // Remove from output files if it exists\n        if self.output_files.remove(\u0026filename).is_some() {\n            Ok(Value::Number(0.0))  // Success\n        } else if self.input_files.remove(\u0026filename).is_some() {\n            Ok(Value::Number(0.0))  // Success\n        } else if self.pipes.remove(\u0026filename).is_some() {\n            Ok(Value::Number(0.0))  // Success\n        } else {\n            let _ = location;\n            Ok(Value::Number(-1.0)) // Not found\n        }\n    }\n\n    /// Call fflush to flush output\n    fn call_fflush\u003cW: Write\u003e(\u0026mut self, args: \u0026[Expr], _location: SourceLocation, output: \u0026mut W) -\u003e Result\u003cValue\u003e {\n        if args.is_empty() {\n            // Flush all output\n            output.flush().map_err(Error::Io)?;\n            for file in self.output_files.values_mut() {\n                let _ = file.flush();\n            }\n            Ok(Value::Number(0.0))\n        } else {\n            let filename = self.eval_expr(\u0026args[0])?.to_string_val();\n            if filename.is_empty() {\n                output.flush().map_err(Error::Io)?;\n                Ok(Value::Number(0.0))\n            } else if let Some(file) = self.output_files.get_mut(\u0026filename) {\n                file.flush().map_err(Error::Io)?;\n                Ok(Value::Number(0.0))\n            } else {\n                Ok(Value::Number(-1.0))\n            }\n        }\n    }\n\n    fn call_builtin(\u0026mut self, name: \u0026str, args: \u0026[Value]) -\u003e Result\u003cOption\u003cValue\u003e\u003e {\n        match name {\n            // String functions\n            \"length\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_else(|| self.record.clone());\n                // Use character count for UTF-8 support\n                Ok(Some(Value::Number(s.chars().count() as f64)))\n            }\n\n            \"substr\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let start = args.get(1).map(|v| v.to_number() as usize).unwrap_or(1);\n                let len = args.get(2).map(|v| v.to_number() as usize);\n\n                // AWK uses 1-based indexing; ensure start is at least 1\n                let start = start.max(1).saturating_sub(1);\n                let result = if let Some(len) = len {\n                    s.chars().skip(start).take(len).collect()\n                } else {\n                    s.chars().skip(start).collect()\n                };\n                Ok(Some(Value::from_string(result)))\n            }\n\n            \"index\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let target = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                // Find byte position, then convert to character position\n                let pos = s.find(\u0026target).map(|byte_idx| {\n                    // Count characters before the byte index\n                    s[..byte_idx].chars().count() + 1\n                }).unwrap_or(0);\n                Ok(Some(Value::Number(pos as f64)))\n            }\n\n            \"sprintf\" =\u003e {\n                let format = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let rest = if args.len() \u003e 1 { \u0026args[1..] } else { \u0026[] };\n                let result = self.format_printf(\u0026format, rest);\n                Ok(Some(Value::from_string(result)))\n            }\n\n            \"tolower\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Some(Value::from_string(s.to_lowercase())))\n            }\n\n            \"toupper\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Some(Value::from_string(s.to_uppercase())))\n            }\n\n            // Math functions\n            \"sin\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.sin())))\n            }\n\n            \"cos\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.cos())))\n            }\n\n            \"atan2\" =\u003e {\n                let y = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                let x = args.get(1).map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(y.atan2(x))))\n            }\n\n            \"exp\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.exp())))\n            }\n\n            \"log\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.ln())))\n            }\n\n            \"sqrt\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.sqrt())))\n            }\n\n            \"int\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.trunc())))\n            }\n\n            \"rand\" =\u003e {\n                // Use the internal RNG state\n                let random = self.next_random();\n                Ok(Some(Value::Number(random)))\n            }\n\n            \"srand\" =\u003e {\n                let old_seed = self.rand_seed;\n                if let Some(seed) = args.first() {\n                    self.rand_seed = seed.to_number() as u64;\n                } else {\n                    use std::time::{SystemTime, UNIX_EPOCH};\n                    self.rand_seed = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .map(|d| d.as_secs())\n                        .unwrap_or(0);\n                }\n                self.rand_state = self.rand_seed;\n                Ok(Some(Value::Number(old_seed as f64)))\n            }\n\n            // System functions\n            \"system\" =\u003e {\n                let cmd = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let status = std::process::Command::new(\"sh\")\n                    .arg(\"-c\")\n                    .arg(\u0026cmd)\n                    .status()\n                    .map(|s| s.code().unwrap_or(-1))\n                    .unwrap_or(-1);\n                Ok(Some(Value::Number(status as f64)))\n            }\n\n            // === GAWK Extensions ===\n\n            // Time functions\n            \"systime\" =\u003e {\n                // Return current time as seconds since epoch\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let secs = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .map(|d| d.as_secs())\n                    .unwrap_or(0);\n                Ok(Some(Value::Number(secs as f64)))\n            }\n\n            \"mktime\" =\u003e {\n                // Parse \"YYYY MM DD HH MM SS [DST]\" into epoch timestamp\n                let datespec = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let parts: Vec\u003ci64\u003e = datespec.split_whitespace()\n                    .filter_map(|s| s.parse().ok())\n                    .collect();\n\n                if parts.len() \u003e= 6 {\n                    // Simple implementation using chrono-like calculation\n                    // This is a simplified version; for full accuracy we'd need chrono crate\n                    let year = parts[0];\n                    let month = parts[1];\n                    let day = parts[2];\n                    let hour = parts[3];\n                    let min = parts[4];\n                    let sec = parts[5];\n\n                    // Simplified epoch calculation (not handling DST or timezones)\n                    let epoch = simple_mktime(year, month, day, hour, min, sec);\n                    Ok(Some(Value::Number(epoch as f64)))\n                } else {\n                    Ok(Some(Value::Number(-1.0)))\n                }\n            }\n\n            \"strftime\" =\u003e {\n                // Format timestamp\n                let format = args.first().map(|v| v.to_string_val()).unwrap_or_else(|| \"%a %b %e %H:%M:%S %Z %Y\".to_string());\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let timestamp = args.get(1)\n                    .map(|v| v.to_number() as u64)\n                    .unwrap_or_else(|| {\n                        SystemTime::now()\n                            .duration_since(UNIX_EPOCH)\n                            .map(|d| d.as_secs())\n                            .unwrap_or(0)\n                    });\n\n                let result = format_strftime(\u0026format, timestamp);\n                Ok(Some(Value::from_string(result)))\n            }\n\n            // gensub - like gsub but returns the result instead of modifying in place\n            \"gensub\" =\u003e {\n                let pattern = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let replacement = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                let how = args.get(2).map(|v| v.to_string_val()).unwrap_or_else(|| \"g\".to_string());\n                let target = args.get(3).map(|v| v.to_string_val()).unwrap_or_else(|| self.record.clone());\n\n                let re = self.get_regex(\u0026pattern)?;\n\n                // \"g\" or \"G\" means global, otherwise it's the occurrence number\n                let result = if how.eq_ignore_ascii_case(\"g\") {\n                    re.replace_all(\u0026target, replacement.replace(\"\u0026\", \"$0\").as_str()).to_string()\n                } else if let Ok(n) = how.parse::\u003cusize\u003e() {\n                    // Replace nth occurrence\n                    let mut count = 0;\n                    let mut last_end = 0;\n                    let mut result = String::new();\n                    for mat in re.find_iter(\u0026target) {\n                        count += 1;\n                        if count == n {\n                            result.push_str(\u0026target[last_end..mat.start()]);\n                            result.push_str(\u0026replacement.replace(\"\u0026\", mat.as_str()));\n                            last_end = mat.end();\n                            break;\n                        }\n                    }\n                    result.push_str(\u0026target[last_end..]);\n                    if count \u003c n {\n                        target.clone()\n                    } else {\n                        result\n                    }\n                } else {\n                    // Default to first occurrence\n                    re.replace(\u0026target, replacement.replace(\"\u0026\", \"$0\").as_str()).to_string()\n                };\n\n                Ok(Some(Value::from_string(result)))\n            }\n\n            _ =\u003e Ok(None), // Not a built-in\n        }\n    }\n\n    fn call_user_function\u003cW: Write\u003e(\n        \u0026mut self,\n        func: \u0026crate::ast::FunctionDef,\n        args: Vec\u003cValue\u003e,\n        array_refs: Vec\u003cOption\u003cString\u003e\u003e,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        // Save current variables for local scope\n        let saved_vars: std::collections::HashMap\u003cString, Value\u003e = func.params.iter()\n            .filter_map(|name| self.variables.get(name).map(|v| (name.clone(), v.clone())))\n            .collect();\n\n        // Save any arrays that share names with parameters (for local arrays)\n        let saved_arrays: std::collections::HashMap\u003cString, std::collections::HashMap\u003cString, Value\u003e\u003e =\n            func.params.iter()\n            .filter_map(|name| self.arrays.get(name).map(|a| (name.clone(), a.clone())))\n            .collect();\n\n        // Create array aliases for pass-by-reference\n        // If an argument is an array reference, the parameter name should point to the same array\n        let mut array_aliases: std::collections::HashMap\u003cString, String\u003e = std::collections::HashMap::new();\n        for (i, param) in func.params.iter().enumerate() {\n            if let Some(Some(array_name)) = array_refs.get(i) {\n                // This parameter is an array reference\n                // Create an alias: when we access param, we should access array_name\n                if param != array_name {\n                    array_aliases.insert(param.clone(), array_name.clone());\n                }\n            }\n        }\n        self.array_aliases = array_aliases;\n\n        // Set scalar parameters\n        for (i, param) in func.params.iter().enumerate() {\n            // Skip if this is an array reference\n            if let Some(Some(_)) = array_refs.get(i) {\n                continue;\n            }\n            let value = args.get(i).cloned().unwrap_or(Value::Uninitialized);\n            self.set_variable_value(param, value);\n        }\n\n        // Execute function body, passing the actual output\n        let result = match self.execute_block(\u0026func.body, output)? {\n            super::stmt::StmtResult::Return(v) =\u003e v,\n            _ =\u003e Value::Uninitialized,\n        };\n\n        // Clear array aliases\n        self.array_aliases.clear();\n\n        // Restore saved variables and remove parameters that weren't saved\n        for param in \u0026func.params {\n            if let Some(value) = saved_vars.get(param) {\n                self.set_variable_value(param, value.clone());\n            } else {\n                self.variables.remove(param);\n            }\n        }\n\n        // Restore any saved arrays or remove local arrays\n        for param in \u0026func.params {\n            if let Some(arr) = saved_arrays.get(param) {\n                self.arrays.insert(param.clone(), arr.clone());\n            } else if !array_refs.get(func.params.iter().position(|p| p == param).unwrap_or(usize::MAX))\n                .map(|r| r.is_some())\n                .unwrap_or(false)\n            {\n                self.arrays.remove(param);\n            }\n        }\n\n        Ok(result)\n    }\n\n    /// Generate a random number between 0 and 1 using xorshift64\n    fn next_random(\u0026mut self) -\u003e f64 {\n        let mut x = self.rand_state;\n        x ^= x \u003c\u003c 13;\n        x ^= x \u003e\u003e 7;\n        x ^= x \u003c\u003c 17;\n        self.rand_state = x;\n        (x as f64) / (u64::MAX as f64)\n    }\n}\n\nfn regex_sub_helper(re: \u0026regex::Regex, replacement: \u0026str, target: \u0026str, global: bool) -\u003e (String, usize) {\n    // Handle \u0026 in replacement (matched text)\n    let mut count = 0;\n\n    if global {\n        let result = re.replace_all(target, |caps: \u0026regex::Captures| {\n            count += 1;\n            replacement.replace(\"\u0026\", caps.get(0).map(|m| m.as_str()).unwrap_or(\"\"))\n        });\n        (result.to_string(), count)\n    } else {\n        let result = re.replace(target, |caps: \u0026regex::Captures| {\n            count += 1;\n            replacement.replace(\"\u0026\", caps.get(0).map(|m| m.as_str()).unwrap_or(\"\"))\n        });\n        (result.to_string(), count)\n    }\n}\n\n/// Simplified mktime implementation (UTC-based)\nfn simple_mktime(year: i64, month: i64, day: i64, hour: i64, min: i64, sec: i64) -\u003e i64 {\n    // Days in each month (non-leap year)\n    const DAYS_IN_MONTH: [i64; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    fn is_leap_year(year: i64) -\u003e bool {\n        (year % 4 == 0 \u0026\u0026 year % 100 != 0) || (year % 400 == 0)\n    }\n\n    fn days_in_year(year: i64) -\u003e i64 {\n        if is_leap_year(year) { 366 } else { 365 }\n    }\n\n    // Calculate days from epoch (1970-01-01)\n    let mut days: i64 = 0;\n\n    // Add days for complete years\n    for y in 1970..year {\n        days += days_in_year(y);\n    }\n    for y in year..1970 {\n        days -= days_in_year(y);\n    }\n\n    // Add days for complete months in current year\n    for m in 1..month {\n        let m_idx = (m - 1) as usize;\n        if m_idx \u003c 12 {\n            days += DAYS_IN_MONTH[m_idx];\n            if m == 2 \u0026\u0026 is_leap_year(year) {\n                days += 1;\n            }\n        }\n    }\n\n    // Add remaining days\n    days += day - 1;\n\n    // Convert to seconds\n    days * 86400 + hour * 3600 + min * 60 + sec\n}\n\n/// Simplified strftime implementation\nfn format_strftime(format: \u0026str, timestamp: u64) -\u003e String {\n    // Break down timestamp into components\n    let secs = timestamp as i64;\n\n    // Calculate year, month, day, etc.\n    let (year, month, day, hour, min, sec, wday, yday) = breakdown_time(secs);\n\n    let weekday_names = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n    let month_names = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    let weekday_full = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    let month_full = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n\n    let mut result = String::new();\n    let mut chars = format.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch == '%' {\n            match chars.next() {\n                Some('Y') =\u003e result.push_str(\u0026format!(\"{:04}\", year)),\n                Some('y') =\u003e result.push_str(\u0026format!(\"{:02}\", year % 100)),\n                Some('m') =\u003e result.push_str(\u0026format!(\"{:02}\", month)),\n                Some('d') =\u003e result.push_str(\u0026format!(\"{:02}\", day)),\n                Some('e') =\u003e result.push_str(\u0026format!(\"{:2}\", day)),\n                Some('H') =\u003e result.push_str(\u0026format!(\"{:02}\", hour)),\n                Some('M') =\u003e result.push_str(\u0026format!(\"{:02}\", min)),\n                Some('S') =\u003e result.push_str(\u0026format!(\"{:02}\", sec)),\n                Some('a') =\u003e result.push_str(weekday_names.get(wday as usize).unwrap_or(\u0026\"???\")),\n                Some('A') =\u003e result.push_str(weekday_full.get(wday as usize).unwrap_or(\u0026\"???\")),\n                Some('b') | Some('h') =\u003e result.push_str(month_names.get((month - 1) as usize).unwrap_or(\u0026\"???\")),\n                Some('B') =\u003e result.push_str(month_full.get((month - 1) as usize).unwrap_or(\u0026\"???\")),\n                Some('j') =\u003e result.push_str(\u0026format!(\"{:03}\", yday)),\n                Some('u') =\u003e result.push_str(\u0026format!(\"{}\", if wday == 0 { 7 } else { wday })),\n                Some('w') =\u003e result.push_str(\u0026format!(\"{}\", wday)),\n                Some('Z') =\u003e result.push_str(\"UTC\"),\n                Some('z') =\u003e result.push_str(\"+0000\"),\n                Some('%') =\u003e result.push('%'),\n                Some('n') =\u003e result.push('\\n'),\n                Some('t') =\u003e result.push('\\t'),\n                Some(c) =\u003e { result.push('%'); result.push(c); }\n                None =\u003e result.push('%'),\n            }\n        } else {\n            result.push(ch);\n        }\n    }\n\n    result\n}\n\n/// Break down epoch seconds into date/time components\nfn breakdown_time(secs: i64) -\u003e (i64, i64, i64, i64, i64, i64, i64, i64) {\n    const DAYS_IN_MONTH: [i64; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    fn is_leap_year(year: i64) -\u003e bool {\n        (year % 4 == 0 \u0026\u0026 year % 100 != 0) || (year % 400 == 0)\n    }\n\n    let sec = secs % 60;\n    let min = (secs / 60) % 60;\n    let hour = (secs / 3600) % 24;\n    let mut days = secs / 86400;\n\n    // wday: 0 = Sunday, 1970-01-01 was Thursday (4)\n    let wday = ((days + 4) % 7 + 7) % 7;\n\n    // Calculate year\n    let mut year = 1970i64;\n    loop {\n        let days_in_year = if is_leap_year(year) { 366 } else { 365 };\n        if days \u003e= days_in_year {\n            days -= days_in_year;\n            year += 1;\n        } else if days \u003c 0 {\n            year -= 1;\n            let days_in_year = if is_leap_year(year) { 366 } else { 365 };\n            days += days_in_year;\n        } else {\n            break;\n        }\n    }\n\n    let yday = days + 1; // 1-based day of year\n\n    // Calculate month and day\n    let mut month = 1i64;\n    for m in 0..12 {\n        let mut dim = DAYS_IN_MONTH[m];\n        if m == 1 \u0026\u0026 is_leap_year(year) {\n            dim += 1;\n        }\n        if days \u003c dim {\n            month = m as i64 + 1;\n            break;\n        }\n        days -= dim;\n    }\n    let day = days + 1;\n\n    (year, month, day, hour, min, sec, wday, yday)\n}\n","traces":[{"line":11,"address":[2508928,2511256,2511288],"length":1,"stats":{"Line":14}},{"line":19,"address":[2252738],"length":1,"stats":{"Line":17}},{"line":20,"address":[2633738],"length":1,"stats":{"Line":14}},{"line":21,"address":[2954910,2955022],"length":1,"stats":{"Line":23}},{"line":22,"address":[2633923,2634084],"length":1,"stats":{"Line":18}},{"line":23,"address":[2832855,2830535,2833015,2830695],"length":1,"stats":{"Line":21}},{"line":24,"address":[2509455,2509541],"length":1,"stats":{"Line":30}},{"line":25,"address":[2634303,2634415],"length":1,"stats":{"Line":12}},{"line":26,"address":[2833180,2830860,2831024,2833344],"length":1,"stats":{"Line":18}},{"line":27,"address":[2634426,2634672],"length":1,"stats":{"Line":14}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[2868229,2868256,2868277,2868208],"length":1,"stats":{"Line":46}},{"line":33,"address":[2253582,2253692],"length":1,"stats":{"Line":12}},{"line":36,"address":[2955925,2956904,2955840],"length":1,"stats":{"Line":24}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":41,"address":[2510725,2510662],"length":1,"stats":{"Line":6}},{"line":43,"address":[2542352],"length":1,"stats":{"Line":11}},{"line":44,"address":[3204898],"length":1,"stats":{"Line":3}},{"line":45,"address":[2868530,2868370],"length":1,"stats":{"Line":1}},{"line":46,"address":[2542455],"length":1,"stats":{"Line":1}},{"line":49,"address":[2895188],"length":1,"stats":{"Line":5}},{"line":50,"address":[2542502,2542449],"length":1,"stats":{"Line":15}},{"line":51,"address":[2254596],"length":1,"stats":{"Line":4}},{"line":54,"address":[2254788],"length":1,"stats":{"Line":0}},{"line":55,"address":[2956703,2956507],"length":1,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":63,"address":[2733834],"length":1,"stats":{"Line":10}},{"line":64,"address":[3401303],"length":1,"stats":{"Line":3}},{"line":65,"address":[3080352,3080425],"length":1,"stats":{"Line":7}},{"line":70,"address":[3088624,3090055,3091474],"length":1,"stats":{"Line":8}},{"line":71,"address":[3077517],"length":1,"stats":{"Line":8}},{"line":73,"address":[],"length":0,"stats":{"Line":19}},{"line":74,"address":[2731242],"length":1,"stats":{"Line":28}},{"line":78,"address":[3089208,3089078,3089319,3091472],"length":1,"stats":{"Line":21}},{"line":79,"address":[3398922],"length":1,"stats":{"Line":31}},{"line":81,"address":[3089380],"length":1,"stats":{"Line":30}},{"line":85,"address":[2731802,2732468,2732302,2731863],"length":1,"stats":{"Line":28}},{"line":86,"address":[3078380,3078797,3078324],"length":1,"stats":{"Line":14}},{"line":88,"address":[3399375,3399845],"length":1,"stats":{"Line":7}},{"line":91,"address":[2895456,2895726],"length":1,"stats":{"Line":23}},{"line":92,"address":[2868984,2868920],"length":1,"stats":{"Line":0}},{"line":95,"address":[3090567,3090478],"length":1,"stats":{"Line":24}},{"line":98,"address":[3400482],"length":1,"stats":{"Line":4}},{"line":99,"address":[3090919,3090774],"length":1,"stats":{"Line":11}},{"line":101,"address":[3079581,3080035],"length":1,"stats":{"Line":6}},{"line":104,"address":[2733398],"length":1,"stats":{"Line":9}},{"line":108,"address":[3066816,3068395,3068438],"length":1,"stats":{"Line":4}},{"line":109,"address":[3055634,3055684,3055765],"length":1,"stats":{"Line":7}},{"line":110,"address":[3376672],"length":1,"stats":{"Line":6}},{"line":112,"address":[3202384,3202368],"length":1,"stats":{"Line":8}},{"line":115,"address":[3057172,3055885,3056114,3056006],"length":1,"stats":{"Line":6}},{"line":116,"address":[3055960],"length":1,"stats":{"Line":15}},{"line":120,"address":[2881488,2881758],"length":1,"stats":{"Line":8}},{"line":121,"address":[2892808,2892876],"length":1,"stats":{"Line":0}},{"line":124,"address":[3067897,3068103,3067810],"length":1,"stats":{"Line":9}},{"line":125,"address":[3056849,3056902,3056711],"length":1,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":127,"address":[3377966],"length":1,"stats":{"Line":5}},{"line":129,"address":[3067997],"length":1,"stats":{"Line":1}},{"line":130,"address":[3068008],"length":1,"stats":{"Line":1}},{"line":131,"address":[3068018],"length":1,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":7}},{"line":137,"address":[2711581,2711631,2711714],"length":1,"stats":{"Line":6}},{"line":138,"address":[3068590],"length":1,"stats":{"Line":17}},{"line":140,"address":[3203184,3203168],"length":1,"stats":{"Line":17}},{"line":144,"address":[3057578,3057654],"length":1,"stats":{"Line":10}},{"line":145,"address":[3378988,3378910],"length":1,"stats":{"Line":9}},{"line":146,"address":[3069189,3069270],"length":1,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[3057836],"length":1,"stats":{"Line":1}},{"line":151,"address":[3069108],"length":1,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[3378784],"length":1,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[3378768],"length":1,"stats":{"Line":0}},{"line":158,"address":[3069016],"length":1,"stats":{"Line":0}},{"line":164,"address":[2712234,2712303],"length":1,"stats":{"Line":9}},{"line":165,"address":[3058131,3058168,3058446],"length":1,"stats":{"Line":10}},{"line":167,"address":[3058470,3058146],"length":1,"stats":{"Line":3}},{"line":171,"address":[3379436,3379540],"length":1,"stats":{"Line":5}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[2712835,2713510],"length":1,"stats":{"Line":2}},{"line":176,"address":[2712869,2712812],"length":1,"stats":{"Line":10}},{"line":177,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[2713051,2713216,2712914],"length":1,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[3059110,3059203],"length":1,"stats":{"Line":4}},{"line":186,"address":[3379806,3380434],"length":1,"stats":{"Line":5}},{"line":187,"address":[3059910,3059658],"length":1,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":9}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[2708344,2706288,2708524],"length":1,"stats":{"Line":2}},{"line":198,"address":[3063224],"length":1,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[3054198],"length":1,"stats":{"Line":1}},{"line":202,"address":[3054153,3052037],"length":1,"stats":{"Line":2}},{"line":203,"address":[3054126],"length":1,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[3373127,3373203],"length":1,"stats":{"Line":2}},{"line":212,"address":[2706838,2706779],"length":1,"stats":{"Line":2}},{"line":213,"address":[2706712],"length":1,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[3375049],"length":1,"stats":{"Line":0}},{"line":216,"address":[3373378,3375004],"length":1,"stats":{"Line":0}},{"line":217,"address":[3374977],"length":1,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[3063535,3063741],"length":1,"stats":{"Line":2}},{"line":226,"address":[3373571],"length":1,"stats":{"Line":2}},{"line":227,"address":[2707219,2707085],"length":1,"stats":{"Line":8}},{"line":229,"address":[3202064,3202099],"length":1,"stats":{"Line":11}},{"line":232,"address":[3052553,3052808],"length":1,"stats":{"Line":2}},{"line":235,"address":[3373709],"length":1,"stats":{"Line":1}},{"line":236,"address":[2707180,2707313],"length":1,"stats":{"Line":2}},{"line":238,"address":[3373905],"length":1,"stats":{"Line":1}},{"line":241,"address":[2865569,2865552],"length":1,"stats":{"Line":3}},{"line":242,"address":[3064278,3064356],"length":1,"stats":{"Line":2}},{"line":244,"address":[3064375],"length":1,"stats":{"Line":1}},{"line":245,"address":[2708043,2707823],"length":1,"stats":{"Line":11}},{"line":246,"address":[3053776,3053687],"length":1,"stats":{"Line":14}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[3398370,3397227,3394080],"length":1,"stats":{"Line":1}},{"line":255,"address":[3394342,3394258,3394205],"length":1,"stats":{"Line":8}},{"line":256,"address":[2726989],"length":1,"stats":{"Line":6}},{"line":258,"address":[2868640,2868624],"length":1,"stats":{"Line":6}},{"line":262,"address":[3084790,3084714],"length":1,"stats":{"Line":5}},{"line":263,"address":[2727403],"length":1,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":8}},{"line":275,"address":[2727601,2727670,2730912],"length":1,"stats":{"Line":7}},{"line":277,"address":[2730922,2727624],"length":1,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[2727871,2727938],"length":1,"stats":{"Line":8}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[3085509],"length":1,"stats":{"Line":3}},{"line":288,"address":[3085611],"length":1,"stats":{"Line":0}},{"line":292,"address":[3074271,3074464],"length":1,"stats":{"Line":7}},{"line":293,"address":[2728222],"length":1,"stats":{"Line":4}},{"line":294,"address":[2728344,2728283],"length":1,"stats":{"Line":2}},{"line":298,"address":[2728383,2728313],"length":1,"stats":{"Line":6}},{"line":299,"address":[],"length":0,"stats":{"Line":4}},{"line":302,"address":[3086283,3086188],"length":1,"stats":{"Line":8}},{"line":303,"address":[],"length":0,"stats":{"Line":6}},{"line":304,"address":[],"length":0,"stats":{"Line":6}},{"line":308,"address":[2729014],"length":1,"stats":{"Line":1}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[3086733,3086652],"length":1,"stats":{"Line":2}},{"line":311,"address":[2729411,2729884],"length":1,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[2730011,2730112],"length":1,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[2729453],"length":1,"stats":{"Line":1}},{"line":318,"address":[3087120,3087227],"length":1,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":325,"address":[3393984],"length":1,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[3072988],"length":1,"stats":{"Line":0}},{"line":335,"address":[3376346,3376555,3375296],"length":1,"stats":{"Line":1}},{"line":336,"address":[3065624,3065674,3065755],"length":1,"stats":{"Line":2}},{"line":337,"address":[2892416,2892437],"length":1,"stats":{"Line":3}},{"line":339,"address":[2892480,2892464],"length":1,"stats":{"Line":3}},{"line":343,"address":[3055513,3054685,3054610],"length":1,"stats":{"Line":4}},{"line":344,"address":[3055428],"length":1,"stats":{"Line":2}},{"line":345,"address":[3376442,3375843],"length":1,"stats":{"Line":1}},{"line":346,"address":[2709660],"length":1,"stats":{"Line":0}},{"line":347,"address":[3066237,3066584],"length":1,"stats":{"Line":1}},{"line":348,"address":[2709562],"length":1,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[2709451],"length":1,"stats":{"Line":1}},{"line":356,"address":[2287972,2287978,2286592],"length":1,"stats":{"Line":2}},{"line":357,"address":[2828425,2826869,2828533,2830089],"length":1,"stats":{"Line":3}},{"line":359,"address":[2286725,2287991],"length":1,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[2508788],"length":1,"stats":{"Line":0}},{"line":363,"address":[2644727],"length":1,"stats":{"Line":1}},{"line":365,"address":[2952980,2953082],"length":1,"stats":{"Line":2}},{"line":366,"address":[2632405,2633192],"length":1,"stats":{"Line":1}},{"line":367,"address":[2287967,2287706,2287220],"length":1,"stats":{"Line":0}},{"line":368,"address":[2633107],"length":1,"stats":{"Line":0}},{"line":369,"address":[2953511,2953455,2953676],"length":1,"stats":{"Line":3}},{"line":370,"address":[2643925,2644187,2643806],"length":1,"stats":{"Line":0}},{"line":371,"address":[2953843],"length":1,"stats":{"Line":0}},{"line":373,"address":[2287319],"length":1,"stats":{"Line":1}},{"line":378,"address":[3071664,3078358,3079335],"length":1,"stats":{"Line":11}},{"line":379,"address":[3381564],"length":1,"stats":{"Line":11}},{"line":381,"address":[2714724],"length":1,"stats":{"Line":11}},{"line":382,"address":[3060631],"length":1,"stats":{"Line":13}},{"line":384,"address":[2714895,2726484],"length":1,"stats":{"Line":6}},{"line":387,"address":[3071849],"length":1,"stats":{"Line":10}},{"line":388,"address":[2894208,2894192],"length":1,"stats":{"Line":9}},{"line":389,"address":[3381918,3392909],"length":1,"stats":{"Line":12}},{"line":390,"address":[],"length":0,"stats":{"Line":9}},{"line":393,"address":[2725884],"length":1,"stats":{"Line":3}},{"line":394,"address":[2725940],"length":1,"stats":{"Line":3}},{"line":395,"address":[3393255,3393200],"length":1,"stats":{"Line":6}},{"line":397,"address":[3083672,3083465],"length":1,"stats":{"Line":4}},{"line":399,"address":[3393523,3393367],"length":1,"stats":{"Line":6}},{"line":402,"address":[2714937],"length":1,"stats":{"Line":9}},{"line":403,"address":[3204416,3204400],"length":1,"stats":{"Line":10}},{"line":404,"address":[],"length":0,"stats":{"Line":14}},{"line":406,"address":[3082698,3082781,3082922],"length":1,"stats":{"Line":13}},{"line":408,"address":[2867470,2867532],"length":1,"stats":{"Line":3}},{"line":409,"address":[3203672],"length":1,"stats":{"Line":6}},{"line":410,"address":[3071666],"length":1,"stats":{"Line":4}},{"line":413,"address":[3060937],"length":1,"stats":{"Line":8}},{"line":414,"address":[2867584,2867600],"length":1,"stats":{"Line":24}},{"line":415,"address":[2724921,2715322,2724752],"length":1,"stats":{"Line":16}},{"line":416,"address":[3392023,3392148],"length":1,"stats":{"Line":16}},{"line":417,"address":[],"length":0,"stats":{"Line":7}},{"line":420,"address":[3382125],"length":1,"stats":{"Line":8}},{"line":421,"address":[2882384,2882400],"length":1,"stats":{"Line":15}},{"line":422,"address":[2724564,2715462],"length":1,"stats":{"Line":10}},{"line":425,"address":[3382252],"length":1,"stats":{"Line":7}},{"line":426,"address":[],"length":0,"stats":{"Line":9}},{"line":427,"address":[],"length":0,"stats":{"Line":6}},{"line":431,"address":[3382415],"length":1,"stats":{"Line":6}},{"line":432,"address":[3203897,3203888],"length":1,"stats":{"Line":9}},{"line":433,"address":[],"length":0,"stats":{"Line":3}},{"line":436,"address":[3061554],"length":1,"stats":{"Line":6}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":441,"address":[3061816],"length":1,"stats":{"Line":6}},{"line":442,"address":[],"length":0,"stats":{"Line":6}},{"line":443,"address":[2867849,2867840],"length":1,"stats":{"Line":6}},{"line":444,"address":[3073502],"length":1,"stats":{"Line":2}},{"line":447,"address":[3383102],"length":1,"stats":{"Line":5}},{"line":448,"address":[2893808,2893817],"length":1,"stats":{"Line":5}},{"line":449,"address":[3383524],"length":1,"stats":{"Line":3}},{"line":452,"address":[2716507],"length":1,"stats":{"Line":5}},{"line":453,"address":[2867081,2867072],"length":1,"stats":{"Line":6}},{"line":454,"address":[3074026],"length":1,"stats":{"Line":2}},{"line":457,"address":[3383704],"length":1,"stats":{"Line":5}},{"line":458,"address":[3204473,3204464],"length":1,"stats":{"Line":15}},{"line":459,"address":[3384048],"length":1,"stats":{"Line":5}},{"line":462,"address":[3074206],"length":1,"stats":{"Line":6}},{"line":463,"address":[3204144,3204153],"length":1,"stats":{"Line":9}},{"line":464,"address":[3063286],"length":1,"stats":{"Line":3}},{"line":467,"address":[],"length":0,"stats":{"Line":4}},{"line":469,"address":[],"length":0,"stats":{"Line":1}},{"line":470,"address":[],"length":0,"stats":{"Line":1}},{"line":473,"address":[2717543],"length":1,"stats":{"Line":4}},{"line":474,"address":[],"length":0,"stats":{"Line":3}},{"line":475,"address":[3063767,3069963,3070076],"length":1,"stats":{"Line":7}},{"line":476,"address":[3069979],"length":1,"stats":{"Line":2}},{"line":479,"address":[],"length":0,"stats":{"Line":2}},{"line":480,"address":[3391123],"length":1,"stats":{"Line":1}},{"line":481,"address":[3391151],"length":1,"stats":{"Line":3}},{"line":482,"address":[],"length":0,"stats":{"Line":1}},{"line":484,"address":[3081473],"length":1,"stats":{"Line":2}},{"line":485,"address":[3070223],"length":1,"stats":{"Line":2}},{"line":489,"address":[3063693],"length":1,"stats":{"Line":3}},{"line":490,"address":[3204736,3204720],"length":1,"stats":{"Line":7}},{"line":491,"address":[3075206,3081017],"length":1,"stats":{"Line":5}},{"line":493,"address":[3390658],"length":1,"stats":{"Line":2}},{"line":495,"address":[2723561],"length":1,"stats":{"Line":9}},{"line":496,"address":[3080849,3080979,3081024],"length":1,"stats":{"Line":6}},{"line":497,"address":[3390818],"length":1,"stats":{"Line":3}},{"line":503,"address":[2717913],"length":1,"stats":{"Line":3}},{"line":506,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[3385070],"length":1,"stats":{"Line":2}},{"line":508,"address":[3064099],"length":1,"stats":{"Line":3}},{"line":510,"address":[3064168],"length":1,"stats":{"Line":1}},{"line":513,"address":[3075256],"length":1,"stats":{"Line":3}},{"line":515,"address":[2866880,2866896],"length":1,"stats":{"Line":8}},{"line":516,"address":[3068525,3064495],"length":1,"stats":{"Line":2}},{"line":517,"address":[3204323,3204304],"length":1,"stats":{"Line":11}},{"line":520,"address":[3068665,3069478,3068837,3068586],"length":1,"stats":{"Line":11}},{"line":523,"address":[3080171,3080103],"length":1,"stats":{"Line":6}},{"line":524,"address":[2722815],"length":1,"stats":{"Line":3}},{"line":525,"address":[2722877],"length":1,"stats":{"Line":3}},{"line":526,"address":[3390082],"length":1,"stats":{"Line":3}},{"line":527,"address":[],"length":0,"stats":{"Line":3}},{"line":528,"address":[3080454],"length":1,"stats":{"Line":2}},{"line":531,"address":[2723157],"length":1,"stats":{"Line":1}},{"line":532,"address":[3069327],"length":1,"stats":{"Line":3}},{"line":534,"address":[],"length":0,"stats":{"Line":1}},{"line":538,"address":[3385398],"length":1,"stats":{"Line":4}},{"line":540,"address":[2718620],"length":1,"stats":{"Line":3}},{"line":542,"address":[3075932,3079474],"length":1,"stats":{"Line":3}},{"line":543,"address":[2722054],"length":1,"stats":{"Line":6}},{"line":544,"address":[3068176],"length":1,"stats":{"Line":2}},{"line":545,"address":[3203300],"length":1,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[3203337,3204796,3204784],"length":1,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":8}},{"line":556,"address":[3075801],"length":1,"stats":{"Line":4}},{"line":557,"address":[2867104,2867120],"length":1,"stats":{"Line":8}},{"line":558,"address":[2882240,2882256],"length":1,"stats":{"Line":11}},{"line":559,"address":[2883472,2883104,2883088,2883484],"length":1,"stats":{"Line":18}},{"line":560,"address":[3204176,3204193,3204608,3204624],"length":1,"stats":{"Line":23}},{"line":562,"address":[3386347,3386438],"length":1,"stats":{"Line":13}},{"line":565,"address":[3386629],"length":1,"stats":{"Line":4}},{"line":566,"address":[2719683,2721447],"length":1,"stats":{"Line":5}},{"line":567,"address":[3067015,3065837,3065691,3065764],"length":1,"stats":{"Line":8}},{"line":569,"address":[2719822],"length":1,"stats":{"Line":2}},{"line":570,"address":[3386897],"length":1,"stats":{"Line":3}},{"line":571,"address":[2719854],"length":1,"stats":{"Line":1}},{"line":572,"address":[3386924,3387039,3387166],"length":1,"stats":{"Line":5}},{"line":573,"address":[2720262,2720194,2720285],"length":1,"stats":{"Line":4}},{"line":574,"address":[3077577],"length":1,"stats":{"Line":2}},{"line":575,"address":[3387372],"length":1,"stats":{"Line":1}},{"line":576,"address":[2720437],"length":1,"stats":{"Line":2}},{"line":577,"address":[3078037],"length":1,"stats":{"Line":1}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":2}},{"line":582,"address":[],"length":0,"stats":{"Line":2}},{"line":583,"address":[2720911,2720950],"length":1,"stats":{"Line":0}},{"line":585,"address":[3078172],"length":1,"stats":{"Line":2}},{"line":589,"address":[3077075,3078404],"length":1,"stats":{"Line":0}},{"line":592,"address":[3388060,3388880],"length":1,"stats":{"Line":6}},{"line":595,"address":[3064703],"length":1,"stats":{"Line":4}},{"line":599,"address":[2635952,2638994,2640576],"length":1,"stats":{"Line":3}},{"line":607,"address":[2957074,2957197],"length":1,"stats":{"Line":8}},{"line":608,"address":[2542560,2542800,2542829,2542596],"length":1,"stats":{"Line":17}},{"line":612,"address":[2647549,2647640],"length":1,"stats":{"Line":8}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[2291155],"length":1,"stats":{"Line":12}},{"line":619,"address":[],"length":0,"stats":{"Line":4}},{"line":620,"address":[2291364,2291271],"length":1,"stats":{"Line":6}},{"line":621,"address":[2957951,2961208],"length":1,"stats":{"Line":7}},{"line":624,"address":[2515624],"length":1,"stats":{"Line":1}},{"line":625,"address":[2651616],"length":1,"stats":{"Line":1}},{"line":629,"address":[2512293],"length":1,"stats":{"Line":4}},{"line":632,"address":[],"length":0,"stats":{"Line":16}},{"line":634,"address":[2958522,2960758],"length":1,"stats":{"Line":8}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[2515162],"length":1,"stats":{"Line":8}},{"line":638,"address":[2651330,2651258],"length":1,"stats":{"Line":22}},{"line":642,"address":[2840692,2836276],"length":1,"stats":{"Line":4}},{"line":643,"address":[2637835],"length":1,"stats":{"Line":3}},{"line":644,"address":[2513289],"length":1,"stats":{"Line":1}},{"line":648,"address":[2637991],"length":1,"stats":{"Line":3}},{"line":651,"address":[2841181,2836765],"length":1,"stats":{"Line":4}},{"line":652,"address":[],"length":0,"stats":{"Line":8}},{"line":653,"address":[2294171,2294263],"length":1,"stats":{"Line":6}},{"line":655,"address":[2639496,2639604],"length":1,"stats":{"Line":6}},{"line":660,"address":[2649524],"length":1,"stats":{"Line":4}},{"line":661,"address":[2649677,2649933],"length":1,"stats":{"Line":7}},{"line":662,"address":[2638740,2638827],"length":1,"stats":{"Line":0}},{"line":663,"address":[2293756,2294021,2293505],"length":1,"stats":{"Line":15}},{"line":664,"address":[2161177,2161168],"length":1,"stats":{"Line":9}},{"line":665,"address":[2650553],"length":1,"stats":{"Line":3}},{"line":667,"address":[2960355],"length":1,"stats":{"Line":5}},{"line":671,"address":[2638459],"length":1,"stats":{"Line":3}},{"line":675,"address":[3381280],"length":1,"stats":{"Line":1}},{"line":676,"address":[3060261],"length":1,"stats":{"Line":1}},{"line":677,"address":[3071537],"length":1,"stats":{"Line":1}},{"line":678,"address":[2714469],"length":1,"stats":{"Line":1}},{"line":679,"address":[],"length":0,"stats":{"Line":1}},{"line":680,"address":[3381357],"length":1,"stats":{"Line":1}},{"line":681,"address":[],"length":0,"stats":{"Line":1}},{"line":685,"address":[3411264,3411711,3411705],"length":1,"stats":{"Line":11}},{"line":687,"address":[3090341],"length":1,"stats":{"Line":12}},{"line":689,"address":[3411374],"length":1,"stats":{"Line":12}},{"line":690,"address":[2865232],"length":1,"stats":{"Line":19}},{"line":691,"address":[2880984,2880818],"length":1,"stats":{"Line":3}},{"line":692,"address":[2880866,2881025,2881024],"length":1,"stats":{"Line":27}},{"line":694,"address":[3090542,3090743],"length":1,"stats":{"Line":6}},{"line":696,"address":[2400192],"length":1,"stats":{"Line":10}},{"line":697,"address":[2891858,2892024],"length":1,"stats":{"Line":7}},{"line":698,"address":[2891906,2892272,2892273],"length":1,"stats":{"Line":11}},{"line":700,"address":[3411467,3411634],"length":1,"stats":{"Line":9}},{"line":705,"address":[3081536],"length":1,"stats":{"Line":3}},{"line":709,"address":[3081312],"length":1,"stats":{"Line":3}},{"line":710,"address":[3092589,3092757],"length":1,"stats":{"Line":6}},{"line":713,"address":[3402288],"length":1,"stats":{"Line":3}},{"line":714,"address":[2391177],"length":1,"stats":{"Line":3}},{"line":718,"address":[3081639],"length":1,"stats":{"Line":3}},{"line":721,"address":[3092915,3093905],"length":1,"stats":{"Line":6}},{"line":722,"address":[3093897,3093002,3093910],"length":1,"stats":{"Line":6}},{"line":724,"address":[3402799,3403634],"length":1,"stats":{"Line":3}},{"line":725,"address":[3093866,3093126,3093879],"length":1,"stats":{"Line":0}},{"line":729,"address":[3081905,3081932],"length":1,"stats":{"Line":6}},{"line":730,"address":[3403405,3403021,3403386],"length":1,"stats":{"Line":2}},{"line":731,"address":[3403394],"length":1,"stats":{"Line":1}},{"line":732,"address":[3093658,3093779],"length":1,"stats":{"Line":1}},{"line":733,"address":[3093768,3093843,3093797],"length":1,"stats":{"Line":1}},{"line":734,"address":[3403608,3403571],"length":1,"stats":{"Line":0}},{"line":740,"address":[3082117,3082027],"length":1,"stats":{"Line":3}},{"line":743,"address":[3082138,3082344,3082091],"length":1,"stats":{"Line":6}},{"line":747,"address":[3408203,3405552,3411249],"length":1,"stats":{"Line":2}},{"line":749,"address":[3405634],"length":1,"stats":{"Line":2}},{"line":752,"address":[2394514],"length":1,"stats":{"Line":2}},{"line":754,"address":[3405783],"length":1,"stats":{"Line":3}},{"line":755,"address":[2394836],"length":1,"stats":{"Line":8}},{"line":756,"address":[3406296],"length":1,"stats":{"Line":3}},{"line":757,"address":[3085461],"length":1,"stats":{"Line":9}},{"line":759,"address":[3406810],"length":1,"stats":{"Line":3}},{"line":760,"address":[2395695,2395786],"length":1,"stats":{"Line":12}},{"line":762,"address":[3085911],"length":1,"stats":{"Line":9}},{"line":763,"address":[2395882],"length":1,"stats":{"Line":3}},{"line":764,"address":[3407150,3407092],"length":1,"stats":{"Line":12}},{"line":765,"address":[2396165,2396761],"length":1,"stats":{"Line":4}},{"line":766,"address":[3407343,3408209],"length":1,"stats":{"Line":0}},{"line":767,"address":[3407356,3408613],"length":1,"stats":{"Line":3}},{"line":768,"address":[3408863,3407394],"length":1,"stats":{"Line":2}},{"line":769,"address":[3097672,3099353],"length":1,"stats":{"Line":0}},{"line":770,"address":[3409363,3407470],"length":1,"stats":{"Line":6}},{"line":771,"address":[3099853,3097748],"length":1,"stats":{"Line":2}},{"line":772,"address":[2396374,2398661],"length":1,"stats":{"Line":2}},{"line":773,"address":[3100343,3097816],"length":1,"stats":{"Line":2}},{"line":774,"address":[2396439,2398966],"length":1,"stats":{"Line":0}},{"line":775,"address":[3086638,3089205],"length":1,"stats":{"Line":2}},{"line":776,"address":[2396511,2399148],"length":1,"stats":{"Line":0}},{"line":777,"address":[3407736,3410457],"length":1,"stats":{"Line":0}},{"line":778,"address":[3410695,3407766],"length":1,"stats":{"Line":0}},{"line":779,"address":[3410976,3407794],"length":1,"stats":{"Line":0}},{"line":780,"address":[3411192,3407824],"length":1,"stats":{"Line":0}},{"line":781,"address":[3101437,3098094],"length":1,"stats":{"Line":0}},{"line":782,"address":[3407897,3411202],"length":1,"stats":{"Line":0}},{"line":783,"address":[2396728,2399983],"length":1,"stats":{"Line":0}},{"line":784,"address":[3098183,3101452],"length":1,"stats":{"Line":0}},{"line":785,"address":[2400008,2396113],"length":1,"stats":{"Line":0}},{"line":786,"address":[3086225],"length":1,"stats":{"Line":0}},{"line":789,"address":[3411244,3407133],"length":1,"stats":{"Line":2}},{"line":793,"address":[3097289],"length":1,"stats":{"Line":2}},{"line":797,"address":[2392784],"length":1,"stats":{"Line":2}},{"line":800,"address":[2392560],"length":1,"stats":{"Line":3}},{"line":801,"address":[3094117,3093949],"length":1,"stats":{"Line":5}},{"line":804,"address":[3094288,3094200],"length":1,"stats":{"Line":2}},{"line":805,"address":[3404024,3404190,3404069],"length":1,"stats":{"Line":3}},{"line":806,"address":[3083187,3083142,3083299],"length":1,"stats":{"Line":3}},{"line":807,"address":[3094584,3094539,3094626],"length":1,"stats":{"Line":3}},{"line":810,"address":[2393268,2393433,2393226],"length":1,"stats":{"Line":4}},{"line":813,"address":[2393419],"length":1,"stats":{"Line":1}},{"line":814,"address":[3083543],"length":1,"stats":{"Line":3}},{"line":815,"address":[2393446],"length":1,"stats":{"Line":1}},{"line":816,"address":[2394305,2394385,2393489],"length":1,"stats":{"Line":2}},{"line":817,"address":[3084440,3083632,3084471],"length":1,"stats":{"Line":2}},{"line":818,"address":[3095753,3095712,3095766],"length":1,"stats":{"Line":2}},{"line":819,"address":[3404643],"length":1,"stats":{"Line":3}},{"line":820,"address":[3094957,3095603,3095576],"length":1,"stats":{"Line":0}},{"line":821,"address":[3095584,3095616],"length":1,"stats":{"Line":0}},{"line":822,"address":[2394266,2394310],"length":1,"stats":{"Line":0}},{"line":828,"address":[3083728,3083670,3083781],"length":1,"stats":{"Line":4}},{"line":831,"address":[3083736],"length":1,"stats":{"Line":1}},{"line":832,"address":[2393636,2393682,2394017],"length":1,"stats":{"Line":5}},{"line":833,"address":[3404956,3404985,3404883],"length":1,"stats":{"Line":5}},{"line":834,"address":[3404972,3405003,3405074],"length":1,"stats":{"Line":5}},{"line":835,"address":[3095316,3095280],"length":1,"stats":{"Line":0}},{"line":837,"address":[3095260],"length":1,"stats":{"Line":2}},{"line":838,"address":[3084152,3084101],"length":1,"stats":{"Line":11}},{"line":841,"address":[3095329,3095398,3095385],"length":1,"stats":{"Line":2}},{"line":843,"address":[3084294,3083897,3084230],"length":1,"stats":{"Line":11}},{"line":845,"address":[3084238],"length":1,"stats":{"Line":8}}],"covered":384,"coverable":460},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","interpreter","expr.rs"],"content":"use std::io::Write;\n\nuse crate::ast::*;\nuse crate::error::Result;\nuse crate::value::{compare_values, Value};\n\nuse super::Interpreter;\n\nimpl\u003c'a\u003e Interpreter\u003c'a\u003e {\n    /// Evaluate an expression (for contexts where we don't have output, like condition checking)\n    pub fn eval_expr(\u0026mut self, expr: \u0026Expr) -\u003e Result\u003cValue\u003e {\n        // Use a null writer for function calls that might need output\n        let mut null = std::io::sink();\n        self.eval_expr_with_output(expr, \u0026mut null)\n    }\n\n    /// Evaluate an expression with a writer for function calls that produce output\n    pub fn eval_expr_with_output\u003cW: Write\u003e(\u0026mut self, expr: \u0026Expr, output: \u0026mut W) -\u003e Result\u003cValue\u003e {\n        match expr {\n            Expr::Number(n, _) =\u003e Ok(Value::Number(*n)),\n\n            Expr::String(s, _) =\u003e Ok(Value::from_string(s.clone())),\n\n            Expr::Regex(pattern, _) =\u003e {\n                // Regex in expression context matches against $0\n                let record = self.record.clone();\n                let re = self.get_regex(pattern)?;\n                Ok(Value::Number(if re.is_match(\u0026record) { 1.0 } else { 0.0 }))\n            }\n\n            Expr::Var(name, _) =\u003e Ok(self.get_variable(name)),\n\n            Expr::Field(expr, _) =\u003e {\n                let index = self.eval_expr_with_output(expr, output)?.to_number() as usize;\n                Ok(Value::from_string(self.get_field(index)))\n            }\n\n            Expr::ArrayAccess { array, indices, .. } =\u003e {\n                let key_parts: Result\u003cVec\u003cValue\u003e\u003e = indices.iter()\n                    .map(|e| self.eval_expr_with_output(e, output))\n                    .collect();\n                let key = self.make_array_key(\u0026key_parts?);\n                Ok(self.get_array_element(array, \u0026key))\n            }\n\n            Expr::Binary { left, op, right, .. } =\u003e {\n                self.eval_binary_op_with_output(left, *op, right, output)\n            }\n\n            Expr::Unary { op, operand, .. } =\u003e {\n                self.eval_unary_op_with_output(*op, operand, output)\n            }\n\n            Expr::Assign { target, op, value, .. } =\u003e {\n                self.eval_assignment_with_output(target, *op, value, output)\n            }\n\n            Expr::PreIncrement(expr, _) =\u003e {\n                let current = self.eval_expr_with_output(expr, output)?.to_number();\n                let new_val = Value::Number(current + 1.0);\n                self.assign_to_lvalue(expr, new_val.clone())?;\n                Ok(new_val)\n            }\n\n            Expr::PreDecrement(expr, _) =\u003e {\n                let current = self.eval_expr_with_output(expr, output)?.to_number();\n                let new_val = Value::Number(current - 1.0);\n                self.assign_to_lvalue(expr, new_val.clone())?;\n                Ok(new_val)\n            }\n\n            Expr::PostIncrement(expr, _) =\u003e {\n                let current = self.eval_expr_with_output(expr, output)?.to_number();\n                let new_val = Value::Number(current + 1.0);\n                self.assign_to_lvalue(expr, new_val)?;\n                Ok(Value::Number(current))\n            }\n\n            Expr::PostDecrement(expr, _) =\u003e {\n                let current = self.eval_expr_with_output(expr, output)?.to_number();\n                let new_val = Value::Number(current - 1.0);\n                self.assign_to_lvalue(expr, new_val)?;\n                Ok(Value::Number(current))\n            }\n\n            Expr::Ternary { condition, then_expr, else_expr, .. } =\u003e {\n                let cond = self.eval_expr_with_output(condition, output)?;\n                if cond.is_truthy() {\n                    self.eval_expr_with_output(then_expr, output)\n                } else {\n                    self.eval_expr_with_output(else_expr, output)\n                }\n            }\n\n            Expr::Call { name, args, location } =\u003e {\n                self.call_function(name, args, *location, output)\n            }\n\n            Expr::InArray { key, array, .. } =\u003e {\n                let key_parts: Result\u003cVec\u003cValue\u003e\u003e = key.iter()\n                    .map(|e| self.eval_expr_with_output(e, output))\n                    .collect();\n                let key_str = self.make_array_key(\u0026key_parts?);\n                Ok(Value::Number(if self.array_key_exists(array, \u0026key_str) { 1.0 } else { 0.0 }))\n            }\n\n            Expr::Match { expr, pattern, negated, .. } =\u003e {\n                let string = self.eval_expr_with_output(expr, output)?.to_string_val();\n                let pattern_str = match pattern.as_ref() {\n                    Expr::Regex(p, _) =\u003e p.clone(),\n                    other =\u003e self.eval_expr_with_output(other, output)?.to_string_val(),\n                };\n                let re = self.get_regex(\u0026pattern_str)?;\n                let matches = re.is_match(\u0026string);\n                let result = if *negated { !matches } else { matches };\n                Ok(Value::Number(if result { 1.0 } else { 0.0 }))\n            }\n\n            Expr::Concat(parts, _) =\u003e {\n                let mut result = String::new();\n                for part in parts {\n                    result.push_str(\u0026self.eval_expr_with_output(part, output)?.to_string_val());\n                }\n                Ok(Value::from_string(result))\n            }\n\n            Expr::Getline { var, input, location } =\u003e {\n                self.eval_getline(var.as_ref(), input.as_ref(), *location)\n            }\n\n            Expr::Group(expr, _) =\u003e self.eval_expr_with_output(expr, output),\n        }\n    }\n\n    fn eval_binary_op_with_output\u003cW: Write\u003e(\n        \u0026mut self,\n        left: \u0026Expr,\n        op: BinaryOp,\n        right: \u0026Expr,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        // Short-circuit evaluation for logical operators\n        match op {\n            BinaryOp::And =\u003e {\n                let l = self.eval_expr_with_output(left, output)?;\n                if !l.is_truthy() {\n                    return Ok(Value::Number(0.0));\n                }\n                let r = self.eval_expr_with_output(right, output)?;\n                return Ok(Value::Number(if r.is_truthy() { 1.0 } else { 0.0 }));\n            }\n            BinaryOp::Or =\u003e {\n                let l = self.eval_expr_with_output(left, output)?;\n                if l.is_truthy() {\n                    return Ok(Value::Number(1.0));\n                }\n                let r = self.eval_expr_with_output(right, output)?;\n                return Ok(Value::Number(if r.is_truthy() { 1.0 } else { 0.0 }));\n            }\n            _ =\u003e {}\n        }\n\n        let l = self.eval_expr_with_output(left, output)?;\n        let r = self.eval_expr_with_output(right, output)?;\n\n        match op {\n            BinaryOp::Add =\u003e Ok(Value::Number(l.to_number() + r.to_number())),\n            BinaryOp::Sub =\u003e Ok(Value::Number(l.to_number() - r.to_number())),\n            BinaryOp::Mul =\u003e Ok(Value::Number(l.to_number() * r.to_number())),\n            BinaryOp::Div =\u003e {\n                let divisor = r.to_number();\n                if divisor == 0.0 {\n                    Ok(Value::Number(f64::INFINITY))\n                } else {\n                    Ok(Value::Number(l.to_number() / divisor))\n                }\n            }\n            BinaryOp::Mod =\u003e {\n                let divisor = r.to_number();\n                if divisor == 0.0 {\n                    Ok(Value::Number(f64::NAN))\n                } else {\n                    Ok(Value::Number(l.to_number() % divisor))\n                }\n            }\n            BinaryOp::Pow =\u003e Ok(Value::Number(l.to_number().powf(r.to_number()))),\n            BinaryOp::Lt =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_lt() { 1.0 } else { 0.0 })),\n            BinaryOp::Le =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_le() { 1.0 } else { 0.0 })),\n            BinaryOp::Gt =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_gt() { 1.0 } else { 0.0 })),\n            BinaryOp::Ge =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_ge() { 1.0 } else { 0.0 })),\n            BinaryOp::Eq =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_eq() { 1.0 } else { 0.0 })),\n            BinaryOp::Ne =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_ne() { 1.0 } else { 0.0 })),\n            BinaryOp::Concat =\u003e {\n                let mut s = l.to_string_val();\n                s.push_str(\u0026r.to_string_val());\n                Ok(Value::from_string(s))\n            }\n            BinaryOp::And | BinaryOp::Or =\u003e unreachable!(), // Handled above\n        }\n    }\n\n    fn eval_unary_op_with_output\u003cW: Write\u003e(\n        \u0026mut self,\n        op: UnaryOp,\n        operand: \u0026Expr,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        let val = self.eval_expr_with_output(operand, output)?;\n        match op {\n            UnaryOp::Neg =\u003e Ok(Value::Number(-val.to_number())),\n            UnaryOp::Pos =\u003e Ok(Value::Number(val.to_number())),\n            UnaryOp::Not =\u003e Ok(Value::Number(if val.is_truthy() { 0.0 } else { 1.0 })),\n        }\n    }\n\n    fn eval_assignment_with_output\u003cW: Write\u003e(\n        \u0026mut self,\n        target: \u0026Expr,\n        op: AssignOp,\n        value: \u0026Expr,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        let new_value = match op {\n            AssignOp::Assign =\u003e self.eval_expr_with_output(value, output)?,\n            _ =\u003e {\n                let current = self.eval_expr_with_output(target, output)?;\n                let rhs = self.eval_expr_with_output(value, output)?;\n                match op {\n                    AssignOp::AddAssign =\u003e Value::Number(current.to_number() + rhs.to_number()),\n                    AssignOp::SubAssign =\u003e Value::Number(current.to_number() - rhs.to_number()),\n                    AssignOp::MulAssign =\u003e Value::Number(current.to_number() * rhs.to_number()),\n                    AssignOp::DivAssign =\u003e Value::Number(current.to_number() / rhs.to_number()),\n                    AssignOp::ModAssign =\u003e Value::Number(current.to_number() % rhs.to_number()),\n                    AssignOp::PowAssign =\u003e Value::Number(current.to_number().powf(rhs.to_number())),\n                    AssignOp::Assign =\u003e unreachable!(),\n                }\n            }\n        };\n\n        self.assign_to_lvalue(target, new_value.clone())?;\n        Ok(new_value)\n    }\n\n    /// Evaluate getline expression\n    pub(crate) fn eval_getline(\n        \u0026mut self,\n        var: Option\u003c\u0026String\u003e,\n        input: Option\u003c\u0026GetlineInput\u003e,\n        _location: crate::error::SourceLocation,\n    ) -\u003e Result\u003cValue\u003e {\n        use std::io::BufRead;\n\n        match input {\n            None =\u003e {\n                // getline with no input source - read from current input\n                // This is handled by the main loop, so we return 0 (EOF) here\n                Ok(Value::Number(0.0))\n            }\n            Some(GetlineInput::File(file_expr)) =\u003e {\n                let filename = self.eval_expr(file_expr)?.to_string_val();\n\n                // Get or open the file\n                if !self.input_files.contains_key(\u0026filename) {\n                    match std::fs::File::open(\u0026filename) {\n                        Ok(file) =\u003e {\n                            self.input_files.insert(filename.clone(), std::io::BufReader::new(file));\n                        }\n                        Err(_) =\u003e return Ok(Value::Number(-1.0)), // Error\n                    }\n                }\n\n                let reader = self.input_files.get_mut(\u0026filename).unwrap();\n                let mut line = String::new();\n                match reader.read_line(\u0026mut line) {\n                    Ok(0) =\u003e Ok(Value::Number(0.0)), // EOF\n                    Ok(_) =\u003e {\n                        // Remove trailing newline\n                        if line.ends_with('\\n') {\n                            line.pop();\n                            if line.ends_with('\\r') {\n                                line.pop();\n                            }\n                        }\n\n                        if let Some(var_name) = var {\n                            self.set_variable_value(var_name, Value::from_string(line));\n                        } else {\n                            self.set_record(\u0026line);\n                        }\n                        Ok(Value::Number(1.0)) // Success\n                    }\n                    Err(_) =\u003e Ok(Value::Number(-1.0)), // Error\n                }\n            }\n            Some(GetlineInput::Pipe(cmd_expr)) =\u003e {\n                let cmd = self.eval_expr(cmd_expr)?.to_string_val();\n\n                // Get or open the pipe\n                if !self.pipes.contains_key(\u0026cmd) {\n                    match std::process::Command::new(\"sh\")\n                        .arg(\"-c\")\n                        .arg(\u0026cmd)\n                        .stdout(std::process::Stdio::piped())\n                        .spawn()\n                    {\n                        Ok(mut child) =\u003e {\n                            let stdout = child.stdout.take().unwrap();\n                            self.pipes.insert(cmd.clone(), super::PipeInput {\n                                child,\n                                reader: std::io::BufReader::new(stdout),\n                            });\n                        }\n                        Err(_) =\u003e return Ok(Value::Number(-1.0)), // Error\n                    }\n                }\n\n                let pipe = self.pipes.get_mut(\u0026cmd).unwrap();\n                let mut line = String::new();\n                match pipe.reader.read_line(\u0026mut line) {\n                    Ok(0) =\u003e Ok(Value::Number(0.0)), // EOF\n                    Ok(_) =\u003e {\n                        // Remove trailing newline\n                        if line.ends_with('\\n') {\n                            line.pop();\n                            if line.ends_with('\\r') {\n                                line.pop();\n                            }\n                        }\n\n                        if let Some(var_name) = var {\n                            self.set_variable_value(var_name, Value::from_string(line));\n                        } else {\n                            self.set_record(\u0026line);\n                        }\n                        Ok(Value::Number(1.0)) // Success\n                    }\n                    Err(_) =\u003e Ok(Value::Number(-1.0)), // Error\n                }\n            }\n        }\n    }\n\n    pub fn assign_to_lvalue(\u0026mut self, target: \u0026Expr, value: Value) -\u003e Result\u003c()\u003e {\n        match target {\n            Expr::Var(name, _) =\u003e {\n                self.set_variable_value(name, value);\n            }\n            Expr::Field(expr, _) =\u003e {\n                let index = self.eval_expr(expr)?.to_number() as usize;\n                self.set_field(index, value.to_string_val());\n            }\n            Expr::ArrayAccess { array, indices, .. } =\u003e {\n                let key_parts: Result\u003cVec\u003cValue\u003e\u003e = indices.iter().map(|e| self.eval_expr(e)).collect();\n                let key = self.make_array_key(\u0026key_parts?);\n                self.set_array_element(array, \u0026key, value);\n            }\n            _ =\u003e {\n                // Invalid lvalue, but we'll just ignore for now\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[2696992],"length":1,"stats":{"Line":5}},{"line":13,"address":[3042274],"length":1,"stats":{"Line":20}},{"line":14,"address":[3042294],"length":1,"stats":{"Line":16}},{"line":18,"address":[2250792,2248080,2250786],"length":1,"stats":{"Line":38}},{"line":19,"address":[],"length":0,"stats":{"Line":27}},{"line":20,"address":[2604627],"length":1,"stats":{"Line":24}},{"line":22,"address":[2593478],"length":1,"stats":{"Line":14}},{"line":24,"address":[2469081],"length":1,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[2595494,2593661],"length":1,"stats":{"Line":8}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[2248559],"length":1,"stats":{"Line":7}},{"line":33,"address":[2752020,2763172],"length":1,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":11}},{"line":35,"address":[2251282],"length":1,"stats":{"Line":6}},{"line":38,"address":[2605147],"length":1,"stats":{"Line":4}},{"line":39,"address":[2752109,2763261],"length":1,"stats":{"Line":4}},{"line":40,"address":[2469427],"length":1,"stats":{"Line":12}},{"line":42,"address":[2215640,2213109],"length":1,"stats":{"Line":4}},{"line":43,"address":[2596843],"length":1,"stats":{"Line":4}},{"line":46,"address":[2752244,2763396],"length":1,"stats":{"Line":9}},{"line":47,"address":[2216192,2213237],"length":1,"stats":{"Line":18}},{"line":50,"address":[2469628],"length":1,"stats":{"Line":5}},{"line":51,"address":[2608579,2605452],"length":1,"stats":{"Line":10}},{"line":54,"address":[2915261],"length":1,"stats":{"Line":25}},{"line":55,"address":[],"length":0,"stats":{"Line":45}},{"line":58,"address":[2213455],"length":1,"stats":{"Line":3}},{"line":59,"address":[2249222,2252524],"length":1,"stats":{"Line":6}},{"line":60,"address":[2598056],"length":1,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[2915423],"length":1,"stats":{"Line":1}},{"line":66,"address":[2598589,2594422],"length":1,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[2474644,2474476],"length":1,"stats":{"Line":2}},{"line":69,"address":[2474819],"length":1,"stats":{"Line":1}},{"line":72,"address":[2469931],"length":1,"stats":{"Line":4}},{"line":73,"address":[2249346,2254362],"length":1,"stats":{"Line":8}},{"line":74,"address":[2920920],"length":1,"stats":{"Line":4}},{"line":75,"address":[2219043],"length":1,"stats":{"Line":4}},{"line":76,"address":[2219295],"length":1,"stats":{"Line":4}},{"line":79,"address":[2469993],"length":1,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[2611933],"length":1,"stats":{"Line":1}},{"line":82,"address":[2255559],"length":1,"stats":{"Line":1}},{"line":83,"address":[2759016,2770168],"length":1,"stats":{"Line":1}},{"line":86,"address":[2470055],"length":1,"stats":{"Line":3}},{"line":87,"address":[2922079,2915670],"length":1,"stats":{"Line":6}},{"line":88,"address":[2476856,2476791],"length":1,"stats":{"Line":6}},{"line":89,"address":[2770644,2759653,2759492,2770805],"length":1,"stats":{"Line":6}},{"line":91,"address":[2256262,2256331],"length":1,"stats":{"Line":6}},{"line":95,"address":[2594685],"length":1,"stats":{"Line":11}},{"line":96,"address":[2752921,2764073],"length":1,"stats":{"Line":14}},{"line":99,"address":[2753049,2764201],"length":1,"stats":{"Line":2}},{"line":100,"address":[2249761],"length":1,"stats":{"Line":2}},{"line":101,"address":[2282528,2282552],"length":1,"stats":{"Line":6}},{"line":103,"address":[2256552,2249832],"length":1,"stats":{"Line":2}},{"line":104,"address":[2602027],"length":1,"stats":{"Line":2}},{"line":107,"address":[2249899],"length":1,"stats":{"Line":2}},{"line":108,"address":[2753280,2771500,2760348,2764432],"length":1,"stats":{"Line":4}},{"line":109,"address":[2760745,2771897],"length":1,"stats":{"Line":2}},{"line":110,"address":[2221877,2221944],"length":1,"stats":{"Line":4}},{"line":111,"address":[2602832,2602881,2603716],"length":1,"stats":{"Line":2}},{"line":113,"address":[2603236,2602861],"length":1,"stats":{"Line":4}},{"line":114,"address":[2478869],"length":1,"stats":{"Line":2}},{"line":115,"address":[2258326],"length":1,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[2606404],"length":1,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[2773029,2761877],"length":1,"stats":{"Line":0}},{"line":127,"address":[2764554,2753402],"length":1,"stats":{"Line":2}},{"line":128,"address":[2606541],"length":1,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[2482047,2482074,2480848],"length":1,"stats":{"Line":8}},{"line":143,"address":[2605511],"length":1,"stats":{"Line":9}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[2605843,2605677],"length":1,"stats":{"Line":2}},{"line":146,"address":[2617239,2617304],"length":1,"stats":{"Line":4}},{"line":147,"address":[2481491],"length":1,"stats":{"Line":2}},{"line":149,"address":[2606165,2606203,2606620],"length":1,"stats":{"Line":4}},{"line":150,"address":[2481848,2481913],"length":1,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[2605770,2606654],"length":1,"stats":{"Line":3}},{"line":154,"address":[2261608,2261673],"length":1,"stats":{"Line":6}},{"line":155,"address":[2782032,2776736],"length":1,"stats":{"Line":3}},{"line":157,"address":[2928024,2928451,2927902],"length":1,"stats":{"Line":6}},{"line":158,"address":[2782331,2777096,2777035,2782392],"length":1,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":7}},{"line":164,"address":[2928601,2928664],"length":1,"stats":{"Line":14}},{"line":166,"address":[2226924],"length":1,"stats":{"Line":6}},{"line":167,"address":[2483321,2483754],"length":1,"stats":{"Line":6}},{"line":168,"address":[2483906,2483348],"length":1,"stats":{"Line":13}},{"line":169,"address":[2928974,2929640],"length":1,"stats":{"Line":8}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[2619238,2620010],"length":1,"stats":{"Line":4}},{"line":172,"address":[2227960,2227828,2228071],"length":1,"stats":{"Line":5}},{"line":173,"address":[2620061],"length":1,"stats":{"Line":1}},{"line":175,"address":[2608776,2608912],"length":1,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[2619262,2620273],"length":1,"stats":{"Line":7}},{"line":180,"address":[2228223,2228339,2228091],"length":1,"stats":{"Line":4}},{"line":181,"address":[2620324],"length":1,"stats":{"Line":0}},{"line":183,"address":[2778828,2784124,2778963,2784259],"length":1,"stats":{"Line":5}},{"line":186,"address":[2779068,2783115,2777819,2784364],"length":1,"stats":{"Line":4}},{"line":187,"address":[2930446,2929078],"length":1,"stats":{"Line":8}},{"line":188,"address":[2608084,2609585],"length":1,"stats":{"Line":15}},{"line":189,"address":[2483539,2485173],"length":1,"stats":{"Line":10}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[2229147,2227247],"length":1,"stats":{"Line":12}},{"line":192,"address":[2608204,2610237],"length":1,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[2931422,2929291],"length":1,"stats":{"Line":4}},{"line":195,"address":[2785507,2785563,2780211,2780267],"length":1,"stats":{"Line":4}},{"line":196,"address":[2486005],"length":1,"stats":{"Line":2}},{"line":202,"address":[2773712,2775248,2774470,2774496,2774464,2775254],"length":1,"stats":{"Line":5}},{"line":208,"address":[2604701],"length":1,"stats":{"Line":5}},{"line":209,"address":[2604872],"length":1,"stats":{"Line":5}},{"line":210,"address":[2480347,2480452],"length":1,"stats":{"Line":8}},{"line":211,"address":[2224013,2224232],"length":1,"stats":{"Line":4}},{"line":212,"address":[2616211,2616497],"length":1,"stats":{"Line":8}},{"line":216,"address":[2622048,2624092,2624086],"length":1,"stats":{"Line":19}},{"line":223,"address":[2788004,2785972],"length":1,"stats":{"Line":26}},{"line":224,"address":[2230147,2229986],"length":1,"stats":{"Line":20}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[2230075,2230377],"length":1,"stats":{"Line":3}},{"line":227,"address":[2230527,2230578],"length":1,"stats":{"Line":6}},{"line":228,"address":[2622987],"length":1,"stats":{"Line":3}},{"line":229,"address":[2266605,2266795],"length":1,"stats":{"Line":6}},{"line":230,"address":[2487237,2487489],"length":1,"stats":{"Line":6}},{"line":231,"address":[2789227,2786909,2787195,2788941],"length":1,"stats":{"Line":6}},{"line":232,"address":[2487624,2487285],"length":1,"stats":{"Line":2}},{"line":233,"address":[2623155,2623539],"length":1,"stats":{"Line":2}},{"line":234,"address":[2932939,2933373],"length":1,"stats":{"Line":2}},{"line":240,"address":[2267314,2266095],"length":1,"stats":{"Line":32}},{"line":241,"address":[],"length":0,"stats":{"Line":12}},{"line":245,"address":[2691465,2692685,2690112],"length":1,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[2690455],"length":1,"stats":{"Line":1}},{"line":260,"address":[3035470],"length":1,"stats":{"Line":2}},{"line":263,"address":[3035900],"length":1,"stats":{"Line":1}},{"line":264,"address":[2691003,2690955],"length":1,"stats":{"Line":3}},{"line":265,"address":[3036163],"length":1,"stats":{"Line":2}},{"line":266,"address":[3357291,3357333,3357498,3357209],"length":1,"stats":{"Line":3}},{"line":268,"address":[2691026],"length":1,"stats":{"Line":0}},{"line":272,"address":[3047872,3047245],"length":1,"stats":{"Line":3}},{"line":273,"address":[3036658],"length":1,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":5}},{"line":275,"address":[3036925],"length":1,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[2691969,2692066],"length":1,"stats":{"Line":4}},{"line":279,"address":[3048469],"length":1,"stats":{"Line":2}},{"line":280,"address":[3358244],"length":1,"stats":{"Line":2}},{"line":281,"address":[3037306],"length":1,"stats":{"Line":0}},{"line":285,"address":[3048582,3048425],"length":1,"stats":{"Line":3}},{"line":286,"address":[3048598,3048687],"length":1,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[3037539],"length":1,"stats":{"Line":1}},{"line":292,"address":[3048075],"length":1,"stats":{"Line":0}},{"line":295,"address":[3356417],"length":1,"stats":{"Line":3}},{"line":296,"address":[3356440,3358797],"length":1,"stats":{"Line":6}},{"line":299,"address":[3049437],"length":1,"stats":{"Line":1}},{"line":300,"address":[3038219,3038502],"length":1,"stats":{"Line":4}},{"line":301,"address":[],"length":0,"stats":{"Line":3}},{"line":302,"address":[3038386],"length":1,"stats":{"Line":3}},{"line":303,"address":[2693311],"length":1,"stats":{"Line":3}},{"line":304,"address":[2693377],"length":1,"stats":{"Line":3}},{"line":306,"address":[3049903],"length":1,"stats":{"Line":3}},{"line":307,"address":[2693573,2693643],"length":1,"stats":{"Line":6}},{"line":308,"address":[3050154,3050072,3050288],"length":1,"stats":{"Line":9}},{"line":309,"address":[2693784],"length":1,"stats":{"Line":3}},{"line":310,"address":[2693824],"length":1,"stats":{"Line":3}},{"line":313,"address":[3038525],"length":1,"stats":{"Line":0}},{"line":317,"address":[3360476,3359282],"length":1,"stats":{"Line":6}},{"line":318,"address":[3050760],"length":1,"stats":{"Line":3}},{"line":319,"address":[3050772,3050993,3050860],"length":1,"stats":{"Line":9}},{"line":320,"address":[3039748],"length":1,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[2694677,2694762],"length":1,"stats":{"Line":6}},{"line":324,"address":[3051274],"length":1,"stats":{"Line":3}},{"line":325,"address":[3361049],"length":1,"stats":{"Line":3}},{"line":326,"address":[3051354],"length":1,"stats":{"Line":0}},{"line":330,"address":[2694792,2694928],"length":1,"stats":{"Line":5}},{"line":331,"address":[2695009,2694944],"length":1,"stats":{"Line":4}},{"line":333,"address":[3040143,3040406],"length":1,"stats":{"Line":2}},{"line":335,"address":[3040293],"length":1,"stats":{"Line":1}},{"line":337,"address":[3050898],"length":1,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":15}},{"line":344,"address":[3361599],"length":1,"stats":{"Line":23}},{"line":345,"address":[3361712],"length":1,"stats":{"Line":14}},{"line":346,"address":[2695516,2695726],"length":1,"stats":{"Line":30}},{"line":348,"address":[3051998],"length":1,"stats":{"Line":3}},{"line":349,"address":[3052769,3052013,3052238],"length":1,"stats":{"Line":6}},{"line":350,"address":[3041459],"length":1,"stats":{"Line":3}},{"line":352,"address":[3040785],"length":1,"stats":{"Line":12}},{"line":353,"address":[3362560,3361841],"length":1,"stats":{"Line":44}},{"line":354,"address":[2696918,2696412],"length":1,"stats":{"Line":12}},{"line":355,"address":[],"length":0,"stats":{"Line":10}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":12}}],"covered":180,"coverable":204},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","interpreter","mod.rs"],"content":"mod builtins;\nmod expr;\npub mod stmt;\n\nuse std::collections::HashMap;\nuse std::io::{BufRead, BufReader, Write};\nuse std::fs::File;\nuse std::process::{Child, ChildStdout, ChildStdin};\n\nuse crate::ast::*;\nuse crate::error::{Error, Result};\nuse crate::value::Value;\n\nuse regex::Regex;\n\n/// Input source for getline from pipe\npub struct PipeInput {\n    #[allow(dead_code)]\n    child: Child,\n    reader: BufReader\u003cChildStdout\u003e,\n}\n\n/// Output destination for print/printf redirection\npub enum OutputFile {\n    File(File),\n    Pipe(ChildStdin),\n}\n\nimpl Write for OutputFile {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e std::io::Result\u003cusize\u003e {\n        match self {\n            OutputFile::File(f) =\u003e f.write(buf),\n            OutputFile::Pipe(p) =\u003e p.write(buf),\n        }\n    }\n\n    fn flush(\u0026mut self) -\u003e std::io::Result\u003c()\u003e {\n        match self {\n            OutputFile::File(f) =\u003e f.flush(),\n            OutputFile::Pipe(p) =\u003e p.flush(),\n        }\n    }\n}\n\n/// The AWK interpreter runtime\npub struct Interpreter\u003c'a\u003e {\n    /// The parsed program\n    program: \u0026'a Program,\n\n    /// Global variables\n    pub(crate) variables: HashMap\u003cString, Value\u003e,\n\n    /// Associative arrays\n    pub(crate) arrays: HashMap\u003cString, HashMap\u003cString, Value\u003e\u003e,\n\n    /// User-defined functions\n    pub(crate) functions: HashMap\u003cString, \u0026'a FunctionDef\u003e,\n\n    /// Built-in variables\n    /// Field separator (FS)\n    pub(crate) fs: String,\n    /// Output field separator (OFS)\n    pub(crate) ofs: String,\n    /// Record separator (RS)\n    pub(crate) rs: String,\n    /// Output record separator (ORS)\n    pub(crate) ors: String,\n    /// Number format for output (OFMT)\n    pub(crate) ofmt: String,\n    /// Conversion format (CONVFMT)\n    pub(crate) convfmt: String,\n    /// Subscript separator (SUBSEP)\n    pub(crate) subsep: String,\n    /// Field pattern (FPAT) - gawk extension\n    pub(crate) fpat: String,\n    /// Fixed field widths (FIELDWIDTHS) - gawk extension\n    pub(crate) fieldwidths: String,\n\n    /// Mode flags\n    pub(crate) posix_mode: bool,\n    pub(crate) traditional_mode: bool,\n\n    /// Current record ($0)\n    pub(crate) record: String,\n    /// Current fields ($1, $2, ...)\n    pub(crate) fields: Vec\u003cString\u003e,\n    /// Number of fields (NF)\n    pub(crate) nf: usize,\n    /// Record number (NR)\n    pub(crate) nr: usize,\n    /// File record number (FNR)\n    pub(crate) fnr: usize,\n    /// Current filename (FILENAME)\n    pub(crate) filename: String,\n\n    /// RSTART and RLENGTH from match()\n    pub(crate) rstart: usize,\n    pub(crate) rlength: i32,\n\n    /// Control flow flags\n    should_exit: bool,\n    exit_code: i32,\n    should_next: bool,\n    should_nextfile: bool,\n\n    /// Open files for output redirection\n    pub(crate) output_files: HashMap\u003cString, OutputFile\u003e,\n\n    /// Open files for input (getline)\n    pub(crate) input_files: HashMap\u003cString, BufReader\u003cFile\u003e\u003e,\n\n    /// Open pipes for input (getline from command)\n    pub(crate) pipes: HashMap\u003cString, PipeInput\u003e,\n\n    /// Compiled regex cache\n    pub(crate) regex_cache: HashMap\u003cString, Regex\u003e,\n\n    /// Range pattern state (for /start/,/end/ patterns)\n    range_states: HashMap\u003cusize, bool\u003e,\n\n    /// Random number generator state\n    pub(crate) rand_seed: u64,\n    pub(crate) rand_state: u64,\n\n    /// Command line arguments (ARGC, ARGV)\n    pub(crate) argc: usize,\n    pub(crate) argv: Vec\u003cString\u003e,\n\n    /// Environment variables (ENVIRON)\n    pub(crate) environ: HashMap\u003cString, String\u003e,\n\n    /// Array aliases for pass-by-reference in functions\n    /// Maps parameter name -\u003e actual array name\n    pub(crate) array_aliases: HashMap\u003cString, String\u003e,\n}\n\nimpl\u003c'a\u003e Interpreter\u003c'a\u003e {\n    pub fn new(program: \u0026'a Program) -\u003e Self {\n        let mut functions = HashMap::new();\n        for func in \u0026program.functions {\n            functions.insert(func.name.clone(), func);\n        }\n\n        // Initialize environment variables\n        let environ: HashMap\u003cString, String\u003e = std::env::vars().collect();\n\n        // Initialize random seed from current time\n        use std::time::{SystemTime, UNIX_EPOCH};\n        let rand_seed = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_nanos() as u64)\n            .unwrap_or(12345);\n\n        Self {\n            program,\n            variables: HashMap::new(),\n            arrays: HashMap::new(),\n            functions,\n            fs: \" \".to_string(),\n            ofs: \" \".to_string(),\n            rs: \"\\n\".to_string(),\n            ors: \"\\n\".to_string(),\n            ofmt: \"%.6g\".to_string(),\n            convfmt: \"%.6g\".to_string(),\n            subsep: \"\\x1c\".to_string(),\n            fpat: String::new(),\n            fieldwidths: String::new(),\n            posix_mode: false,\n            traditional_mode: false,\n            record: String::new(),\n            fields: Vec::new(),\n            nf: 0,\n            nr: 0,\n            fnr: 0,\n            filename: String::new(),\n            rstart: 0,\n            rlength: -1,\n            should_exit: false,\n            exit_code: 0,\n            should_next: false,\n            should_nextfile: false,\n            output_files: HashMap::new(),\n            input_files: HashMap::new(),\n            pipes: HashMap::new(),\n            regex_cache: HashMap::new(),\n            range_states: HashMap::new(),\n            rand_seed,\n            rand_state: rand_seed,\n            argc: 0,\n            argv: Vec::new(),\n            environ,\n            array_aliases: HashMap::new(),\n        }\n    }\n\n    /// Set command line arguments (ARGC and ARGV)\n    pub fn set_args(\u0026mut self, args: Vec\u003cString\u003e) {\n        self.argc = args.len();\n        self.argv = args;\n    }\n\n    /// Set the field separator\n    pub fn set_fs(\u0026mut self, fs: \u0026str) {\n        self.fs = fs.to_string();\n        // Clear FPAT and FIELDWIDTHS when FS is set\n        self.fpat.clear();\n        self.fieldwidths.clear();\n    }\n\n    /// Set POSIX strict mode\n    pub fn set_posix_mode(\u0026mut self, enabled: bool) {\n        self.posix_mode = enabled;\n        if enabled {\n            self.traditional_mode = false;\n        }\n    }\n\n    /// Set traditional AWK mode (no gawk extensions)\n    pub fn set_traditional_mode(\u0026mut self, enabled: bool) {\n        self.traditional_mode = enabled;\n        if enabled {\n            self.posix_mode = false;\n        }\n    }\n\n    /// Set a variable before execution\n    pub fn set_variable(\u0026mut self, name: \u0026str, value: \u0026str) {\n        self.variables.insert(name.to_string(), Value::from_string(value.to_string()));\n    }\n\n    /// Set the current filename (FILENAME)\n    pub fn set_filename(\u0026mut self, filename: \u0026str) {\n        self.filename = filename.to_string();\n    }\n\n    /// Run the AWK program with given input\n    pub fn run\u003cR: BufRead, W: Write\u003e(\u0026mut self, inputs: Vec\u003cR\u003e, output: \u0026mut W) -\u003e Result\u003ci32\u003e {\n        // Execute BEGIN rules\n        for rule in \u0026self.program.rules {\n            if matches!(\u0026rule.pattern, Some(Pattern::Begin)) {\n                if let Some(action) = \u0026rule.action {\n                    self.execute_block(action, output)?;\n                }\n                if self.should_exit {\n                    return Ok(self.exit_code);\n                }\n            }\n        }\n\n        // Process input files\n        for input in inputs {\n            self.fnr = 0;\n\n            // Execute BEGINFILE rules (gawk extension)\n            for rule in \u0026self.program.rules {\n                if matches!(\u0026rule.pattern, Some(Pattern::BeginFile)) {\n                    if let Some(action) = \u0026rule.action {\n                        self.execute_block(action, output)?;\n                    }\n                    if self.should_exit {\n                        return Ok(self.exit_code);\n                    }\n                }\n            }\n\n            self.process_input(input, output)?;\n\n            // Execute ENDFILE rules (gawk extension)\n            for rule in \u0026self.program.rules {\n                if matches!(\u0026rule.pattern, Some(Pattern::EndFile)) {\n                    if let Some(action) = \u0026rule.action {\n                        self.execute_block(action, output)?;\n                    }\n                    if self.should_exit {\n                        return Ok(self.exit_code);\n                    }\n                }\n            }\n\n            if self.should_exit {\n                return Ok(self.exit_code);\n            }\n        }\n\n        // Execute END rules\n        for rule in \u0026self.program.rules {\n            if matches!(\u0026rule.pattern, Some(Pattern::End)) {\n                if let Some(action) = \u0026rule.action {\n                    self.execute_block(action, output)?;\n                }\n            }\n        }\n\n        Ok(self.exit_code)\n    }\n\n    fn process_input\u003cR: BufRead, W: Write\u003e(\u0026mut self, mut input: R, output: \u0026mut W) -\u003e Result\u003c()\u003e {\n        // Check for paragraph mode (RS = \"\")\n        if self.rs.is_empty() {\n            return self.process_input_paragraph_mode(input, output);\n        }\n\n        let mut line = String::new();\n\n        loop {\n            line.clear();\n            let bytes_read = input.read_line(\u0026mut line).map_err(Error::Io)?;\n            if bytes_read == 0 {\n                break; // EOF\n            }\n\n            // Remove record separator\n            if line.ends_with('\\n') {\n                line.pop();\n                if line.ends_with('\\r') {\n                    line.pop();\n                }\n            }\n\n            self.nr += 1;\n            self.fnr += 1;\n            self.set_record(\u0026line);\n\n            self.process_current_record(output)?;\n\n            if self.should_nextfile {\n                self.should_nextfile = false;\n                break;\n            }\n\n            if self.should_exit {\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Process input in paragraph mode (RS = \"\")\n    /// Blank lines separate records; multiple blank lines count as one separator\n    fn process_input_paragraph_mode\u003cR: BufRead, W: Write\u003e(\u0026mut self, mut input: R, output: \u0026mut W) -\u003e Result\u003c()\u003e {\n        let mut line = String::new();\n        let mut record = String::new();\n        let mut in_record = false;\n\n        loop {\n            line.clear();\n            let bytes_read = input.read_line(\u0026mut line).map_err(Error::Io)?;\n\n            // Check if line is blank (empty or only whitespace)\n            let is_blank = line.trim().is_empty();\n\n            if bytes_read == 0 {\n                // EOF - process any remaining record\n                if !record.is_empty() {\n                    // Remove trailing newline\n                    while record.ends_with('\\n') || record.ends_with('\\r') {\n                        record.pop();\n                    }\n                    self.nr += 1;\n                    self.fnr += 1;\n                    self.set_record(\u0026record);\n                    self.process_current_record(output)?;\n                }\n                break;\n            }\n\n            if is_blank {\n                // Blank line - end of record if we're in one\n                if in_record \u0026\u0026 !record.is_empty() {\n                    // Remove trailing newline\n                    while record.ends_with('\\n') || record.ends_with('\\r') {\n                        record.pop();\n                    }\n                    self.nr += 1;\n                    self.fnr += 1;\n                    self.set_record(\u0026record);\n                    self.process_current_record(output)?;\n\n                    record.clear();\n                    in_record = false;\n\n                    if self.should_nextfile || self.should_exit {\n                        break;\n                    }\n                }\n            } else {\n                // Non-blank line - add to record\n                if in_record {\n                    record.push('\\n');\n                }\n                // Remove trailing newline from line before adding\n                if line.ends_with('\\n') {\n                    line.pop();\n                    if line.ends_with('\\r') {\n                        line.pop();\n                    }\n                }\n                record.push_str(\u0026line);\n                in_record = true;\n            }\n        }\n\n        if self.should_nextfile {\n            self.should_nextfile = false;\n        }\n\n        Ok(())\n    }\n\n    /// Process the current record through all matching rules\n    fn process_current_record\u003cW: Write\u003e(\u0026mut self, output: \u0026mut W) -\u003e Result\u003c()\u003e {\n        for (idx, rule) in self.program.rules.iter().enumerate() {\n            // Skip special patterns that are handled separately\n            if matches!(\u0026rule.pattern,\n                Some(Pattern::Begin) | Some(Pattern::End) |\n                Some(Pattern::BeginFile) | Some(Pattern::EndFile)) {\n                continue;\n            }\n\n            let matches = self.pattern_matches(\u0026rule.pattern, idx)?;\n            if matches {\n                if let Some(action) = \u0026rule.action {\n                    self.execute_block(action, output)?;\n                } else {\n                    // Default action is to print $0\n                    writeln!(output, \"{}\", self.record).map_err(Error::Io)?;\n                }\n            }\n\n            if self.should_next {\n                self.should_next = false;\n                break;\n            }\n\n            if self.should_nextfile || self.should_exit {\n                break;\n            }\n        }\n        Ok(())\n    }\n\n    pub(crate) fn set_record(\u0026mut self, record: \u0026str) {\n        self.record = record.to_string();\n        self.split_fields();\n    }\n\n    fn split_fields(\u0026mut self) {\n        self.fields.clear();\n\n        if self.record.is_empty() {\n            self.nf = 0;\n            return;\n        }\n\n        // Pre-estimate capacity to reduce reallocations\n        let estimated_fields = self.record.len() / 8 + 1;\n        self.fields.reserve(estimated_fields.min(64));\n\n        // Check for FPAT (field pattern) - gawk extension\n        if !self.fpat.is_empty() \u0026\u0026 !self.posix_mode \u0026\u0026 !self.traditional_mode {\n            self.split_fields_fpat();\n            return;\n        }\n\n        // Check for FIELDWIDTHS - gawk extension\n        if !self.fieldwidths.is_empty() \u0026\u0026 !self.posix_mode \u0026\u0026 !self.traditional_mode {\n            self.split_fields_widths();\n            return;\n        }\n\n        // Standard FS-based splitting\n        if self.fs == \" \" {\n            // Special case: split on runs of whitespace, trimming leading/trailing\n            // Use byte-based iteration for ASCII optimization\n            self.fields.extend(self.record.split_whitespace().map(String::from));\n        } else if self.fs.len() == 1 {\n            // Single character separator - most common case, optimize for it\n            let sep = self.fs.as_bytes()[0];\n            let bytes = self.record.as_bytes();\n            let mut start = 0;\n\n            for (i, \u0026b) in bytes.iter().enumerate() {\n                if b == sep {\n                    self.fields.push(self.record[start..i].to_string());\n                    start = i + 1;\n                }\n            }\n            // Don't forget the last field\n            self.fields.push(self.record[start..].to_string());\n        } else {\n            // Regex separator - cache the compiled regex\n            let fs = self.fs.clone();\n            let record = self.record.clone();\n            if let Some(regex) = self.regex_cache.get(\u0026fs) {\n                self.fields.extend(regex.split(\u0026record).map(String::from));\n            } else if let Ok(regex) = Regex::new(\u0026fs) {\n                self.fields.extend(regex.split(\u0026record).map(String::from));\n                self.regex_cache.insert(fs, regex);\n            } else {\n                // If regex fails, treat as literal string\n                self.fields.extend(record.split(\u0026fs).map(String::from));\n            }\n        }\n\n        self.nf = self.fields.len();\n    }\n\n    /// Split fields using FPAT (field pattern matching)\n    fn split_fields_fpat(\u0026mut self) {\n        let fpat = self.fpat.clone();\n        let record = self.record.clone();\n\n        if let Some(regex) = self.regex_cache.get(\u0026fpat) {\n            for mat in regex.find_iter(\u0026record) {\n                self.fields.push(mat.as_str().to_string());\n            }\n        } else if let Ok(regex) = Regex::new(\u0026fpat) {\n            for mat in regex.find_iter(\u0026record) {\n                self.fields.push(mat.as_str().to_string());\n            }\n            self.regex_cache.insert(fpat, regex);\n        }\n\n        self.nf = self.fields.len();\n    }\n\n    /// Split fields using FIELDWIDTHS (fixed-width fields)\n    fn split_fields_widths(\u0026mut self) {\n        let widths: Vec\u003cusize\u003e = self.fieldwidths\n            .split_whitespace()\n            .filter_map(|s| s.parse().ok())\n            .collect();\n\n        let mut pos = 0;\n        let chars: Vec\u003cchar\u003e = self.record.chars().collect();\n\n        for width in widths {\n            if pos \u003e= chars.len() {\n                break;\n            }\n            let end = (pos + width).min(chars.len());\n            let field: String = chars[pos..end].iter().collect();\n            self.fields.push(field);\n            pos = end;\n        }\n\n        self.nf = self.fields.len();\n    }\n\n    #[inline]\n    pub(crate) fn get_field(\u0026self, index: usize) -\u003e String {\n        if index == 0 {\n            self.record.clone()\n        } else if index \u003c= self.fields.len() {\n            self.fields[index - 1].clone()\n        } else {\n            String::new()\n        }\n    }\n\n    /// Get field reference without cloning (for read-only access)\n    #[inline]\n    #[allow(dead_code)]\n    pub(crate) fn get_field_ref(\u0026self, index: usize) -\u003e \u0026str {\n        if index == 0 {\n            \u0026self.record\n        } else if index \u003c= self.fields.len() {\n            \u0026self.fields[index - 1]\n        } else {\n            \"\"\n        }\n    }\n\n    pub(crate) fn set_field(\u0026mut self, index: usize, value: String) {\n        if index == 0 {\n            self.record = value;\n            self.split_fields();\n        } else {\n            // Extend fields if necessary\n            while self.fields.len() \u003c index {\n                self.fields.push(String::new());\n            }\n            self.fields[index - 1] = value;\n            self.nf = self.fields.len();\n            // Rebuild $0\n            self.record = self.fields.join(\u0026self.ofs);\n        }\n    }\n\n    fn pattern_matches(\u0026mut self, pattern: \u0026Option\u003cPattern\u003e, rule_idx: usize) -\u003e Result\u003cbool\u003e {\n        match pattern {\n            None =\u003e Ok(true), // No pattern means always match\n            Some(Pattern::Begin) | Some(Pattern::End) |\n            Some(Pattern::BeginFile) | Some(Pattern::EndFile) =\u003e Ok(false),\n            Some(Pattern::Expr(expr)) =\u003e {\n                let val = self.eval_expr(expr)?;\n                Ok(val.is_truthy())\n            }\n            Some(Pattern::Regex(regex)) =\u003e {\n                let record = self.record.clone();\n                let re = self.get_regex(regex)?;\n                Ok(re.is_match(\u0026record))\n            }\n            Some(Pattern::Range { start, end }) =\u003e {\n                let active = self.range_states.get(\u0026rule_idx).copied().unwrap_or(false);\n                if !active {\n                    // Check if start pattern matches\n                    if self.pattern_matches(\u0026Some(start.as_ref().clone()), rule_idx)? {\n                        self.range_states.insert(rule_idx, true);\n                        return Ok(true);\n                    }\n                    Ok(false)\n                } else {\n                    // Range is active, check if end pattern matches\n                    if self.pattern_matches(\u0026Some(end.as_ref().clone()), rule_idx)? {\n                        self.range_states.insert(rule_idx, false);\n                    }\n                    Ok(true)\n                }\n            }\n            Some(Pattern::And(left, right)) =\u003e {\n                Ok(self.pattern_matches(\u0026Some(left.as_ref().clone()), rule_idx)?\n                    \u0026\u0026 self.pattern_matches(\u0026Some(right.as_ref().clone()), rule_idx)?)\n            }\n            Some(Pattern::Or(left, right)) =\u003e {\n                Ok(self.pattern_matches(\u0026Some(left.as_ref().clone()), rule_idx)?\n                    || self.pattern_matches(\u0026Some(right.as_ref().clone()), rule_idx)?)\n            }\n            Some(Pattern::Not(inner)) =\u003e {\n                Ok(!self.pattern_matches(\u0026Some(inner.as_ref().clone()), rule_idx)?)\n            }\n        }\n    }\n\n    pub(crate) fn get_regex(\u0026mut self, pattern: \u0026str) -\u003e Result\u003c\u0026Regex\u003e {\n        if !self.regex_cache.contains_key(pattern) {\n            let regex = Regex::new(pattern).map_err(Error::Regex)?;\n            self.regex_cache.insert(pattern.to_string(), regex);\n        }\n        Ok(self.regex_cache.get(pattern).unwrap())\n    }\n\n    pub(crate) fn get_variable(\u0026self, name: \u0026str) -\u003e Value {\n        // Check special variables first\n        match name {\n            \"NF\" =\u003e Value::Number(self.nf as f64),\n            \"NR\" =\u003e Value::Number(self.nr as f64),\n            \"FNR\" =\u003e Value::Number(self.fnr as f64),\n            \"FS\" =\u003e Value::from_string(self.fs.clone()),\n            \"OFS\" =\u003e Value::from_string(self.ofs.clone()),\n            \"RS\" =\u003e Value::from_string(self.rs.clone()),\n            \"ORS\" =\u003e Value::from_string(self.ors.clone()),\n            \"OFMT\" =\u003e Value::from_string(self.ofmt.clone()),\n            \"CONVFMT\" =\u003e Value::from_string(self.convfmt.clone()),\n            \"SUBSEP\" =\u003e Value::from_string(self.subsep.clone()),\n            \"FILENAME\" =\u003e Value::from_string(self.filename.clone()),\n            \"RSTART\" =\u003e Value::Number(self.rstart as f64),\n            \"RLENGTH\" =\u003e Value::Number(self.rlength as f64),\n            \"ARGC\" =\u003e Value::Number(self.argc as f64),\n            // gawk extensions\n            \"FPAT\" =\u003e Value::from_string(self.fpat.clone()),\n            \"FIELDWIDTHS\" =\u003e Value::from_string(self.fieldwidths.clone()),\n            _ =\u003e self.variables.get(name).cloned().unwrap_or(Value::Uninitialized),\n        }\n    }\n\n    /// Get an element from ARGV, ENVIRON, or PROCINFO arrays\n    pub(crate) fn get_special_array(\u0026self, array: \u0026str, key: \u0026str) -\u003e Option\u003cValue\u003e {\n        match array {\n            \"ARGV\" =\u003e {\n                key.parse::\u003cusize\u003e().ok()\n                    .and_then(|i| self.argv.get(i))\n                    .map(|s| Value::from_string(s.clone()))\n            }\n            \"ENVIRON\" =\u003e {\n                self.environ.get(key).map(|s| Value::from_string(s.clone()))\n            }\n            \"PROCINFO\" =\u003e {\n                // gawk PROCINFO array - system information\n                match key {\n                    \"version\" =\u003e Some(Value::from_string(env!(\"CARGO_PKG_VERSION\").to_string())),\n                    \"strftime\" =\u003e Some(Value::from_string(\"%a %b %e %H:%M:%S %Z %Y\".to_string())),\n                    \"FS\" =\u003e {\n                        if !self.fpat.is_empty() {\n                            Some(Value::from_string(\"FPAT\".to_string()))\n                        } else if !self.fieldwidths.is_empty() {\n                            Some(Value::from_string(\"FIELDWIDTHS\".to_string()))\n                        } else {\n                            Some(Value::from_string(\"FS\".to_string()))\n                        }\n                    }\n                    \"identifiers\" =\u003e Some(Value::Number(0.0)), // Not implemented\n                    \"pid\" =\u003e Some(Value::Number(std::process::id() as f64)),\n                    \"ppid\" =\u003e Some(Value::Number(0.0)), // Not easily available in Rust\n                    \"uid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    \"gid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    \"euid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    \"egid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    \"pgrpid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    _ =\u003e Some(Value::Uninitialized),\n                }\n            }\n            _ =\u003e None,\n        }\n    }\n\n    pub(crate) fn set_variable_value(\u0026mut self, name: \u0026str, value: Value) {\n        // Handle special variables\n        match name {\n            \"NF\" =\u003e {\n                let new_nf = value.to_number() as usize;\n                if new_nf \u003c self.nf {\n                    self.fields.truncate(new_nf);\n                } else {\n                    while self.fields.len() \u003c new_nf {\n                        self.fields.push(String::new());\n                    }\n                }\n                self.nf = new_nf;\n                self.record = self.fields.join(\u0026self.ofs);\n            }\n            \"FS\" =\u003e {\n                self.fs = value.to_string_val();\n                // Clear FPAT and FIELDWIDTHS when FS is set\n                self.fpat.clear();\n                self.fieldwidths.clear();\n            }\n            \"OFS\" =\u003e self.ofs = value.to_string_val(),\n            \"RS\" =\u003e self.rs = value.to_string_val(),\n            \"ORS\" =\u003e self.ors = value.to_string_val(),\n            \"OFMT\" =\u003e self.ofmt = value.to_string_val(),\n            \"CONVFMT\" =\u003e self.convfmt = value.to_string_val(),\n            \"SUBSEP\" =\u003e self.subsep = value.to_string_val(),\n            // gawk extensions\n            \"FPAT\" =\u003e {\n                self.fpat = value.to_string_val();\n                // FPAT takes precedence over FS and FIELDWIDTHS\n                self.fieldwidths.clear();\n            }\n            \"FIELDWIDTHS\" =\u003e {\n                self.fieldwidths = value.to_string_val();\n                // FIELDWIDTHS takes precedence over FS\n                self.fpat.clear();\n            }\n            _ =\u003e {\n                self.variables.insert(name.to_string(), value);\n            }\n        }\n    }\n\n    /// Resolve array name through aliases (for pass-by-reference in functions)\n    fn resolve_array_name\u003c'b\u003e(\u0026'b self, array: \u0026'b str) -\u003e \u0026'b str {\n        self.array_aliases.get(array).map(|s| s.as_str()).unwrap_or(array)\n    }\n\n    pub(crate) fn get_array_element(\u0026self, array: \u0026str, key: \u0026str) -\u003e Value {\n        let array = self.resolve_array_name(array);\n\n        // Check for special arrays first\n        if let Some(val) = self.get_special_array(array, key) {\n            return val;\n        }\n\n        self.arrays\n            .get(array)\n            .and_then(|arr| arr.get(key))\n            .cloned()\n            .unwrap_or(Value::Uninitialized)\n    }\n\n    pub(crate) fn set_array_element(\u0026mut self, array: \u0026str, key: \u0026str, value: Value) {\n        let array = self.resolve_array_name(array).to_string();\n        self.arrays\n            .entry(array)\n            .or_default()\n            .insert(key.to_string(), value);\n    }\n\n    pub(crate) fn array_key_exists(\u0026self, array: \u0026str, key: \u0026str) -\u003e bool {\n        let array = self.resolve_array_name(array);\n\n        // Check special arrays\n        match array {\n            \"ARGV\" =\u003e {\n                key.parse::\u003cusize\u003e().ok()\n                    .map(|i| i \u003c self.argv.len())\n                    .unwrap_or(false)\n            }\n            \"ENVIRON\" =\u003e self.environ.contains_key(key),\n            _ =\u003e {\n                self.arrays\n                    .get(array)\n                    .map(|arr| arr.contains_key(key))\n                    .unwrap_or(false)\n            }\n        }\n    }\n\n    pub(crate) fn delete_array_element(\u0026mut self, array: \u0026str, key: \u0026str) {\n        let array = self.resolve_array_name(array).to_string();\n        if let Some(arr) = self.arrays.get_mut(\u0026array) {\n            arr.remove(key);\n        }\n    }\n\n    pub(crate) fn make_array_key(\u0026self, indices: \u0026[Value]) -\u003e String {\n        indices\n            .iter()\n            .map(|v| v.to_string_val())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\u0026self.subsep)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::lexer::Lexer;\n    use crate::parser::Parser;\n    use std::io::Cursor;\n\n    fn run_awk(program: \u0026str, input: \u0026str) -\u003e String {\n        let mut lexer = Lexer::new(program);\n        let tokens = lexer.tokenize().unwrap();\n        let mut parser = Parser::new(tokens);\n        let ast = parser.parse().unwrap();\n\n        let mut interpreter = Interpreter::new(\u0026ast);\n        let mut output = Vec::new();\n        let inputs: Vec\u003cstd::io::BufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = if input.is_empty() {\n            vec![]\n        } else {\n            vec![std::io::BufReader::new(Cursor::new(input))]\n        };\n\n        interpreter.run(inputs, \u0026mut output).unwrap();\n        String::from_utf8(output).unwrap()\n    }\n\n    #[test]\n    fn test_begin_print() {\n        let output = run_awk(r#\"BEGIN { print \"hello\" }\"#, \"\");\n        assert_eq!(output, \"hello\\n\");\n    }\n\n    #[test]\n    fn test_print_field() {\n        let output = run_awk(\"{ print $1 }\", \"one two three\");\n        assert_eq!(output, \"one\\n\");\n    }\n\n    #[test]\n    fn test_print_multiple_fields() {\n        let output = run_awk(\"{ print $1, $3 }\", \"one two three\");\n        assert_eq!(output, \"one three\\n\");\n    }\n\n    #[test]\n    fn test_arithmetic() {\n        let output = run_awk(\"BEGIN { print 2 + 3 * 4 }\", \"\");\n        assert_eq!(output, \"14\\n\");\n    }\n\n    #[test]\n    fn test_variable() {\n        let output = run_awk(\"BEGIN { x = 5; print x }\", \"\");\n        assert_eq!(output, \"5\\n\");\n    }\n\n    #[test]\n    fn test_if_statement() {\n        let output = run_awk(\"BEGIN { x = 10; if (x \u003e 5) print \\\"big\\\" }\", \"\");\n        assert_eq!(output, \"big\\n\");\n    }\n\n    #[test]\n    fn test_while_loop() {\n        let output = run_awk(\"BEGIN { i = 1; while (i \u003c= 3) { print i; i++ } }\", \"\");\n        assert_eq!(output, \"1\\n2\\n3\\n\");\n    }\n\n    #[test]\n    fn test_pattern_match() {\n        let output = run_awk(\"/two/ { print $0 }\", \"one\\ntwo\\nthree\");\n        assert_eq!(output, \"two\\n\");\n    }\n\n    #[test]\n    fn test_for_loop() {\n        let output = run_awk(\"BEGIN { for (i = 1; i \u003c= 3; i++) print i }\", \"\");\n        assert_eq!(output, \"1\\n2\\n3\\n\");\n    }\n\n    #[test]\n    fn test_for_in_loop() {\n        let output = run_awk(\"BEGIN { a[1]=1; a[2]=2; for (k in a) count++; print count }\", \"\");\n        assert_eq!(output, \"2\\n\");\n    }\n\n    #[test]\n    fn test_do_while() {\n        let output = run_awk(\"BEGIN { i = 0; do { i++ } while (i \u003c 3); print i }\", \"\");\n        assert_eq!(output, \"3\\n\");\n    }\n\n    #[test]\n    fn test_break() {\n        let output = run_awk(\"BEGIN { for (i=1; i\u003c=10; i++) { if (i==3) break; print i } }\", \"\");\n        assert_eq!(output, \"1\\n2\\n\");\n    }\n\n    #[test]\n    fn test_continue() {\n        let output = run_awk(\"BEGIN { for (i=1; i\u003c=3; i++) { if (i==2) continue; print i } }\", \"\");\n        assert_eq!(output, \"1\\n3\\n\");\n    }\n\n    #[test]\n    fn test_next() {\n        let output = run_awk(\"/skip/ { next } { print }\", \"one\\nskip\\ntwo\");\n        assert_eq!(output, \"one\\ntwo\\n\");\n    }\n\n    #[test]\n    fn test_exit() {\n        // exit is called before print on NR == 2\n        let output = run_awk(\"NR == 2 { exit } { print }\", \"one\\ntwo\\nthree\");\n        assert_eq!(output, \"one\\n\");\n    }\n\n    #[test]\n    fn test_exit_in_end() {\n        let output = run_awk(\"{ print } END { print \\\"done\\\" }\", \"one\\ntwo\");\n        assert!(output.contains(\"done\"));\n    }\n\n    #[test]\n    fn test_array_access() {\n        let output = run_awk(\"BEGIN { a[\\\"x\\\"] = 1; print a[\\\"x\\\"] }\", \"\");\n        assert_eq!(output, \"1\\n\");\n    }\n\n    #[test]\n    fn test_array_in() {\n        let output = run_awk(\"BEGIN { a[1]=1; print (1 in a), (2 in a) }\", \"\");\n        assert_eq!(output, \"1 0\\n\");\n    }\n\n    #[test]\n    fn test_delete() {\n        let output = run_awk(\"BEGIN { a[1]=1; a[2]=2; delete a[1]; for(k in a) print k }\", \"\");\n        assert_eq!(output, \"2\\n\");\n    }\n\n    #[test]\n    fn test_special_variables() {\n        let output = run_awk(\"{ print NR, NF, $0 }\", \"a b c\");\n        assert_eq!(output, \"1 3 a b c\\n\");\n    }\n\n    #[test]\n    fn test_fs_change() {\n        let output = run_awk(\"BEGIN { FS = \\\":\\\" } { print $1 }\", \"a:b:c\");\n        assert_eq!(output, \"a\\n\");\n    }\n\n    #[test]\n    fn test_ofs() {\n        let output = run_awk(\"BEGIN { OFS = \\\"-\\\" } { print $1, $2 }\", \"a b c\");\n        assert_eq!(output, \"a-b\\n\");\n    }\n\n    #[test]\n    fn test_nf_access() {\n        let output = run_awk(\"{ print $NF }\", \"a b c\");\n        assert_eq!(output, \"c\\n\");\n    }\n\n    #[test]\n    fn test_field_modify() {\n        let output = run_awk(\"{ $2 = \\\"X\\\"; print $0 }\", \"a b c\");\n        assert_eq!(output, \"a X c\\n\");\n    }\n\n    #[test]\n    fn test_user_function() {\n        let output = run_awk(\"function double(x) { return x*2 } BEGIN { print double(5) }\", \"\");\n        assert_eq!(output, \"10\\n\");\n    }\n\n    #[test]\n    fn test_recursion() {\n        let output = run_awk(\"function fact(n) { return n\u003c=1 ? 1 : n*fact(n-1) } BEGIN { print fact(5) }\", \"\");\n        assert_eq!(output, \"120\\n\");\n    }\n\n    #[test]\n    fn test_printf() {\n        let output = run_awk(\"BEGIN { printf \\\"%d %s\\\\n\\\", 42, \\\"hello\\\" }\", \"\");\n        assert_eq!(output, \"42 hello\\n\");\n    }\n\n    #[test]\n    fn test_range_pattern() {\n        let output = run_awk(\"/start/,/end/ { print }\", \"before\\nstart\\nmiddle\\nend\\nafter\");\n        assert_eq!(output, \"start\\nmiddle\\nend\\n\");\n    }\n\n    #[test]\n    fn test_compound_pattern_and() {\n        let output = run_awk(\"NR \u003e 1 \u0026\u0026 NR \u003c 4 { print }\", \"one\\ntwo\\nthree\\nfour\");\n        assert_eq!(output, \"two\\nthree\\n\");\n    }\n\n    #[test]\n    fn test_logical_or_in_expr() {\n        let output = run_awk(\"{ if (/a/ || /c/) print }\", \"a\\nb\\nc\");\n        assert_eq!(output, \"a\\nc\\n\");\n    }\n\n    #[test]\n    fn test_negated_pattern() {\n        let output = run_awk(\"!/skip/ { print }\", \"keep\\nskip\\nkeep\");\n        assert_eq!(output, \"keep\\nkeep\\n\");\n    }\n\n    #[test]\n    fn test_builtin_length() {\n        let output = run_awk(\"BEGIN { print length(\\\"hello\\\") }\", \"\");\n        assert_eq!(output, \"5\\n\");\n    }\n\n    #[test]\n    fn test_builtin_substr() {\n        let output = run_awk(\"BEGIN { print substr(\\\"hello\\\", 2, 3) }\", \"\");\n        assert_eq!(output, \"ell\\n\");\n    }\n\n    #[test]\n    fn test_builtin_index() {\n        let output = run_awk(\"BEGIN { print index(\\\"hello\\\", \\\"ll\\\") }\", \"\");\n        assert_eq!(output, \"3\\n\");\n    }\n\n    #[test]\n    fn test_builtin_split() {\n        let output = run_awk(\"BEGIN { n = split(\\\"a:b:c\\\", arr, \\\":\\\"); print n, arr[1], arr[2] }\", \"\");\n        assert_eq!(output, \"3 a b\\n\");\n    }\n\n    #[test]\n    fn test_builtin_sub() {\n        let output = run_awk(\"BEGIN { x = \\\"hello\\\"; sub(\\\"l\\\", \\\"L\\\", x); print x }\", \"\");\n        assert_eq!(output, \"heLlo\\n\");\n    }\n\n    #[test]\n    fn test_builtin_gsub() {\n        let output = run_awk(\"BEGIN { x = \\\"hello\\\"; gsub(\\\"l\\\", \\\"L\\\", x); print x }\", \"\");\n        assert_eq!(output, \"heLLo\\n\");\n    }\n\n    #[test]\n    fn test_builtin_match() {\n        let output = run_awk(\"BEGIN { print match(\\\"hello\\\", \\\"ll\\\") }\", \"\");\n        assert_eq!(output, \"3\\n\");\n    }\n\n    #[test]\n    fn test_builtin_sprintf() {\n        let output = run_awk(\"BEGIN { print sprintf(\\\"%05d\\\", 42) }\", \"\");\n        assert_eq!(output, \"00042\\n\");\n    }\n\n    #[test]\n    fn test_builtin_tolower() {\n        let output = run_awk(\"BEGIN { print tolower(\\\"HELLO\\\") }\", \"\");\n        assert_eq!(output, \"hello\\n\");\n    }\n\n    #[test]\n    fn test_builtin_toupper() {\n        let output = run_awk(\"BEGIN { print toupper(\\\"hello\\\") }\", \"\");\n        assert_eq!(output, \"HELLO\\n\");\n    }\n\n    #[test]\n    fn test_builtin_math() {\n        let output = run_awk(\"BEGIN { print int(3.7), sqrt(4), sin(0) }\", \"\");\n        assert_eq!(output, \"3 2 0\\n\");\n    }\n\n    #[test]\n    fn test_ternary() {\n        let output = run_awk(\"BEGIN { print 1 ? \\\"yes\\\" : \\\"no\\\" }\", \"\");\n        assert_eq!(output, \"yes\\n\");\n    }\n\n    #[test]\n    fn test_concatenation() {\n        let output = run_awk(\"BEGIN { print \\\"a\\\" \\\"b\\\" \\\"c\\\" }\", \"\");\n        assert_eq!(output, \"abc\\n\");\n    }\n\n    #[test]\n    fn test_unary_ops() {\n        let output = run_awk(\"BEGIN { x = 5; print -x, +x, !0 }\", \"\");\n        assert_eq!(output, \"-5 5 1\\n\");\n    }\n\n    #[test]\n    fn test_post_increment() {\n        let output = run_awk(\"BEGIN { x = 5; print x++ \\\" \\\" x }\", \"\");\n        assert_eq!(output, \"5 6\\n\");\n    }\n\n    #[test]\n    fn test_pre_increment() {\n        let output = run_awk(\"BEGIN { x = 5; print ++x }\", \"\");\n        assert_eq!(output, \"6\\n\");\n    }\n\n    #[test]\n    fn test_compound_assign() {\n        let output = run_awk(\"BEGIN { x = 10; x += 5; x -= 3; x *= 2; print x }\", \"\");\n        assert_eq!(output, \"24\\n\");\n    }\n\n    #[test]\n    fn test_getline_var() {\n        let output = run_awk(\"{ getline next_line; print $0, next_line }\", \"a\\nb\");\n        // When we read \"a\", getline reads \"b\" into next_line\n        assert!(output.contains(\"a\") \u0026\u0026 output.contains(\"b\"));\n    }\n\n    #[test]\n    fn test_fpat() {\n        let output = run_awk(\"BEGIN { FPAT = \\\"[^,]+\\\" } { print $1, $2 }\", \"a,b,c\");\n        assert_eq!(output, \"a b\\n\");\n    }\n\n    #[test]\n    fn test_fieldwidths() {\n        let output = run_awk(\"BEGIN { FIELDWIDTHS = \\\"2 3 2\\\" } { print $1, $2 }\", \"abcdefg\");\n        assert_eq!(output, \"ab cde\\n\");\n    }\n\n    #[test]\n    fn test_paragraph_mode() {\n        let output = run_awk(\"BEGIN { RS = \\\"\\\" } { print NR, NF }\", \"a b\\nc d\\n\\ne f\");\n        // First paragraph has 4 words across 2 lines, second has 2 words\n        assert!(output.contains(\"1\"));\n    }\n}\n","traces":[{"line":30,"address":[2734320],"length":1,"stats":{"Line":2}},{"line":31,"address":[3080802],"length":1,"stats":{"Line":2}},{"line":32,"address":[3401893],"length":1,"stats":{"Line":1}},{"line":33,"address":[3092091],"length":1,"stats":{"Line":1}},{"line":37,"address":[3091936],"length":1,"stats":{"Line":0}},{"line":38,"address":[3080685],"length":1,"stats":{"Line":0}},{"line":39,"address":[2734276],"length":1,"stats":{"Line":0}},{"line":40,"address":[2734251],"length":1,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":139,"address":[3350654],"length":1,"stats":{"Line":6}},{"line":140,"address":[3029749,3029673],"length":1,"stats":{"Line":14}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[2685000],"length":1,"stats":{"Line":8}},{"line":149,"address":[3030107,3030000,3029930],"length":1,"stats":{"Line":29}},{"line":150,"address":[2685135],"length":1,"stats":{"Line":10}},{"line":151,"address":[3030046],"length":1,"stats":{"Line":29}},{"line":156,"address":[3041379],"length":1,"stats":{"Line":10}},{"line":157,"address":[3041398],"length":1,"stats":{"Line":11}},{"line":159,"address":[],"length":0,"stats":{"Line":10}},{"line":160,"address":[2685415],"length":1,"stats":{"Line":11}},{"line":161,"address":[2685487],"length":1,"stats":{"Line":10}},{"line":162,"address":[3030463],"length":1,"stats":{"Line":11}},{"line":163,"address":[3030535],"length":1,"stats":{"Line":21}},{"line":164,"address":[3351631],"length":1,"stats":{"Line":11}},{"line":165,"address":[3351703],"length":1,"stats":{"Line":22}},{"line":166,"address":[2685855],"length":1,"stats":{"Line":11}},{"line":167,"address":[3030815],"length":1,"stats":{"Line":22}},{"line":170,"address":[2685967],"length":1,"stats":{"Line":11}},{"line":171,"address":[],"length":0,"stats":{"Line":22}},{"line":175,"address":[3352011],"length":1,"stats":{"Line":11}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[3031035],"length":1,"stats":{"Line":24}},{"line":183,"address":[2686195],"length":1,"stats":{"Line":11}},{"line":184,"address":[2686247],"length":1,"stats":{"Line":24}},{"line":185,"address":[3352239],"length":1,"stats":{"Line":11}},{"line":186,"address":[3042539],"length":1,"stats":{"Line":24}},{"line":190,"address":[],"length":0,"stats":{"Line":11}},{"line":192,"address":[],"length":0,"stats":{"Line":24}},{"line":197,"address":[3033090,3033116,3032832],"length":1,"stats":{"Line":0}},{"line":198,"address":[2687975,2687902],"length":1,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[3032656,3032738],"length":1,"stats":{"Line":1}},{"line":204,"address":[3353736,3353792,3353703],"length":1,"stats":{"Line":2}},{"line":206,"address":[3044058],"length":1,"stats":{"Line":1}},{"line":207,"address":[3032810],"length":1,"stats":{"Line":1}},{"line":211,"address":[2671568],"length":1,"stats":{"Line":0}},{"line":212,"address":[3337110],"length":1,"stats":{"Line":0}},{"line":213,"address":[3027361,3027378],"length":1,"stats":{"Line":0}},{"line":214,"address":[3337131],"length":1,"stats":{"Line":0}},{"line":219,"address":[3350560],"length":1,"stats":{"Line":0}},{"line":220,"address":[3350582],"length":1,"stats":{"Line":0}},{"line":221,"address":[3040850,3040833],"length":1,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[3024328,3024048,3024299],"length":1,"stats":{"Line":0}},{"line":228,"address":[3024312,3024105,3024179],"length":1,"stats":{"Line":0}},{"line":232,"address":[2668176,2668275],"length":1,"stats":{"Line":0}},{"line":233,"address":[3023935,3024001,3023895],"length":1,"stats":{"Line":0}},{"line":237,"address":[2751378,2748000,2750917],"length":1,"stats":{"Line":10}},{"line":239,"address":[],"length":0,"stats":{"Line":35}},{"line":240,"address":[2244135,2247595,2244912,2241472],"length":1,"stats":{"Line":33}},{"line":241,"address":[2211910],"length":1,"stats":{"Line":18}},{"line":242,"address":[],"length":0,"stats":{"Line":14}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[2751339],"length":1,"stats":{"Line":1}},{"line":251,"address":[2210833,2209388,2209207],"length":1,"stats":{"Line":18}},{"line":252,"address":[],"length":0,"stats":{"Line":7}},{"line":255,"address":[2210228,2209510],"length":1,"stats":{"Line":14}},{"line":256,"address":[2750435,2749449],"length":1,"stats":{"Line":13}},{"line":257,"address":[2211403],"length":1,"stats":{"Line":2}},{"line":258,"address":[2211472,2211505],"length":1,"stats":{"Line":4}},{"line":260,"address":[2247243,2243775],"length":1,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":5}},{"line":269,"address":[2246388,2242920],"length":1,"stats":{"Line":5}},{"line":270,"address":[],"length":0,"stats":{"Line":9}},{"line":271,"address":[2243250,2246718],"length":1,"stats":{"Line":1}},{"line":272,"address":[2467383,2467416],"length":1,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[2750404],"length":1,"stats":{"Line":0}},{"line":280,"address":[2246572,2243104],"length":1,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":6}},{"line":287,"address":[2209789,2209699],"length":1,"stats":{"Line":12}},{"line":288,"address":[2242161,2245613],"length":1,"stats":{"Line":3}},{"line":289,"address":[2749058],"length":1,"stats":{"Line":3}},{"line":294,"address":[2209752],"length":1,"stats":{"Line":6}},{"line":297,"address":[2232816,2235229,2235249,2234048,2234011,2233990],"length":1,"stats":{"Line":5}},{"line":299,"address":[2460507,2460589],"length":1,"stats":{"Line":12}},{"line":300,"address":[2233996,2234230,2235235,2232998],"length":1,"stats":{"Line":10}},{"line":303,"address":[],"length":0,"stats":{"Line":12}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[2234313,2233069],"length":1,"stats":{"Line":7}},{"line":307,"address":[2205263,2204425],"length":1,"stats":{"Line":5}},{"line":308,"address":[2743252],"length":1,"stats":{"Line":7}},{"line":313,"address":[2461016],"length":1,"stats":{"Line":5}},{"line":314,"address":[2234716,2233476],"length":1,"stats":{"Line":6}},{"line":315,"address":[2233491,2234731],"length":1,"stats":{"Line":4}},{"line":316,"address":[2743480],"length":1,"stats":{"Line":0}},{"line":320,"address":[2234678,2233578,2233611,2234818,2233438,2234851],"length":1,"stats":{"Line":10}},{"line":321,"address":[2461225,2461281,2461312],"length":1,"stats":{"Line":14}},{"line":322,"address":[2204944,2204992],"length":1,"stats":{"Line":17}},{"line":324,"address":[2743653,2743866],"length":1,"stats":{"Line":18}},{"line":326,"address":[2205167],"length":1,"stats":{"Line":3}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":5}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[2241157,2236464,2238795,2238816],"length":1,"stats":{"Line":5}},{"line":342,"address":[2745703],"length":1,"stats":{"Line":5}},{"line":343,"address":[2462990],"length":1,"stats":{"Line":5}},{"line":344,"address":[2745806],"length":1,"stats":{"Line":5}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[2463054],"length":1,"stats":{"Line":5}},{"line":348,"address":[2745886,2747896],"length":1,"stats":{"Line":5}},{"line":351,"address":[2463340],"length":1,"stats":{"Line":5}},{"line":353,"address":[2239417,2237057],"length":1,"stats":{"Line":5}},{"line":355,"address":[2463512,2463471],"length":1,"stats":{"Line":10}},{"line":357,"address":[],"length":0,"stats":{"Line":15}},{"line":358,"address":[2237266,2240098,2239626,2237738],"length":1,"stats":{"Line":0}},{"line":360,"address":[2463736,2463815],"length":1,"stats":{"Line":5}},{"line":361,"address":[2746615,2746550,2746653],"length":1,"stats":{"Line":10}},{"line":362,"address":[2746695,2746630],"length":1,"stats":{"Line":10}},{"line":363,"address":[],"length":0,"stats":{"Line":5}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[2747180,2746256],"length":1,"stats":{"Line":10}},{"line":370,"address":[2207803,2208089],"length":1,"stats":{"Line":7}},{"line":372,"address":[],"length":0,"stats":{"Line":10}},{"line":373,"address":[2241112,2238164,2238751,2240524],"length":1,"stats":{"Line":0}},{"line":375,"address":[2747444,2747374],"length":1,"stats":{"Line":5}},{"line":376,"address":[],"length":0,"stats":{"Line":10}},{"line":377,"address":[2238341,2238395,2240755,2240701],"length":1,"stats":{"Line":10}},{"line":378,"address":[2747886,2747578],"length":1,"stats":{"Line":5}},{"line":380,"address":[2464985],"length":1,"stats":{"Line":5}},{"line":381,"address":[2238600,2240960],"length":1,"stats":{"Line":5}},{"line":383,"address":[],"length":0,"stats":{"Line":5}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[2240103,2237743],"length":1,"stats":{"Line":5}},{"line":390,"address":[],"length":0,"stats":{"Line":4}},{"line":393,"address":[],"length":0,"stats":{"Line":10}},{"line":394,"address":[],"length":0,"stats":{"Line":5}},{"line":395,"address":[2207969],"length":1,"stats":{"Line":5}},{"line":396,"address":[2747138],"length":1,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":10}},{"line":400,"address":[2747172],"length":1,"stats":{"Line":5}},{"line":404,"address":[2746321,2747836],"length":1,"stats":{"Line":5}},{"line":405,"address":[2747829],"length":1,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":5}},{"line":412,"address":[2235280],"length":1,"stats":{"Line":17}},{"line":413,"address":[2461723,2461804],"length":1,"stats":{"Line":35}},{"line":415,"address":[2205551,2205610],"length":1,"stats":{"Line":28}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":10}},{"line":422,"address":[2462180],"length":1,"stats":{"Line":12}},{"line":423,"address":[2235812],"length":1,"stats":{"Line":12}},{"line":424,"address":[],"length":0,"stats":{"Line":12}},{"line":427,"address":[2745107,2745504],"length":1,"stats":{"Line":1}},{"line":431,"address":[2235789],"length":1,"stats":{"Line":3}},{"line":432,"address":[2236424],"length":1,"stats":{"Line":3}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[2236404,2236441],"length":1,"stats":{"Line":6}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[2744712],"length":1,"stats":{"Line":3}},{"line":443,"address":[3010880,3010979],"length":1,"stats":{"Line":7}},{"line":444,"address":[2666577,2666471,2666511],"length":1,"stats":{"Line":17}},{"line":445,"address":[3022309],"length":1,"stats":{"Line":12}},{"line":448,"address":[],"length":0,"stats":{"Line":7}},{"line":449,"address":[3334119],"length":1,"stats":{"Line":12}},{"line":451,"address":[2668699],"length":1,"stats":{"Line":7}},{"line":452,"address":[3013205],"length":1,"stats":{"Line":1}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":19}},{"line":458,"address":[3013245],"length":1,"stats":{"Line":12}},{"line":461,"address":[3334319,3334358,3334401],"length":1,"stats":{"Line":20}},{"line":462,"address":[2668961],"length":1,"stats":{"Line":3}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":23}},{"line":468,"address":[2669042],"length":1,"stats":{"Line":4}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":15}},{"line":476,"address":[3334538],"length":1,"stats":{"Line":16}},{"line":477,"address":[3334514,3336486],"length":1,"stats":{"Line":5}},{"line":479,"address":[],"length":0,"stats":{"Line":8}},{"line":480,"address":[3013760],"length":1,"stats":{"Line":4}},{"line":481,"address":[3334818],"length":1,"stats":{"Line":4}},{"line":483,"address":[3013806,3013926],"length":1,"stats":{"Line":6}},{"line":484,"address":[2669600,2669870],"length":1,"stats":{"Line":7}},{"line":485,"address":[3025455],"length":1,"stats":{"Line":4}},{"line":486,"address":[2669875,2669840],"length":1,"stats":{"Line":4}},{"line":490,"address":[2669618],"length":1,"stats":{"Line":3}},{"line":493,"address":[2669222],"length":1,"stats":{"Line":1}},{"line":494,"address":[3024970],"length":1,"stats":{"Line":1}},{"line":495,"address":[3025638,3025715],"length":1,"stats":{"Line":2}},{"line":496,"address":[2670162,2670078],"length":1,"stats":{"Line":0}},{"line":497,"address":[3014563,3014793,3014695],"length":1,"stats":{"Line":3}},{"line":498,"address":[3014936,3014833],"length":1,"stats":{"Line":2}},{"line":499,"address":[3026266],"length":1,"stats":{"Line":1}},{"line":502,"address":[3336341],"length":1,"stats":{"Line":0}},{"line":506,"address":[3025403],"length":1,"stats":{"Line":17}},{"line":510,"address":[3024164,3025109,3023440],"length":1,"stats":{"Line":3}},{"line":511,"address":[3034730],"length":1,"stats":{"Line":3}},{"line":512,"address":[3034802],"length":1,"stats":{"Line":3}},{"line":514,"address":[3034947,3034870],"length":1,"stats":{"Line":6}},{"line":515,"address":[2679063,2678995,2679186],"length":1,"stats":{"Line":0}},{"line":516,"address":[3024017,3024116],"length":1,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":9}},{"line":519,"address":[],"length":0,"stats":{"Line":9}},{"line":520,"address":[3345624,3345906],"length":1,"stats":{"Line":6}},{"line":522,"address":[3345690],"length":1,"stats":{"Line":3}},{"line":525,"address":[3024080,3025041],"length":1,"stats":{"Line":6}},{"line":529,"address":[3028176,3029199,3029205],"length":1,"stats":{"Line":4}},{"line":530,"address":[3028284,3028199],"length":1,"stats":{"Line":8}},{"line":532,"address":[2914144,2914163],"length":1,"stats":{"Line":12}},{"line":535,"address":[3028317],"length":1,"stats":{"Line":4}},{"line":536,"address":[3349353,3349440],"length":1,"stats":{"Line":8}},{"line":538,"address":[3028720,3028462,3029108,3028573],"length":1,"stats":{"Line":16}},{"line":539,"address":[3040104,3040035],"length":1,"stats":{"Line":8}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[3028850],"length":1,"stats":{"Line":4}},{"line":543,"address":[3028957],"length":1,"stats":{"Line":4}},{"line":544,"address":[3040333],"length":1,"stats":{"Line":4}},{"line":545,"address":[3040364],"length":1,"stats":{"Line":4}},{"line":548,"address":[3040385],"length":1,"stats":{"Line":4}},{"line":552,"address":[],"length":0,"stats":{"Line":6}},{"line":553,"address":[2181010],"length":1,"stats":{"Line":6}},{"line":554,"address":[3033186],"length":1,"stats":{"Line":4}},{"line":555,"address":[2459030],"length":1,"stats":{"Line":5}},{"line":556,"address":[2176066],"length":1,"stats":{"Line":5}},{"line":558,"address":[3033249],"length":1,"stats":{"Line":2}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[3336568,3336601],"length":1,"stats":{"Line":0}},{"line":567,"address":[3336579],"length":1,"stats":{"Line":0}},{"line":568,"address":[3015584,3015646,3015729],"length":1,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[3026891],"length":1,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":3}},{"line":576,"address":[3035006,3034038],"length":1,"stats":{"Line":6}},{"line":577,"address":[3045427,3045342],"length":1,"stats":{"Line":1}},{"line":578,"address":[3355291,3355339],"length":1,"stats":{"Line":2}},{"line":581,"address":[3355359,3355156],"length":1,"stats":{"Line":6}},{"line":582,"address":[2690048,2689451],"length":1,"stats":{"Line":2}},{"line":584,"address":[3045619,3045746,3046275],"length":1,"stats":{"Line":6}},{"line":585,"address":[3034703],"length":1,"stats":{"Line":3}},{"line":587,"address":[3034743],"length":1,"stats":{"Line":3}},{"line":591,"address":[3028609,3027392,3028615],"length":1,"stats":{"Line":16}},{"line":592,"address":[3027446],"length":1,"stats":{"Line":17}},{"line":593,"address":[3016261],"length":1,"stats":{"Line":12}},{"line":594,"address":[3027559],"length":1,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[3016318],"length":1,"stats":{"Line":4}},{"line":597,"address":[3017123,3016326],"length":1,"stats":{"Line":4}},{"line":598,"address":[2672727,2672784],"length":1,"stats":{"Line":6}},{"line":600,"address":[3027673],"length":1,"stats":{"Line":5}},{"line":601,"address":[3027690],"length":1,"stats":{"Line":6}},{"line":602,"address":[3337479,3338444],"length":1,"stats":{"Line":12}},{"line":603,"address":[3338626],"length":1,"stats":{"Line":6}},{"line":605,"address":[2671987],"length":1,"stats":{"Line":3}},{"line":606,"address":[],"length":0,"stats":{"Line":3}},{"line":607,"address":[3337599,3339266,3339631],"length":1,"stats":{"Line":9}},{"line":609,"address":[3338734,3339337,3339271,3339035],"length":1,"stats":{"Line":6}},{"line":610,"address":[2673694],"length":1,"stats":{"Line":3}},{"line":611,"address":[3029561],"length":1,"stats":{"Line":3}},{"line":613,"address":[2673660],"length":1,"stats":{"Line":3}},{"line":616,"address":[3029127,3029596,3029876],"length":1,"stats":{"Line":3}},{"line":617,"address":[],"length":0,"stats":{"Line":3}},{"line":619,"address":[3018596],"length":1,"stats":{"Line":3}},{"line":622,"address":[2672093],"length":1,"stats":{"Line":0}},{"line":623,"address":[3337649,3339655,3340327,3340058],"length":1,"stats":{"Line":0}},{"line":624,"address":[2674452,2674277],"length":1,"stats":{"Line":0}},{"line":626,"address":[3016778],"length":1,"stats":{"Line":0}},{"line":627,"address":[3028074,3030586,3031257,3031213,3030961],"length":1,"stats":{"Line":0}},{"line":628,"address":[2675306,2675077,2674906],"length":1,"stats":{"Line":0}},{"line":630,"address":[3028227],"length":1,"stats":{"Line":0}},{"line":631,"address":[3016975,3020012],"length":1,"stats":{"Line":0}},{"line":636,"address":[3033360,3033937,3033966],"length":1,"stats":{"Line":7}},{"line":637,"address":[3033440,3033932],"length":1,"stats":{"Line":13}},{"line":638,"address":[2688660,2688736,2688514],"length":1,"stats":{"Line":14}},{"line":639,"address":[3354789,3354860],"length":1,"stats":{"Line":14}},{"line":641,"address":[3044839],"length":1,"stats":{"Line":7}},{"line":644,"address":[3022320],"length":1,"stats":{"Line":5}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":8}},{"line":648,"address":[3011159,3011300],"length":1,"stats":{"Line":9}},{"line":649,"address":[2666976,2666835],"length":1,"stats":{"Line":4}},{"line":650,"address":[3011375,3011511],"length":1,"stats":{"Line":5}},{"line":651,"address":[3011580,3011483],"length":1,"stats":{"Line":4}},{"line":652,"address":[],"length":0,"stats":{"Line":4}},{"line":653,"address":[2667193,2667294],"length":1,"stats":{"Line":6}},{"line":654,"address":[3022962,3023063],"length":1,"stats":{"Line":4}},{"line":655,"address":[2667446,2667339],"length":1,"stats":{"Line":11}},{"line":656,"address":[3023114,3023221],"length":1,"stats":{"Line":6}},{"line":657,"address":[3011929,3012039],"length":1,"stats":{"Line":11}},{"line":658,"address":[3333035,3333150],"length":1,"stats":{"Line":6}},{"line":659,"address":[2667661,2667802],"length":1,"stats":{"Line":11}},{"line":660,"address":[2667876,2667769],"length":1,"stats":{"Line":4}},{"line":662,"address":[3012275,3012415],"length":1,"stats":{"Line":12}},{"line":663,"address":[3012383,3012556],"length":1,"stats":{"Line":5}},{"line":664,"address":[3012474],"length":1,"stats":{"Line":12}},{"line":669,"address":[2676304],"length":1,"stats":{"Line":4}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[3342145],"length":1,"stats":{"Line":4}},{"line":672,"address":[3032448],"length":1,"stats":{"Line":1}},{"line":673,"address":[2913984,2914002],"length":1,"stats":{"Line":3}},{"line":674,"address":[2676509],"length":1,"stats":{"Line":1}},{"line":676,"address":[2676432],"length":1,"stats":{"Line":5}},{"line":677,"address":[2744224,2744242],"length":1,"stats":{"Line":3}},{"line":679,"address":[],"length":0,"stats":{"Line":4}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[3032611,3032679],"length":1,"stats":{"Line":4}},{"line":683,"address":[3032656,3032795],"length":1,"stats":{"Line":2}},{"line":684,"address":[3342528],"length":1,"stats":{"Line":2}},{"line":685,"address":[3343838,3342696],"length":1,"stats":{"Line":1}},{"line":686,"address":[3033979],"length":1,"stats":{"Line":0}},{"line":687,"address":[3034203,3034307,3034088],"length":1,"stats":{"Line":2}},{"line":688,"address":[3022840],"length":1,"stats":{"Line":0}},{"line":690,"address":[2678216],"length":1,"stats":{"Line":1}},{"line":693,"address":[3032908,3032998],"length":1,"stats":{"Line":1}},{"line":694,"address":[3342876,3342730],"length":1,"stats":{"Line":2}},{"line":695,"address":[3021825,3021991],"length":1,"stats":{"Line":0}},{"line":696,"address":[3022110,3021963],"length":1,"stats":{"Line":0}},{"line":697,"address":[3022082,3022229],"length":1,"stats":{"Line":0}},{"line":698,"address":[3033465,3033612],"length":1,"stats":{"Line":0}},{"line":699,"address":[2677592,2677743],"length":1,"stats":{"Line":0}},{"line":700,"address":[3033703,3033897],"length":1,"stats":{"Line":0}},{"line":701,"address":[3343582],"length":1,"stats":{"Line":0}},{"line":704,"address":[3021323],"length":1,"stats":{"Line":6}},{"line":708,"address":[3028138,3028170,3025248],"length":1,"stats":{"Line":9}},{"line":710,"address":[],"length":0,"stats":{"Line":15}},{"line":711,"address":[3025350,3025424],"length":1,"stats":{"Line":25}},{"line":712,"address":[],"length":0,"stats":{"Line":2}},{"line":713,"address":[3038953],"length":1,"stats":{"Line":1}},{"line":714,"address":[2682928,2683062],"length":1,"stats":{"Line":2}},{"line":716,"address":[2682895,2682952],"length":1,"stats":{"Line":2}},{"line":717,"address":[3027819],"length":1,"stats":{"Line":1}},{"line":720,"address":[3348803],"length":1,"stats":{"Line":1}},{"line":721,"address":[3039164,3039050],"length":1,"stats":{"Line":2}},{"line":723,"address":[3036710,3036761],"length":1,"stats":{"Line":38}},{"line":724,"address":[3038708,3036822],"length":1,"stats":{"Line":10}},{"line":726,"address":[3027550],"length":1,"stats":{"Line":5}},{"line":727,"address":[],"length":0,"stats":{"Line":5}},{"line":729,"address":[],"length":0,"stats":{"Line":43}},{"line":730,"address":[],"length":0,"stats":{"Line":43}},{"line":731,"address":[3346693,3348066,3346807,3346746],"length":1,"stats":{"Line":33}},{"line":732,"address":[3025858,3025797,3025744,3026908],"length":1,"stats":{"Line":35}},{"line":733,"address":[],"length":0,"stats":{"Line":35}},{"line":734,"address":[3346918,3347032,3346971,3347631],"length":1,"stats":{"Line":35}},{"line":736,"address":[2681169,2681222],"length":1,"stats":{"Line":31}},{"line":737,"address":[],"length":0,"stats":{"Line":6}},{"line":739,"address":[],"length":0,"stats":{"Line":3}},{"line":741,"address":[],"length":0,"stats":{"Line":29}},{"line":742,"address":[3347323,3347194],"length":1,"stats":{"Line":8}},{"line":744,"address":[3347453],"length":1,"stats":{"Line":4}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[3037388,3037454],"length":1,"stats":{"Line":29}},{"line":753,"address":[3025152],"length":1,"stats":{"Line":12}},{"line":754,"address":[2680396],"length":1,"stats":{"Line":14}},{"line":757,"address":[3020592],"length":1,"stats":{"Line":3}},{"line":758,"address":[3020698],"length":1,"stats":{"Line":3}},{"line":761,"address":[2676048],"length":1,"stats":{"Line":3}},{"line":762,"address":[3032111],"length":1,"stats":{"Line":1}},{"line":765,"address":[3020905],"length":1,"stats":{"Line":4}},{"line":766,"address":[3020912],"length":1,"stats":{"Line":4}},{"line":767,"address":[2744147,2744112],"length":1,"stats":{"Line":18}},{"line":769,"address":[2676252],"length":1,"stats":{"Line":4}},{"line":772,"address":[2678649,2678320,2678674],"length":1,"stats":{"Line":10}},{"line":773,"address":[3034387,3034471],"length":1,"stats":{"Line":22}},{"line":774,"address":[3344252],"length":1,"stats":{"Line":11}},{"line":775,"address":[3344259],"length":1,"stats":{"Line":11}},{"line":777,"address":[2678542],"length":1,"stats":{"Line":11}},{"line":780,"address":[],"length":0,"stats":{"Line":2}},{"line":781,"address":[3020315],"length":1,"stats":{"Line":2}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[3341370],"length":1,"stats":{"Line":2}},{"line":786,"address":[3031678],"length":1,"stats":{"Line":0}},{"line":787,"address":[2604016,2604034],"length":1,"stats":{"Line":0}},{"line":790,"address":[3020550,3020377],"length":1,"stats":{"Line":2}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[3020485],"length":1,"stats":{"Line":2}},{"line":793,"address":[3020492],"length":1,"stats":{"Line":2}},{"line":794,"address":[2592800,2592835],"length":1,"stats":{"Line":6}},{"line":800,"address":[3040776,3040782,3040512],"length":1,"stats":{"Line":2}},{"line":801,"address":[],"length":0,"stats":{"Line":2}},{"line":802,"address":[3029406,3029337],"length":1,"stats":{"Line":4}},{"line":803,"address":[],"length":0,"stats":{"Line":4}},{"line":807,"address":[3336768,3337062,3337068],"length":1,"stats":{"Line":5}},{"line":808,"address":[2671375],"length":1,"stats":{"Line":10}},{"line":810,"address":[3015831],"length":1,"stats":{"Line":11}},{"line":812,"address":[],"length":0,"stats":{"Line":11}}],"covered":311,"coverable":390},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","interpreter","stmt.rs"],"content":"use std::io::Write;\nuse std::fs::{File, OpenOptions};\nuse std::process::{Command, Stdio};\n\nuse crate::ast::*;\nuse crate::error::{Error, Result};\nuse crate::value::Value;\n\nuse super::{Interpreter, OutputFile};\n\n/// Result of executing a statement\npub enum StmtResult {\n    Normal,\n    Break,\n    Continue,\n    Return(Value),\n}\n\nimpl\u003c'a\u003e Interpreter\u003c'a\u003e {\n    pub fn execute_block\u003cW: Write\u003e(\u0026mut self, block: \u0026Block, output: \u0026mut W) -\u003e Result\u003cStmtResult\u003e {\n        for stmt in \u0026block.statements {\n            let result = self.execute_stmt(stmt, output)?;\n            match result {\n                StmtResult::Normal =\u003e continue,\n                other =\u003e return Ok(other),\n            }\n        }\n        Ok(StmtResult::Normal)\n    }\n\n    pub fn execute_stmt\u003cW: Write\u003e(\u0026mut self, stmt: \u0026Stmt, output: \u0026mut W) -\u003e Result\u003cStmtResult\u003e {\n        match stmt {\n            Stmt::Empty =\u003e Ok(StmtResult::Normal),\n\n            Stmt::Expr(expr) =\u003e {\n                self.eval_expr_with_output(expr, output)?;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Print { args, output: redirect, .. } =\u003e {\n                self.execute_print(args, redirect, output)?;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Printf { format, args, output: redirect, .. } =\u003e {\n                self.execute_printf(format, args, redirect, output)?;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::If { condition, then_branch, else_branch, .. } =\u003e {\n                let cond = self.eval_expr_with_output(condition, output)?;\n                if cond.is_truthy() {\n                    self.execute_stmt(then_branch, output)\n                } else if let Some(else_stmt) = else_branch {\n                    self.execute_stmt(else_stmt, output)\n                } else {\n                    Ok(StmtResult::Normal)\n                }\n            }\n\n            Stmt::While { condition, body, .. } =\u003e {\n                loop {\n                    let cond = self.eval_expr_with_output(condition, output)?;\n                    if !cond.is_truthy() {\n                        break;\n                    }\n                    match self.execute_stmt(body, output)? {\n                        StmtResult::Normal | StmtResult::Continue =\u003e continue,\n                        StmtResult::Break =\u003e break,\n                        StmtResult::Return(v) =\u003e return Ok(StmtResult::Return(v)),\n                    }\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::DoWhile { body, condition, .. } =\u003e {\n                loop {\n                    match self.execute_stmt(body, output)? {\n                        StmtResult::Normal | StmtResult::Continue =\u003e {}\n                        StmtResult::Break =\u003e break,\n                        StmtResult::Return(v) =\u003e return Ok(StmtResult::Return(v)),\n                    }\n                    let cond = self.eval_expr_with_output(condition, output)?;\n                    if !cond.is_truthy() {\n                        break;\n                    }\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::For { init, condition, update, body, .. } =\u003e {\n                // Execute init\n                if let Some(init_stmt) = init {\n                    self.execute_stmt(init_stmt, output)?;\n                }\n\n                loop {\n                    // Check condition\n                    if let Some(cond_expr) = condition {\n                        let cond = self.eval_expr_with_output(cond_expr, output)?;\n                        if !cond.is_truthy() {\n                            break;\n                        }\n                    }\n\n                    // Execute body\n                    match self.execute_stmt(body, output)? {\n                        StmtResult::Normal | StmtResult::Continue =\u003e {}\n                        StmtResult::Break =\u003e break,\n                        StmtResult::Return(v) =\u003e return Ok(StmtResult::Return(v)),\n                    }\n\n                    // Execute update\n                    if let Some(update_expr) = update {\n                        self.eval_expr_with_output(update_expr, output)?;\n                    }\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::ForIn { var, array, body, .. } =\u003e {\n                // Get keys from array (resolve aliases for pass-by-reference)\n                let resolved_array = self.array_aliases.get(array).map(|s| s.as_str()).unwrap_or(array);\n                let keys: Vec\u003cString\u003e = self.arrays\n                    .get(resolved_array)\n                    .map(|arr| arr.keys().cloned().collect())\n                    .unwrap_or_default();\n\n                for key in keys {\n                    self.set_variable_value(var, Value::from_string(key));\n                    match self.execute_stmt(body, output)? {\n                        StmtResult::Normal | StmtResult::Continue =\u003e continue,\n                        StmtResult::Break =\u003e break,\n                        StmtResult::Return(v) =\u003e return Ok(StmtResult::Return(v)),\n                    }\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Block(block) =\u003e self.execute_block(block, output),\n\n            Stmt::Break { .. } =\u003e Ok(StmtResult::Break),\n\n            Stmt::Continue { .. } =\u003e Ok(StmtResult::Continue),\n\n            Stmt::Next { .. } =\u003e {\n                self.should_next = true;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Nextfile { .. } =\u003e {\n                self.should_nextfile = true;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Exit { code, .. } =\u003e {\n                self.exit_code = code.as_ref()\n                    .map(|e| self.eval_expr_with_output(e, output).map(|v| v.to_number() as i32))\n                    .transpose()?\n                    .unwrap_or(0);\n                self.should_exit = true;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Return { value, .. } =\u003e {\n                let val = value.as_ref()\n                    .map(|e| self.eval_expr_with_output(e, output))\n                    .transpose()?\n                    .unwrap_or(Value::Uninitialized);\n                Ok(StmtResult::Return(val))\n            }\n\n            Stmt::Delete { array, index, .. } =\u003e {\n                if index.is_empty() {\n                    // delete array (entire array)\n                    self.arrays.remove(array);\n                } else {\n                    let key_parts: Result\u003cVec\u003cValue\u003e\u003e = index.iter()\n                        .map(|e| self.eval_expr_with_output(e, output))\n                        .collect();\n                    let key = self.make_array_key(\u0026key_parts?);\n                    self.delete_array_element(array, \u0026key);\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Getline { var, input, location } =\u003e {\n                // Getline as a statement\n                let _result = self.eval_getline(var.as_ref(), input.as_ref(), *location)?;\n                Ok(StmtResult::Normal)\n            }\n        }\n    }\n\n    fn execute_print\u003cW: Write\u003e(\n        \u0026mut self,\n        args: \u0026[Expr],\n        redirect: \u0026Option\u003cOutputRedirect\u003e,\n        default_output: \u0026mut W,\n    ) -\u003e Result\u003c()\u003e {\n        let values: Result\u003cVec\u003cString\u003e\u003e = args.iter()\n            .map(|e| self.eval_expr_with_output(e, default_output).map(|v| v.to_string_val()))\n            .collect();\n        let values = values?;\n\n        let line = if values.is_empty() {\n            // print without args prints $0\n            self.record.clone()\n        } else {\n            values.join(\u0026self.ofs)\n        };\n\n        // Handle output redirection\n        match redirect {\n            None =\u003e {\n                writeln!(default_output, \"{}\", line).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Truncate(target_expr)) =\u003e {\n                let filename = self.eval_expr_with_output(target_expr, default_output)?.to_string_val();\n                let file = self.get_or_open_file(\u0026filename, false)?;\n                writeln!(file, \"{}\", line).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Append(target_expr)) =\u003e {\n                let filename = self.eval_expr_with_output(target_expr, default_output)?.to_string_val();\n                let file = self.get_or_open_file(\u0026filename, true)?;\n                writeln!(file, \"{}\", line).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Pipe(cmd_expr)) =\u003e {\n                let cmd = self.eval_expr_with_output(cmd_expr, default_output)?.to_string_val();\n                let pipe = self.get_or_open_pipe(\u0026cmd)?;\n                writeln!(pipe, \"{}\", line).map_err(Error::Io)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute_printf\u003cW: Write\u003e(\n        \u0026mut self,\n        format_expr: \u0026Expr,\n        args: \u0026[Expr],\n        redirect: \u0026Option\u003cOutputRedirect\u003e,\n        default_output: \u0026mut W,\n    ) -\u003e Result\u003c()\u003e {\n        let format = self.eval_expr_with_output(format_expr, default_output)?.to_string_val();\n        let values: Result\u003cVec\u003cValue\u003e\u003e = args.iter()\n            .map(|e| self.eval_expr_with_output(e, default_output))\n            .collect();\n        let values = values?;\n\n        let formatted = self.format_printf(\u0026format, \u0026values);\n\n        // Handle output redirection\n        match redirect {\n            None =\u003e {\n                write!(default_output, \"{}\", formatted).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Truncate(target_expr)) =\u003e {\n                let filename = self.eval_expr_with_output(target_expr, default_output)?.to_string_val();\n                let file = self.get_or_open_file(\u0026filename, false)?;\n                write!(file, \"{}\", formatted).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Append(target_expr)) =\u003e {\n                let filename = self.eval_expr_with_output(target_expr, default_output)?.to_string_val();\n                let file = self.get_or_open_file(\u0026filename, true)?;\n                write!(file, \"{}\", formatted).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Pipe(cmd_expr)) =\u003e {\n                let cmd = self.eval_expr_with_output(cmd_expr, default_output)?.to_string_val();\n                let pipe = self.get_or_open_pipe(\u0026cmd)?;\n                write!(pipe, \"{}\", formatted).map_err(Error::Io)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get or open a file for output redirection\n    fn get_or_open_file(\u0026mut self, filename: \u0026str, append: bool) -\u003e Result\u003c\u0026mut OutputFile\u003e {\n        if !self.output_files.contains_key(filename) {\n            let file = if append {\n                OpenOptions::new()\n                    .create(true)\n                    .append(true)\n                    .open(filename)\n                    .map_err(Error::Io)?\n            } else {\n                File::create(filename).map_err(Error::Io)?\n            };\n            self.output_files.insert(filename.to_string(), OutputFile::File(file));\n        }\n        Ok(self.output_files.get_mut(filename).unwrap())\n    }\n\n    /// Get or open a pipe for output redirection\n    fn get_or_open_pipe(\u0026mut self, cmd: \u0026str) -\u003e Result\u003c\u0026mut OutputFile\u003e {\n        if !self.output_files.contains_key(cmd) {\n            let child = Command::new(\"sh\")\n                .arg(\"-c\")\n                .arg(cmd)\n                .stdin(Stdio::piped())\n                .spawn()\n                .map_err(Error::Io)?;\n\n            let stdin = child.stdin.unwrap();\n            self.output_files.insert(cmd.to_string(), OutputFile::Pipe(stdin));\n        }\n        Ok(self.output_files.get_mut(cmd).unwrap())\n    }\n\n    pub(crate) fn format_printf(\u0026self, format: \u0026str, args: \u0026[Value]) -\u003e String {\n        let mut result = String::new();\n        let mut chars = format.chars().peekable();\n        let mut arg_idx = 0;\n\n        while let Some(ch) = chars.next() {\n            if ch != '%' {\n                result.push(ch);\n                continue;\n            }\n\n            // Check for %%\n            if chars.peek() == Some(\u0026'%') {\n                chars.next();\n                result.push('%');\n                continue;\n            }\n\n            // Parse format specifier\n            let mut width = String::new();\n            let mut precision = String::new();\n            let mut flags = String::new();\n\n            // Flags\n            while let Some(\u0026c) = chars.peek() {\n                if c == '-' || c == '+' || c == ' ' || c == '#' || c == '0' {\n                    flags.push(c);\n                    chars.next();\n                } else {\n                    break;\n                }\n            }\n\n            // Width\n            while let Some(\u0026c) = chars.peek() {\n                if c.is_ascii_digit() {\n                    width.push(c);\n                    chars.next();\n                } else {\n                    break;\n                }\n            }\n\n            // Precision\n            if chars.peek() == Some(\u0026'.') {\n                chars.next();\n                while let Some(\u0026c) = chars.peek() {\n                    if c.is_ascii_digit() {\n                        precision.push(c);\n                        chars.next();\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            // Conversion specifier\n            let spec = chars.next().unwrap_or('s');\n            let arg = args.get(arg_idx).cloned().unwrap_or(Value::Uninitialized);\n            arg_idx += 1;\n\n            let width_num: Option\u003cusize\u003e = width.parse().ok();\n            let precision_num: Option\u003cusize\u003e = precision.parse().ok();\n            let left_align = flags.contains('-');\n\n            let formatted = match spec {\n                's' =\u003e {\n                    let s = arg.to_string_val();\n                    let s = if let Some(p) = precision_num {\n                        s.chars().take(p).collect()\n                    } else {\n                        s\n                    };\n                    if let Some(w) = width_num {\n                        if left_align {\n                            format!(\"{:\u003cwidth$}\", s, width = w)\n                        } else {\n                            format!(\"{:\u003ewidth$}\", s, width = w)\n                        }\n                    } else {\n                        s\n                    }\n                }\n                'd' | 'i' =\u003e {\n                    let n = arg.to_number() as i64;\n                    if let Some(w) = width_num {\n                        if flags.contains('0') \u0026\u0026 !left_align {\n                            format!(\"{:0\u003ewidth$}\", n, width = w)\n                        } else if left_align {\n                            format!(\"{:\u003cwidth$}\", n, width = w)\n                        } else {\n                            format!(\"{:\u003ewidth$}\", n, width = w)\n                        }\n                    } else {\n                        format!(\"{}\", n)\n                    }\n                }\n                'f' | 'F' =\u003e {\n                    let n = arg.to_number();\n                    let p = precision_num.unwrap_or(6);\n                    if let Some(w) = width_num {\n                        if left_align {\n                            format!(\"{:\u003cwidth$.prec$}\", n, width = w, prec = p)\n                        } else {\n                            format!(\"{:\u003ewidth$.prec$}\", n, width = w, prec = p)\n                        }\n                    } else {\n                        format!(\"{:.prec$}\", n, prec = p)\n                    }\n                }\n                'e' | 'E' =\u003e {\n                    let n = arg.to_number();\n                    let p = precision_num.unwrap_or(6);\n                    format!(\"{:.prec$e}\", n, prec = p)\n                }\n                'g' | 'G' =\u003e {\n                    let n = arg.to_number();\n                    let p = precision_num.unwrap_or(6);\n                    // Simplified %g implementation\n                    if n.abs() \u003e= 1e-4 \u0026\u0026 n.abs() \u003c 10f64.powi(p as i32) {\n                        format!(\"{:.prec$}\", n, prec = p)\n                    } else {\n                        format!(\"{:.prec$e}\", n, prec = p)\n                    }\n                }\n                'o' =\u003e format!(\"{:o}\", arg.to_number() as u64),\n                'x' =\u003e format!(\"{:x}\", arg.to_number() as u64),\n                'X' =\u003e format!(\"{:X}\", arg.to_number() as u64),\n                'c' =\u003e {\n                    let n = arg.to_number() as u32;\n                    char::from_u32(n).map(|c| c.to_string()).unwrap_or_default()\n                }\n                _ =\u003e format!(\"%{}\", spec),\n            };\n\n            result.push_str(\u0026formatted);\n        }\n\n        result\n    }\n}\n","traces":[{"line":20,"address":[2622832],"length":1,"stats":{"Line":19}},{"line":21,"address":[2241952,2241936],"length":1,"stats":{"Line":28}},{"line":22,"address":[2242172,2242019],"length":1,"stats":{"Line":9}},{"line":23,"address":[2623294],"length":1,"stats":{"Line":7}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[2278147],"length":1,"stats":{"Line":4}},{"line":28,"address":[2498438],"length":1,"stats":{"Line":7}},{"line":31,"address":[2488288,2491910,2491916],"length":1,"stats":{"Line":20}},{"line":32,"address":[2612950],"length":1,"stats":{"Line":8}},{"line":33,"address":[2615201],"length":1,"stats":{"Line":1}},{"line":35,"address":[2613039],"length":1,"stats":{"Line":16}},{"line":36,"address":[2792320,2802128,2790123,2799931],"length":1,"stats":{"Line":18}},{"line":37,"address":[2802336,2792528],"length":1,"stats":{"Line":14}},{"line":40,"address":[2232203],"length":1,"stats":{"Line":10}},{"line":41,"address":[2234641,2232238],"length":1,"stats":{"Line":7}},{"line":42,"address":[2234706],"length":1,"stats":{"Line":9}},{"line":45,"address":[2488719],"length":1,"stats":{"Line":3}},{"line":46,"address":[2934367,2936745],"length":1,"stats":{"Line":3}},{"line":47,"address":[2792826,2802634],"length":1,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":53,"address":[2627378,2627666],"length":1,"stats":{"Line":7}},{"line":54,"address":[2616078,2616152,2616264],"length":1,"stats":{"Line":12}},{"line":55,"address":[2627424,2627538],"length":1,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[2232695],"length":1,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[2793569,2803377],"length":1,"stats":{"Line":3}},{"line":64,"address":[2271605,2271540],"length":1,"stats":{"Line":6}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[2628185,2628792],"length":1,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[2236376],"length":1,"stats":{"Line":0}},{"line":73,"address":[2793850,2803658],"length":1,"stats":{"Line":3}},{"line":76,"address":[2232751],"length":1,"stats":{"Line":2}},{"line":77,"address":[2800596,2790788],"length":1,"stats":{"Line":2}},{"line":78,"address":[2236588],"length":1,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[2237122],"length":1,"stats":{"Line":0}},{"line":83,"address":[2939286,2938931],"length":1,"stats":{"Line":2}},{"line":84,"address":[2618394,2618459],"length":1,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[2272780],"length":1,"stats":{"Line":2}},{"line":91,"address":[2268551],"length":1,"stats":{"Line":5}},{"line":93,"address":[2268649,2273303],"length":1,"stats":{"Line":10}},{"line":94,"address":[2795578,2805316,2805386,2795508],"length":1,"stats":{"Line":11}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[2939574,2939990],"length":1,"stats":{"Line":16}},{"line":100,"address":[2494476,2494373],"length":1,"stats":{"Line":7}},{"line":101,"address":[2940234,2940299],"length":1,"stats":{"Line":13}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[2940072,2940434],"length":1,"stats":{"Line":14}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[2495170],"length":1,"stats":{"Line":0}},{"line":114,"address":[2619985,2619734],"length":1,"stats":{"Line":7}},{"line":115,"address":[2274782],"length":1,"stats":{"Line":4}},{"line":118,"address":[2619324],"length":1,"stats":{"Line":5}},{"line":121,"address":[2268704],"length":1,"stats":{"Line":4}},{"line":123,"address":[2791020,2800828],"length":1,"stats":{"Line":4}},{"line":124,"address":[2935101],"length":1,"stats":{"Line":4}},{"line":125,"address":[2791143,2800951],"length":1,"stats":{"Line":4}},{"line":126,"address":[2233160],"length":1,"stats":{"Line":12}},{"line":129,"address":[2941288,2935153,2941359],"length":1,"stats":{"Line":12}},{"line":130,"address":[2275389,2275208],"length":1,"stats":{"Line":8}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[2621103],"length":1,"stats":{"Line":0}},{"line":137,"address":[2631726],"length":1,"stats":{"Line":3}},{"line":140,"address":[2935276],"length":1,"stats":{"Line":4}},{"line":142,"address":[2791337,2801145],"length":1,"stats":{"Line":3}},{"line":144,"address":[2233434],"length":1,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[2791517,2801325],"length":1,"stats":{"Line":3}},{"line":148,"address":[2614470],"length":1,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[2489981],"length":1,"stats":{"Line":1}},{"line":153,"address":[2625835],"length":1,"stats":{"Line":1}},{"line":156,"address":[2935681],"length":1,"stats":{"Line":2}},{"line":157,"address":[2614730,2621371,2621451,2614669],"length":1,"stats":{"Line":6}},{"line":158,"address":[2801555,2791747],"length":1,"stats":{"Line":6}},{"line":159,"address":[2632601,2625972],"length":1,"stats":{"Line":2}},{"line":160,"address":[2496817],"length":1,"stats":{"Line":2}},{"line":161,"address":[2276241],"length":1,"stats":{"Line":2}},{"line":162,"address":[2632728],"length":1,"stats":{"Line":2}},{"line":165,"address":[2626061],"length":1,"stats":{"Line":4}},{"line":166,"address":[2233933,2233873,2240616],"length":1,"stats":{"Line":7}},{"line":167,"address":[2572784,2572822],"length":1,"stats":{"Line":12}},{"line":169,"address":[2942690],"length":1,"stats":{"Line":3}},{"line":170,"address":[2276506],"length":1,"stats":{"Line":3}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[2490395],"length":1,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[2798793,2808601],"length":1,"stats":{"Line":2}},{"line":179,"address":[2164624,2164648],"length":1,"stats":{"Line":6}},{"line":181,"address":[2633299,2633191],"length":1,"stats":{"Line":2}},{"line":182,"address":[2633604],"length":1,"stats":{"Line":2}},{"line":184,"address":[2633727],"length":1,"stats":{"Line":2}},{"line":187,"address":[2801860,2792052],"length":1,"stats":{"Line":0}},{"line":189,"address":[2801910,2792102,2809260,2799452],"length":1,"stats":{"Line":0}},{"line":190,"address":[2622737],"length":1,"stats":{"Line":0}},{"line":195,"address":[2280400,2278272,2282231],"length":1,"stats":{"Line":11}},{"line":201,"address":[2944637],"length":1,"stats":{"Line":8}},{"line":202,"address":[],"length":0,"stats":{"Line":38}},{"line":204,"address":[2242712],"length":1,"stats":{"Line":5}},{"line":206,"address":[2635189,2635112],"length":1,"stats":{"Line":10}},{"line":208,"address":[2944998,2945168],"length":1,"stats":{"Line":7}},{"line":210,"address":[2944955,2945061],"length":1,"stats":{"Line":11}},{"line":214,"address":[2243157,2243192],"length":1,"stats":{"Line":7}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[2635538,2635814,2635467],"length":1,"stats":{"Line":15}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[2279433],"length":1,"stats":{"Line":1}},{"line":224,"address":[2501019,2501905,2500061],"length":1,"stats":{"Line":2}},{"line":225,"address":[2625983,2626525],"length":1,"stats":{"Line":1}},{"line":226,"address":[2947236,2947525],"length":1,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[2626532,2627440,2624725],"length":1,"stats":{"Line":4}},{"line":230,"address":[2947898,2948462],"length":1,"stats":{"Line":2}},{"line":231,"address":[2627097,2627414],"length":1,"stats":{"Line":1}},{"line":235,"address":[2635785],"length":1,"stats":{"Line":6}},{"line":238,"address":[2502864,2505304,2507175],"length":1,"stats":{"Line":3}},{"line":245,"address":[2502978],"length":1,"stats":{"Line":3}},{"line":246,"address":[2639200],"length":1,"stats":{"Line":3}},{"line":247,"address":[2573408,2573432],"length":1,"stats":{"Line":9}},{"line":249,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[2283012,2283105],"length":1,"stats":{"Line":7}},{"line":254,"address":[2283201],"length":1,"stats":{"Line":3}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":7}},{"line":258,"address":[2283678],"length":1,"stats":{"Line":1}},{"line":259,"address":[2247954,2248069,2248958],"length":1,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[2641187,2640898],"length":1,"stats":{"Line":1}},{"line":263,"address":[2628974],"length":1,"stats":{"Line":0}},{"line":264,"address":[2249849,2248005,2248963],"length":1,"stats":{"Line":0}},{"line":265,"address":[2821167,2825311,2821681,2825825],"length":1,"stats":{"Line":0}},{"line":266,"address":[2630820,2630531],"length":1,"stats":{"Line":0}},{"line":268,"address":[2950056],"length":1,"stats":{"Line":0}},{"line":269,"address":[2250781,2249854,2248059],"length":1,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[2952440,2952776],"length":1,"stats":{"Line":0}},{"line":275,"address":[2504207],"length":1,"stats":{"Line":4}},{"line":279,"address":[3371585,3371556,3370752],"length":1,"stats":{"Line":2}},{"line":280,"address":[3061791,3061088],"length":1,"stats":{"Line":4}},{"line":281,"address":[3371415,3370877],"length":1,"stats":{"Line":3}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[3371117],"length":1,"stats":{"Line":1}},{"line":286,"address":[2704692,2704896],"length":1,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[3050439,3050271],"length":1,"stats":{"Line":4}},{"line":292,"address":[3049878],"length":1,"stats":{"Line":2}},{"line":296,"address":[3050592,3051664,3051670],"length":1,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":3}},{"line":298,"address":[3051123,3050705,3051015],"length":1,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[3050920],"length":1,"stats":{"Line":2}},{"line":303,"address":[2706244,2705402,2705541,2705604,2705751],"length":1,"stats":{"Line":2}},{"line":305,"address":[2705795],"length":1,"stats":{"Line":1}},{"line":306,"address":[3062613,3062689],"length":1,"stats":{"Line":2}},{"line":308,"address":[2705343],"length":1,"stats":{"Line":1}},{"line":311,"address":[3049706,3042320,3045594],"length":1,"stats":{"Line":11}},{"line":312,"address":[2697167],"length":1,"stats":{"Line":8}},{"line":313,"address":[3363567,3363484],"length":1,"stats":{"Line":6}},{"line":314,"address":[3053826],"length":1,"stats":{"Line":3}},{"line":316,"address":[3042574],"length":1,"stats":{"Line":12}},{"line":317,"address":[2697409],"length":1,"stats":{"Line":4}},{"line":318,"address":[3054037,3060965],"length":1,"stats":{"Line":8}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[3054055,3053995],"length":1,"stats":{"Line":8}},{"line":324,"address":[3054124],"length":1,"stats":{"Line":1}},{"line":325,"address":[3370713],"length":1,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[3363877],"length":1,"stats":{"Line":5}},{"line":331,"address":[3042890],"length":1,"stats":{"Line":4}},{"line":332,"address":[3042997,3042949],"length":1,"stats":{"Line":16}},{"line":335,"address":[2697739,2697803],"length":1,"stats":{"Line":16}},{"line":336,"address":[3054402,3054465],"length":1,"stats":{"Line":17}},{"line":337,"address":[2697911],"length":1,"stats":{"Line":4}},{"line":338,"address":[2697976],"length":1,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[3054409,3054540],"length":1,"stats":{"Line":15}},{"line":346,"address":[3364364,3364412],"length":1,"stats":{"Line":20}},{"line":347,"address":[3364418],"length":1,"stats":{"Line":5}},{"line":348,"address":[],"length":0,"stats":{"Line":7}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[3043354,3043448],"length":1,"stats":{"Line":7}},{"line":356,"address":[3364555],"length":1,"stats":{"Line":3}},{"line":357,"address":[],"length":0,"stats":{"Line":2}},{"line":358,"address":[2698347],"length":1,"stats":{"Line":2}},{"line":359,"address":[2698377],"length":1,"stats":{"Line":3}},{"line":360,"address":[],"length":0,"stats":{"Line":2}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[3054766,3054998],"length":1,"stats":{"Line":13}},{"line":369,"address":[],"length":0,"stats":{"Line":8}},{"line":370,"address":[2698570,2698645],"length":1,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":17}},{"line":373,"address":[2698811],"length":1,"stats":{"Line":4}},{"line":374,"address":[2698940],"length":1,"stats":{"Line":15}},{"line":376,"address":[3044354],"length":1,"stats":{"Line":5}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[3044457,3044683],"length":1,"stats":{"Line":11}},{"line":379,"address":[3044824,3044691],"length":1,"stats":{"Line":15}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[3056024],"length":1,"stats":{"Line":3}},{"line":384,"address":[2699730,2699631],"length":1,"stats":{"Line":7}},{"line":385,"address":[2699668],"length":1,"stats":{"Line":4}},{"line":386,"address":[2700075,2699794],"length":1,"stats":{"Line":6}},{"line":388,"address":[3056492,3056351],"length":1,"stats":{"Line":2}},{"line":391,"address":[],"length":0,"stats":{"Line":5}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[3056991,3055739],"length":1,"stats":{"Line":10}},{"line":396,"address":[3366800],"length":1,"stats":{"Line":5}},{"line":397,"address":[3057143,3057200,3057078],"length":1,"stats":{"Line":9}},{"line":398,"address":[3057214],"length":1,"stats":{"Line":3}},{"line":399,"address":[3057180],"length":1,"stats":{"Line":0}},{"line":400,"address":[3057712,3057491],"length":1,"stats":{"Line":0}},{"line":402,"address":[3046273,3046176],"length":1,"stats":{"Line":0}},{"line":405,"address":[3057103,3057887],"length":1,"stats":{"Line":8}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[3365526,3367761],"length":1,"stats":{"Line":5}},{"line":410,"address":[3367770],"length":1,"stats":{"Line":3}},{"line":411,"address":[2701436],"length":1,"stats":{"Line":2}},{"line":412,"address":[3046833],"length":1,"stats":{"Line":1}},{"line":413,"address":[3058244,3058535],"length":1,"stats":{"Line":0}},{"line":415,"address":[2701674,2701537],"length":1,"stats":{"Line":2}},{"line":418,"address":[2702116,2701487],"length":1,"stats":{"Line":4}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[3368700,3365553],"length":1,"stats":{"Line":2}},{"line":423,"address":[3058949],"length":1,"stats":{"Line":1}},{"line":424,"address":[3059007],"length":1,"stats":{"Line":1}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[3055820,3059234],"length":1,"stats":{"Line":2}},{"line":428,"address":[3059243],"length":1,"stats":{"Line":1}},{"line":430,"address":[3059293,3059386],"length":1,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":2}},{"line":433,"address":[2702856,2702699],"length":1,"stats":{"Line":2}},{"line":436,"address":[3044583,3048611],"length":1,"stats":{"Line":2}},{"line":437,"address":[2699274,2703453],"length":1,"stats":{"Line":2}},{"line":438,"address":[2703683,2699301],"length":1,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[2703908,2699328],"length":1,"stats":{"Line":4}},{"line":441,"address":[3001792,3001776],"length":1,"stats":{"Line":6}},{"line":443,"address":[3055675,3060668],"length":1,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":6}},{"line":449,"address":[],"length":0,"stats":{"Line":4}}],"covered":204,"coverable":253},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","lexer","mod.rs"],"content":"mod tokens;\n\npub use tokens::{keyword_to_token, Token, TokenKind};\n\nuse crate::error::{Error, Result};\n\n/// AWK lexer that tokenizes source code\npub struct Lexer\u003c'a\u003e {\n    source: \u0026'a str,\n    chars: std::iter::Peekable\u003cstd::str::CharIndices\u003c'a\u003e\u003e,\n    line: usize,\n    column: usize,\n    last_token_produces_value: bool,\n}\n\nimpl\u003c'a\u003e Lexer\u003c'a\u003e {\n    pub fn new(source: \u0026'a str) -\u003e Self {\n        Self {\n            source,\n            chars: source.char_indices().peekable(),\n            line: 1,\n            column: 1,\n            last_token_produces_value: false,\n        }\n    }\n\n    /// Tokenize the entire source, returning all tokens\n    pub fn tokenize(\u0026mut self) -\u003e Result\u003cVec\u003cToken\u003e\u003e {\n        // Pre-allocate based on source length (rough estimate: 1 token per 4 chars)\n        let estimated_tokens = self.source.len() / 4 + 1;\n        let mut tokens = Vec::with_capacity(estimated_tokens.min(1024));\n\n        loop {\n            let token = self.next_token()?;\n            let is_eof = matches!(token.kind, TokenKind::Eof);\n            tokens.push(token);\n            if is_eof {\n                break;\n            }\n        }\n        Ok(tokens)\n    }\n\n    /// Get the next token from the source\n    pub fn next_token(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        self.skip_whitespace_and_comments();\n\n        let (line, col) = (self.line, self.column);\n\n        let Some((_pos, ch)) = self.peek_char() else {\n            return Ok(Token::new(TokenKind::Eof, line, col));\n        };\n\n        let token = match ch {\n            // Newlines are significant in AWK\n            '\\n' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Newline, line, col)\n            }\n\n            // String literals\n            '\"' =\u003e self.scan_string()?,\n\n            // Regex or division - depends on context\n            '/' =\u003e {\n                if self.last_token_produces_value {\n                    self.advance();\n                    if self.peek_char_is('=') {\n                        self.advance();\n                        Token::new(TokenKind::SlashAssign, line, col)\n                    } else {\n                        Token::new(TokenKind::Slash, line, col)\n                    }\n                } else {\n                    self.scan_regex()?\n                }\n            }\n\n            // Numbers\n            '0'..='9' | '.' if ch == '.' \u0026\u0026 self.peek_next_is_digit() =\u003e self.scan_number()?,\n            '0'..='9' =\u003e self.scan_number()?,\n\n            // Identifiers and keywords\n            'a'..='z' | 'A'..='Z' | '_' =\u003e self.scan_identifier()?,\n\n            // Operators and delimiters\n            '+' =\u003e {\n                self.advance();\n                if self.peek_char_is('+') {\n                    self.advance();\n                    Token::new(TokenKind::Increment, line, col)\n                } else if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::PlusAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Plus, line, col)\n                }\n            }\n            '-' =\u003e {\n                self.advance();\n                if self.peek_char_is('-') {\n                    self.advance();\n                    Token::new(TokenKind::Decrement, line, col)\n                } else if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::MinusAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Minus, line, col)\n                }\n            }\n            '*' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::StarAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Star, line, col)\n                }\n            }\n            '%' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::PercentAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Percent, line, col)\n                }\n            }\n            '^' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::CaretAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Caret, line, col)\n                }\n            }\n            '\u003c' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::LessEqual, line, col)\n                } else {\n                    Token::new(TokenKind::Less, line, col)\n                }\n            }\n            '\u003e' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::GreaterEqual, line, col)\n                } else if self.peek_char_is('\u003e') {\n                    self.advance();\n                    Token::new(TokenKind::Append, line, col)\n                } else {\n                    Token::new(TokenKind::Greater, line, col)\n                }\n            }\n            '=' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::Equal, line, col)\n                } else {\n                    Token::new(TokenKind::Assign, line, col)\n                }\n            }\n            '!' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::NotEqual, line, col)\n                } else if self.peek_char_is('~') {\n                    self.advance();\n                    Token::new(TokenKind::NotMatch, line, col)\n                } else {\n                    Token::new(TokenKind::Not, line, col)\n                }\n            }\n            '~' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Match, line, col)\n            }\n            '\u0026' =\u003e {\n                self.advance();\n                if self.peek_char_is('\u0026') {\n                    self.advance();\n                    Token::new(TokenKind::And, line, col)\n                } else {\n                    return Err(Error::lexer(\"unexpected '\u0026', did you mean '\u0026\u0026'?\", line, col));\n                }\n            }\n            '|' =\u003e {\n                self.advance();\n                if self.peek_char_is('|') {\n                    self.advance();\n                    Token::new(TokenKind::Or, line, col)\n                } else {\n                    Token::new(TokenKind::Pipe, line, col)\n                }\n            }\n            '$' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Dollar, line, col)\n            }\n            '?' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Question, line, col)\n            }\n            ':' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Colon, line, col)\n            }\n            '(' =\u003e {\n                self.advance();\n                Token::new(TokenKind::LeftParen, line, col)\n            }\n            ')' =\u003e {\n                self.advance();\n                Token::new(TokenKind::RightParen, line, col)\n            }\n            '{' =\u003e {\n                self.advance();\n                Token::new(TokenKind::LeftBrace, line, col)\n            }\n            '}' =\u003e {\n                self.advance();\n                Token::new(TokenKind::RightBrace, line, col)\n            }\n            '[' =\u003e {\n                self.advance();\n                Token::new(TokenKind::LeftBracket, line, col)\n            }\n            ']' =\u003e {\n                self.advance();\n                Token::new(TokenKind::RightBracket, line, col)\n            }\n            ';' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Semicolon, line, col)\n            }\n            ',' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Comma, line, col)\n            }\n\n            _ =\u003e {\n                return Err(Error::lexer(\n                    format!(\"unexpected character '{}'\", ch),\n                    line,\n                    col,\n                ));\n            }\n        };\n\n        self.last_token_produces_value = token.kind.produces_value();\n        Ok(token)\n    }\n\n    fn peek_char(\u0026mut self) -\u003e Option\u003c(usize, char)\u003e {\n        self.chars.peek().copied()\n    }\n\n    fn peek_char_is(\u0026mut self, expected: char) -\u003e bool {\n        self.chars.peek().map(|(_, c)| *c == expected).unwrap_or(false)\n    }\n\n    fn peek_next_is_digit(\u0026self) -\u003e bool {\n        let mut chars = self.chars.clone();\n        chars.next(); // skip current\n        chars.next().map(|(_, c)| c.is_ascii_digit()).unwrap_or(false)\n    }\n\n    fn advance(\u0026mut self) -\u003e Option\u003c(usize, char)\u003e {\n        let result = self.chars.next();\n        if let Some((_, ch)) = result {\n            if ch == '\\n' {\n                self.line += 1;\n                self.column = 1;\n            } else {\n                self.column += 1;\n            }\n        }\n        result\n    }\n\n    fn skip_whitespace_and_comments(\u0026mut self) {\n        loop {\n            match self.peek_char() {\n                Some((_, ' ' | '\\t' | '\\r')) =\u003e {\n                    self.advance();\n                }\n                Some((_, '\\\\')) =\u003e {\n                    // Line continuation\n                    let mut chars = self.chars.clone();\n                    chars.next();\n                    if chars.peek().map(|(_, c)| *c == '\\n').unwrap_or(false) {\n                        self.advance(); // consume backslash\n                        self.advance(); // consume newline\n                    } else {\n                        break;\n                    }\n                }\n                Some((_, '#')) =\u003e {\n                    // Comment - skip to end of line\n                    while let Some((_, ch)) = self.peek_char() {\n                        if ch == '\\n' {\n                            break;\n                        }\n                        self.advance();\n                    }\n                }\n                _ =\u003e break,\n            }\n        }\n    }\n\n    fn scan_string(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let (line, col) = (self.line, self.column);\n        self.advance(); // consume opening quote\n\n        let mut value = String::new();\n\n        loop {\n            match self.advance() {\n                Some((_, '\"')) =\u003e break,\n                Some((_, '\\\\')) =\u003e {\n                    // Escape sequence\n                    match self.peek_char() {\n                        Some((_, 'n')) =\u003e { self.advance(); value.push('\\n'); }\n                        Some((_, 't')) =\u003e { self.advance(); value.push('\\t'); }\n                        Some((_, 'r')) =\u003e { self.advance(); value.push('\\r'); }\n                        Some((_, 'b')) =\u003e { self.advance(); value.push('\\x08'); }\n                        Some((_, 'f')) =\u003e { self.advance(); value.push('\\x0C'); }\n                        Some((_, 'a')) =\u003e { self.advance(); value.push('\\x07'); }\n                        Some((_, 'v')) =\u003e { self.advance(); value.push('\\x0B'); }\n                        Some((_, '\\\\')) =\u003e { self.advance(); value.push('\\\\'); }\n                        Some((_, '\"')) =\u003e { self.advance(); value.push('\"'); }\n                        Some((_, '/')) =\u003e { self.advance(); value.push('/'); }\n                        Some((_, 'x')) =\u003e {\n                            // Hex escape: \\xNN\n                            self.advance(); // consume 'x'\n                            let hex = self.read_hex_digits(2);\n                            if let Some(ch) = u8::from_str_radix(\u0026hex, 16).ok().map(|b| b as char) {\n                                value.push(ch);\n                            } else {\n                                value.push_str(\"\\\\x\");\n                                value.push_str(\u0026hex);\n                            }\n                        }\n                        Some((_, c)) if c.is_ascii_digit() \u0026\u0026 c != '8' \u0026\u0026 c != '9' =\u003e {\n                            // Octal escape: \\NNN (1-3 octal digits)\n                            let octal = self.read_octal_digits(3);\n                            if let Some(ch) = u8::from_str_radix(\u0026octal, 8).ok().map(|b| b as char) {\n                                value.push(ch);\n                            } else {\n                                value.push('\\\\');\n                                value.push_str(\u0026octal);\n                            }\n                        }\n                        Some((_, c)) =\u003e {\n                            // Unknown escape, just use the character\n                            self.advance();\n                            value.push(c);\n                        }\n                        None =\u003e {\n                            return Err(Error::lexer(\"unterminated string\", line, col));\n                        }\n                    }\n                }\n                Some((_, '\\n')) =\u003e {\n                    return Err(Error::lexer(\"unterminated string (newline in string)\", line, col));\n                }\n                Some((_, ch)) =\u003e value.push(ch),\n                None =\u003e {\n                    return Err(Error::lexer(\"unterminated string\", line, col));\n                }\n            }\n        }\n\n        Ok(Token::new(TokenKind::String(value), line, col))\n    }\n\n    fn read_hex_digits(\u0026mut self, max_count: usize) -\u003e String {\n        let mut result = String::new();\n        for _ in 0..max_count {\n            match self.peek_char() {\n                Some((_, c)) if c.is_ascii_hexdigit() =\u003e {\n                    self.advance();\n                    result.push(c);\n                }\n                _ =\u003e break,\n            }\n        }\n        result\n    }\n\n    fn read_octal_digits(\u0026mut self, max_count: usize) -\u003e String {\n        let mut result = String::new();\n        for _ in 0..max_count {\n            match self.peek_char() {\n                Some((_, c)) if c \u003e= '0' \u0026\u0026 c \u003c= '7' =\u003e {\n                    self.advance();\n                    result.push(c);\n                }\n                _ =\u003e break,\n            }\n        }\n        result\n    }\n\n    fn scan_regex(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let (line, col) = (self.line, self.column);\n        self.advance(); // consume opening slash\n\n        let mut pattern = String::new();\n\n        loop {\n            match self.advance() {\n                Some((_, '/')) =\u003e break,\n                Some((_, '\\\\')) =\u003e {\n                    // Escape next character in regex\n                    pattern.push('\\\\');\n                    if let Some((_, ch)) = self.advance() {\n                        pattern.push(ch);\n                    } else {\n                        return Err(Error::lexer(\"unterminated regex\", line, col));\n                    }\n                }\n                Some((_, '\\n')) =\u003e {\n                    return Err(Error::lexer(\"unterminated regex (newline in regex)\", line, col));\n                }\n                Some((_, ch)) =\u003e pattern.push(ch),\n                None =\u003e {\n                    return Err(Error::lexer(\"unterminated regex\", line, col));\n                }\n            }\n        }\n\n        Ok(Token::new(TokenKind::Regex(pattern), line, col))\n    }\n\n    fn scan_number(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let (line, col) = (self.line, self.column);\n        let start_pos = self.chars.peek().map(|(pos, _)| *pos).unwrap_or(0);\n        let mut end_pos = start_pos;\n\n        // Integer part\n        while let Some((pos, ch)) = self.peek_char() {\n            if ch.is_ascii_digit() {\n                end_pos = pos + 1;\n                self.advance();\n            } else {\n                break;\n            }\n        }\n\n        // Decimal part\n        if self.peek_char_is('.') {\n            self.advance();\n            end_pos += 1;\n\n            while let Some((pos, ch)) = self.peek_char() {\n                if ch.is_ascii_digit() {\n                    end_pos = pos + 1;\n                    self.advance();\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // Exponent part\n        if let Some((_, 'e' | 'E')) = self.peek_char() {\n            self.advance();\n            end_pos += 1;\n\n            if let Some((_, '+' | '-')) = self.peek_char() {\n                self.advance();\n                end_pos += 1;\n            }\n\n            while let Some((pos, ch)) = self.peek_char() {\n                if ch.is_ascii_digit() {\n                    end_pos = pos + 1;\n                    self.advance();\n                } else {\n                    break;\n                }\n            }\n        }\n\n        let number_str = \u0026self.source[start_pos..end_pos];\n        let value: f64 = number_str\n            .parse()\n            .map_err(|_| Error::lexer(format!(\"invalid number '{}'\", number_str), line, col))?;\n\n        Ok(Token::new(TokenKind::Number(value), line, col))\n    }\n\n    fn scan_identifier(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let (line, col) = (self.line, self.column);\n        let start_pos = self.chars.peek().map(|(pos, _)| *pos).unwrap_or(0);\n        let mut end_pos = start_pos;\n\n        while let Some((pos, ch)) = self.peek_char() {\n            if ch.is_ascii_alphanumeric() || ch == '_' {\n                end_pos = pos + 1;\n                self.advance();\n            } else {\n                break;\n            }\n        }\n\n        let ident = \u0026self.source[start_pos..end_pos];\n\n        // Check if it's a keyword\n        let kind = keyword_to_token(ident).unwrap_or_else(|| TokenKind::Identifier(ident.to_string()));\n\n        Ok(Token::new(kind, line, col))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_tokens() {\n        // Test operators in context where / is division (after identifier)\n        let mut lexer = Lexer::new(\"x + y - z * w / v % u\");\n        let tokens = lexer.tokenize().unwrap();\n\n        assert!(matches!(tokens[1].kind, TokenKind::Plus));\n        assert!(matches!(tokens[3].kind, TokenKind::Minus));\n        assert!(matches!(tokens[5].kind, TokenKind::Star));\n        assert!(matches!(tokens[7].kind, TokenKind::Slash));\n        assert!(matches!(tokens[9].kind, TokenKind::Percent));\n    }\n\n    #[test]\n    fn test_keywords() {\n        let mut lexer = Lexer::new(\"BEGIN END if else while for print\");\n        let tokens = lexer.tokenize().unwrap();\n\n        assert!(matches!(tokens[0].kind, TokenKind::Begin));\n        assert!(matches!(tokens[1].kind, TokenKind::End));\n        assert!(matches!(tokens[2].kind, TokenKind::If));\n        assert!(matches!(tokens[3].kind, TokenKind::Else));\n        assert!(matches!(tokens[4].kind, TokenKind::While));\n        assert!(matches!(tokens[5].kind, TokenKind::For));\n        assert!(matches!(tokens[6].kind, TokenKind::Print));\n    }\n\n    #[test]\n    fn test_numbers() {\n        let mut lexer = Lexer::new(\"42 3.14 1e10 2.5e-3\");\n        let tokens = lexer.tokenize().unwrap();\n\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if n == 42.0));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if (n - 3.14).abs() \u003c 0.001));\n        assert!(matches!(tokens[2].kind, TokenKind::Number(n) if n == 1e10));\n        assert!(matches!(tokens[3].kind, TokenKind::Number(n) if (n - 2.5e-3).abs() \u003c 0.0001));\n    }\n\n    #[test]\n    fn test_strings() {\n        let mut lexer = Lexer::new(r#\"\"hello\" \"world\\n\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::String(s) if s == \"hello\"));\n        assert!(matches!(\u0026tokens[1].kind, TokenKind::String(s) if s == \"world\\n\"));\n    }\n\n    #[test]\n    fn test_regex_vs_division() {\n        // After identifier, / is division\n        let mut lexer = Lexer::new(\"x / 2\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Slash));\n\n        // At start, / begins a regex\n        let mut lexer = Lexer::new(\"/pattern/\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Regex(s) if s == \"pattern\"));\n    }\n\n    #[test]\n    fn test_line_tracking() {\n        let mut lexer = Lexer::new(\"a\\nb\\nc\");\n        let tokens = lexer.tokenize().unwrap();\n\n        assert_eq!(tokens[0].location.line, 1);\n        assert_eq!(tokens[2].location.line, 2);\n        assert_eq!(tokens[4].location.line, 3);\n    }\n\n    #[test]\n    fn test_comparison_operators() {\n        let mut lexer = Lexer::new(\"\u003c \u003c= \u003e \u003e= == !=\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Less));\n        assert!(matches!(tokens[1].kind, TokenKind::LessEqual));\n        assert!(matches!(tokens[2].kind, TokenKind::Greater));\n        assert!(matches!(tokens[3].kind, TokenKind::GreaterEqual));\n        assert!(matches!(tokens[4].kind, TokenKind::Equal));\n        assert!(matches!(tokens[5].kind, TokenKind::NotEqual));\n    }\n\n    #[test]\n    fn test_logical_operators() {\n        let mut lexer = Lexer::new(\"\u0026\u0026 || !\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::And));\n        assert!(matches!(tokens[1].kind, TokenKind::Or));\n        assert!(matches!(tokens[2].kind, TokenKind::Not));\n    }\n\n    #[test]\n    fn test_regex_match_operators() {\n        let mut lexer = Lexer::new(\"x ~ y x !~ y\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Match));\n        assert!(matches!(tokens[4].kind, TokenKind::NotMatch));\n    }\n\n    #[test]\n    fn test_assignment_operators() {\n        // Put value-producing tokens before /= to avoid regex interpretation\n        let mut lexer = Lexer::new(\"x = 1 x += 1 x -= 1 x *= 1 x /= 1 x %= 1 x ^= 1\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Assign));\n        assert!(matches!(tokens[4].kind, TokenKind::PlusAssign));\n        assert!(matches!(tokens[7].kind, TokenKind::MinusAssign));\n        assert!(matches!(tokens[10].kind, TokenKind::StarAssign));\n        assert!(matches!(tokens[13].kind, TokenKind::SlashAssign));\n        assert!(matches!(tokens[16].kind, TokenKind::PercentAssign));\n        assert!(matches!(tokens[19].kind, TokenKind::CaretAssign));\n    }\n\n    #[test]\n    fn test_increment_decrement() {\n        let mut lexer = Lexer::new(\"++ --\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Increment));\n        assert!(matches!(tokens[1].kind, TokenKind::Decrement));\n    }\n\n    #[test]\n    fn test_delimiters() {\n        let mut lexer = Lexer::new(\"( ) { } [ ] ; ,\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::LeftParen));\n        assert!(matches!(tokens[1].kind, TokenKind::RightParen));\n        assert!(matches!(tokens[2].kind, TokenKind::LeftBrace));\n        assert!(matches!(tokens[3].kind, TokenKind::RightBrace));\n        assert!(matches!(tokens[4].kind, TokenKind::LeftBracket));\n        assert!(matches!(tokens[5].kind, TokenKind::RightBracket));\n        assert!(matches!(tokens[6].kind, TokenKind::Semicolon));\n        assert!(matches!(tokens[7].kind, TokenKind::Comma));\n    }\n\n    #[test]\n    fn test_special_operators() {\n        let mut lexer = Lexer::new(\"$ ? : | \u003e\u003e\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Dollar));\n        assert!(matches!(tokens[1].kind, TokenKind::Question));\n        assert!(matches!(tokens[2].kind, TokenKind::Colon));\n        assert!(matches!(tokens[3].kind, TokenKind::Pipe));\n        assert!(matches!(tokens[4].kind, TokenKind::Append));\n    }\n\n    #[test]\n    fn test_exponent() {\n        let mut lexer = Lexer::new(\"x ^ 2\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Caret));\n    }\n\n    #[test]\n    fn test_comments() {\n        let mut lexer = Lexer::new(\"x # this is a comment\\ny\");\n        let tokens = lexer.tokenize().unwrap();\n        // Comment should be skipped\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Identifier(s) if s == \"x\"));\n        assert!(matches!(tokens[1].kind, TokenKind::Newline));\n        assert!(matches!(\u0026tokens[2].kind, TokenKind::Identifier(s) if s == \"y\"));\n    }\n\n    #[test]\n    fn test_line_continuation() {\n        let mut lexer = Lexer::new(\"x \\\\\\ny\");\n        let tokens = lexer.tokenize().unwrap();\n        // Backslash-newline should be skipped\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Identifier(s) if s == \"x\"));\n        assert!(matches!(\u0026tokens[1].kind, TokenKind::Identifier(s) if s == \"y\"));\n    }\n\n    #[test]\n    fn test_string_escapes() {\n        let mut lexer = Lexer::new(r#\"\"\\t\\r\\n\\b\\f\\a\\v\\\\\\\"\\/\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert!(s.contains('\\t'));\n            assert!(s.contains('\\r'));\n            assert!(s.contains('\\n'));\n            assert!(s.contains('\\\\'));\n            assert!(s.contains('\"'));\n            assert!(s.contains('/'));\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_hex_escape() {\n        let mut lexer = Lexer::new(r#\"\"\\x41\\x42\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert_eq!(s, \"AB\");\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_octal_escape() {\n        let mut lexer = Lexer::new(r#\"\"\\101\\102\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert_eq!(s, \"AB\");\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_regex_with_escapes() {\n        let mut lexer = Lexer::new(r#\"/a\\/b/\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::Regex(s) = \u0026tokens[0].kind {\n            assert!(s.contains(\"\\\\/\"));\n        } else {\n            panic!(\"Expected regex token\");\n        }\n    }\n\n    #[test]\n    fn test_more_keywords() {\n        let mut lexer = Lexer::new(\"do break continue function return delete exit next nextfile getline printf in BEGINFILE ENDFILE\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Do));\n        assert!(matches!(tokens[1].kind, TokenKind::Break));\n        assert!(matches!(tokens[2].kind, TokenKind::Continue));\n        assert!(matches!(tokens[3].kind, TokenKind::Function));\n        assert!(matches!(tokens[4].kind, TokenKind::Return));\n        assert!(matches!(tokens[5].kind, TokenKind::Delete));\n        assert!(matches!(tokens[6].kind, TokenKind::Exit));\n        assert!(matches!(tokens[7].kind, TokenKind::Next));\n        assert!(matches!(tokens[8].kind, TokenKind::Nextfile));\n        assert!(matches!(tokens[9].kind, TokenKind::Getline));\n        assert!(matches!(tokens[10].kind, TokenKind::Printf));\n        assert!(matches!(tokens[11].kind, TokenKind::In));\n        assert!(matches!(tokens[12].kind, TokenKind::BeginFile));\n        assert!(matches!(tokens[13].kind, TokenKind::EndFile));\n    }\n\n    #[test]\n    fn test_number_with_exponent() {\n        let mut lexer = Lexer::new(\"1e+5 1E-5\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if n == 1e5));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if n == 1e-5));\n    }\n\n    #[test]\n    fn test_decimal_starting_with_dot() {\n        let mut lexer = Lexer::new(\".5 .123\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if (n - 0.5).abs() \u003c 0.001));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if (n - 0.123).abs() \u003c 0.001));\n    }\n\n    #[test]\n    fn test_unexpected_character_error() {\n        let mut lexer = Lexer::new(\"@\");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_unterminated_string_error() {\n        let mut lexer = Lexer::new(\"\\\"unterminated\");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_unterminated_regex_error() {\n        let mut lexer = Lexer::new(\"/unterminated\");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_string_with_newline_error() {\n        let mut lexer = Lexer::new(\"\\\"hello\\nworld\\\"\");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_single_ampersand_error() {\n        let mut lexer = Lexer::new(\"\u0026 \");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_eof_token() {\n        let mut lexer = Lexer::new(\"\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Eof));\n    }\n\n    #[test]\n    fn test_regex_with_escapes_complete() {\n        let mut lexer = Lexer::new(r#\"/\\d+\\.\\d*/\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::Regex(s) = \u0026tokens[0].kind {\n            assert!(s.contains(r\"\\d\"));\n        } else {\n            panic!(\"Expected regex token\");\n        }\n    }\n\n    #[test]\n    fn test_string_unknown_escape() {\n        // Unknown escape sequences should just use the character\n        let mut lexer = Lexer::new(r#\"\"\\q\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert_eq!(s, \"q\");\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_number_leading_dot() {\n        let mut lexer = Lexer::new(\".123 .5e2\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if (n - 0.123).abs() \u003c 0.001));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if n == 50.0));\n    }\n\n    #[test]\n    fn test_number_exponent_variations() {\n        let mut lexer = Lexer::new(\"1e5 1E5 1e+5 1e-5 1.5e10\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if n == 1e5));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if n == 1e5));\n        assert!(matches!(tokens[2].kind, TokenKind::Number(n) if n == 1e5));\n        assert!(matches!(tokens[3].kind, TokenKind::Number(n) if n == 1e-5));\n        assert!(matches!(tokens[4].kind, TokenKind::Number(n) if n == 1.5e10));\n    }\n\n    #[test]\n    fn test_regex_after_comma() {\n        // After comma, / should be regex\n        let mut lexer = Lexer::new(\"gsub(/a/, /b/)\");\n        let tokens = lexer.tokenize().unwrap();\n        // gsub ( /a/ , /b/ )\n        assert!(matches!(\u0026tokens[2].kind, TokenKind::Regex(s) if s == \"a\"));\n        assert!(matches!(\u0026tokens[4].kind, TokenKind::Regex(s) if s == \"b\"));\n    }\n\n    #[test]\n    fn test_regex_after_operators() {\n        // After various operators, / should be regex\n        let mut lexer = Lexer::new(\"x ~ /a/ \u0026\u0026 /b/\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(\u0026tokens[2].kind, TokenKind::Regex(s) if s == \"a\"));\n        assert!(matches!(\u0026tokens[4].kind, TokenKind::Regex(s) if s == \"b\"));\n    }\n\n    #[test]\n    fn test_multiple_newlines() {\n        let mut lexer = Lexer::new(\"a\\n\\n\\nb\");\n        let tokens = lexer.tokenize().unwrap();\n        // Should have multiple newline tokens\n        let newline_count = tokens.iter().filter(|t| matches!(t.kind, TokenKind::Newline)).count();\n        assert!(newline_count \u003e= 2);\n    }\n\n    #[test]\n    fn test_comment_at_end() {\n        let mut lexer = Lexer::new(\"x # comment at end\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Identifier(s) if s == \"x\"));\n        assert!(matches!(tokens[1].kind, TokenKind::Eof));\n    }\n\n    #[test]\n    fn test_identifier_with_underscore() {\n        let mut lexer = Lexer::new(\"_var var_name my_func_2\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Identifier(s) if s == \"_var\"));\n        assert!(matches!(\u0026tokens[1].kind, TokenKind::Identifier(s) if s == \"var_name\"));\n        assert!(matches!(\u0026tokens[2].kind, TokenKind::Identifier(s) if s == \"my_func_2\"));\n    }\n\n    #[test]\n    fn test_string_with_all_escapes() {\n        let mut lexer = Lexer::new(r#\"\"\\b\\f\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert!(s.contains('\\x08'));  // backspace\n            assert!(s.contains('\\x0C'));  // form feed\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_invalid_hex_escape() {\n        // Invalid hex should fall back gracefully\n        let mut lexer = Lexer::new(r#\"\"\\xGG\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            // Should contain x since the hex parse failed\n            assert!(s.contains(\"GG\") || s.contains(\"x\"));\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_single_pipe() {\n        let mut lexer = Lexer::new(\"a | b\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Pipe));\n    }\n\n    #[test]\n    fn test_double_pipe() {\n        let mut lexer = Lexer::new(\"a || b\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Or));\n    }\n\n    #[test]\n    fn test_colon() {\n        let mut lexer = Lexer::new(\"a ? b : c\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Question));\n        assert!(matches!(tokens[3].kind, TokenKind::Colon));\n    }\n\n    #[test]\n    fn test_caret() {\n        let mut lexer = Lexer::new(\"x ^ 2 x ^= 3\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Caret));\n        assert!(matches!(tokens[4].kind, TokenKind::CaretAssign));\n    }\n\n    #[test]\n    fn test_all_assignment_types() {\n        let mut lexer = Lexer::new(\"a += 1 b -= 1 c *= 1 d %= 1\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::PlusAssign));\n        assert!(matches!(tokens[4].kind, TokenKind::MinusAssign));\n        assert!(matches!(tokens[7].kind, TokenKind::StarAssign));\n        assert!(matches!(tokens[10].kind, TokenKind::PercentAssign));\n    }\n}\n","traces":[{"line":17,"address":[2185856],"length":1,"stats":{"Line":68}},{"line":20,"address":[2998658],"length":1,"stats":{"Line":29}},{"line":28,"address":[2999676,2998992,2999703],"length":1,"stats":{"Line":68}},{"line":30,"address":[2987758,2987842],"length":1,"stats":{"Line":29}},{"line":31,"address":[],"length":0,"stats":{"Line":69}},{"line":33,"address":[],"length":0,"stats":{"Line":11}},{"line":34,"address":[],"length":0,"stats":{"Line":40}},{"line":35,"address":[],"length":0,"stats":{"Line":39}},{"line":36,"address":[2999414],"length":1,"stats":{"Line":11}},{"line":37,"address":[],"length":0,"stats":{"Line":39}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[2186757],"length":1,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":69}},{"line":46,"address":[2174918],"length":1,"stats":{"Line":29}},{"line":48,"address":[2976288],"length":1,"stats":{"Line":71}},{"line":50,"address":[2976322],"length":1,"stats":{"Line":43}},{"line":51,"address":[2976455],"length":1,"stats":{"Line":7}},{"line":54,"address":[2175042],"length":1,"stats":{"Line":78}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[2987813],"length":1,"stats":{"Line":2}},{"line":58,"address":[3297588],"length":1,"stats":{"Line":3}},{"line":62,"address":[2987872,2989173],"length":1,"stats":{"Line":7}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[2976671,2978249],"length":1,"stats":{"Line":13}},{"line":67,"address":[2989366],"length":1,"stats":{"Line":3}},{"line":68,"address":[2989376],"length":1,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[3299347],"length":1,"stats":{"Line":2}},{"line":72,"address":[3299288],"length":1,"stats":{"Line":3}},{"line":75,"address":[2989396,2989310],"length":1,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":110}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[2980200,2980245,2976710],"length":1,"stats":{"Line":138}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[2988037],"length":1,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[2177300],"length":1,"stats":{"Line":3}},{"line":91,"address":[2978702],"length":1,"stats":{"Line":4}},{"line":92,"address":[2978666],"length":1,"stats":{"Line":3}},{"line":93,"address":[2177406],"length":1,"stats":{"Line":3}},{"line":94,"address":[2990074],"length":1,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[2976811],"length":1,"stats":{"Line":4}},{"line":101,"address":[2175457],"length":1,"stats":{"Line":4}},{"line":102,"address":[3299899],"length":1,"stats":{"Line":2}},{"line":103,"address":[2177500],"length":1,"stats":{"Line":2}},{"line":104,"address":[2177464],"length":1,"stats":{"Line":4}},{"line":105,"address":[2990247],"length":1,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[3299963],"length":1,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[3297873],"length":1,"stats":{"Line":3}},{"line":113,"address":[3297883],"length":1,"stats":{"Line":3}},{"line":114,"address":[2177697],"length":1,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[2979047],"length":1,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[3297911],"length":1,"stats":{"Line":3}},{"line":122,"address":[2988161],"length":1,"stats":{"Line":4}},{"line":123,"address":[2177803],"length":1,"stats":{"Line":2}},{"line":124,"address":[2979214],"length":1,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[2976925],"length":1,"stats":{"Line":4}},{"line":131,"address":[2988199],"length":1,"stats":{"Line":3}},{"line":132,"address":[2990571],"length":1,"stats":{"Line":2}},{"line":133,"address":[3300346],"length":1,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":7}},{"line":140,"address":[],"length":0,"stats":{"Line":7}},{"line":141,"address":[3300439],"length":1,"stats":{"Line":8}},{"line":142,"address":[2990694],"length":1,"stats":{"Line":8}},{"line":144,"address":[2177972],"length":1,"stats":{"Line":5}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[2988275],"length":1,"stats":{"Line":3}},{"line":150,"address":[2178094],"length":1,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[2990738],"length":1,"stats":{"Line":3}},{"line":153,"address":[3300627],"length":1,"stats":{"Line":2}},{"line":154,"address":[2979618],"length":1,"stats":{"Line":2}},{"line":156,"address":[3300583],"length":1,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[3298063],"length":1,"stats":{"Line":28}},{"line":161,"address":[2988313],"length":1,"stats":{"Line":28}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[2178321],"length":1,"stats":{"Line":4}},{"line":165,"address":[2178263],"length":1,"stats":{"Line":27}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[3298101],"length":1,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[2979806],"length":1,"stats":{"Line":2}},{"line":173,"address":[3300794],"length":1,"stats":{"Line":2}},{"line":174,"address":[3300923],"length":1,"stats":{"Line":3}},{"line":175,"address":[3300938],"length":1,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[2175751],"length":1,"stats":{"Line":5}},{"line":182,"address":[],"length":0,"stats":{"Line":5}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[2977174],"length":1,"stats":{"Line":2}},{"line":186,"address":[2977184],"length":1,"stats":{"Line":2}},{"line":187,"address":[2991302],"length":1,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[2991410],"length":1,"stats":{"Line":3}},{"line":197,"address":[2178749],"length":1,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":4}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[2977250],"length":1,"stats":{"Line":3}},{"line":204,"address":[3298289],"length":1,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[3298333],"length":1,"stats":{"Line":5}},{"line":208,"address":[3298348],"length":1,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[3298392],"length":1,"stats":{"Line":3}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":6}},{"line":216,"address":[2176074],"length":1,"stats":{"Line":8}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[2176117],"length":1,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":14}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":8}},{"line":224,"address":[],"length":0,"stats":{"Line":8}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[2176233],"length":1,"stats":{"Line":3}},{"line":228,"address":[2988883],"length":1,"stats":{"Line":6}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[2988927],"length":1,"stats":{"Line":19}},{"line":232,"address":[2176306],"length":1,"stats":{"Line":19}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[3298746],"length":1,"stats":{"Line":13}},{"line":236,"address":[2977737],"length":1,"stats":{"Line":13}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[3298802],"length":1,"stats":{"Line":4}},{"line":240,"address":[2977793],"length":1,"stats":{"Line":5}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[2977834],"length":1,"stats":{"Line":6}},{"line":244,"address":[3298873],"length":1,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[2978532],"length":1,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[2176515,2179371],"length":1,"stats":{"Line":19}},{"line":257,"address":[],"length":0,"stats":{"Line":39}},{"line":260,"address":[3309488],"length":1,"stats":{"Line":69}},{"line":261,"address":[2186917],"length":1,"stats":{"Line":29}},{"line":264,"address":[],"length":0,"stats":{"Line":22}},{"line":265,"address":[2666224,2666234],"length":1,"stats":{"Line":37}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[2185482],"length":1,"stats":{"Line":1}},{"line":271,"address":[3026621,3026608],"length":1,"stats":{"Line":3}},{"line":274,"address":[2987504],"length":1,"stats":{"Line":9}},{"line":275,"address":[2186014],"length":1,"stats":{"Line":9}},{"line":276,"address":[2186032],"length":1,"stats":{"Line":9}},{"line":277,"address":[2186165,2186193,2186067],"length":1,"stats":{"Line":49}},{"line":278,"address":[2987658,2987598,2987672],"length":1,"stats":{"Line":4}},{"line":279,"address":[2998926],"length":1,"stats":{"Line":2}},{"line":281,"address":[2998890,2998964,2998958],"length":1,"stats":{"Line":22}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":69}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[3308083],"length":1,"stats":{"Line":29}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[2185665],"length":1,"stats":{"Line":69}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[3308205],"length":1,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[2998471],"length":1,"stats":{"Line":3}},{"line":298,"address":[2998564],"length":1,"stats":{"Line":1}},{"line":299,"address":[3308334],"length":1,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[2998584,2998513],"length":1,"stats":{"Line":6}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[2996783,2996262,2994480],"length":1,"stats":{"Line":6}},{"line":319,"address":[2994530],"length":1,"stats":{"Line":6}},{"line":320,"address":[2181858],"length":1,"stats":{"Line":7}},{"line":322,"address":[2181863],"length":1,"stats":{"Line":20}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":45}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[2995082,2995226],"length":1,"stats":{"Line":8}},{"line":330,"address":[2984393,2984190],"length":1,"stats":{"Line":6}},{"line":331,"address":[],"length":0,"stats":{"Line":2}},{"line":332,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[3305492,3305268],"length":1,"stats":{"Line":2}},{"line":334,"address":[3305517,3305286],"length":1,"stats":{"Line":2}},{"line":335,"address":[2995782,2995544],"length":1,"stats":{"Line":2}},{"line":336,"address":[2183071,2182826],"length":1,"stats":{"Line":2}},{"line":337,"address":[2995580,2995832],"length":1,"stats":{"Line":2}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[2182880,2183146],"length":1,"stats":{"Line":2}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[3305394],"length":1,"stats":{"Line":3}},{"line":343,"address":[],"length":0,"stats":{"Line":3}},{"line":344,"address":[2705399,2705392],"length":1,"stats":{"Line":12}},{"line":345,"address":[2984888,2984922],"length":1,"stats":{"Line":5}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[2984954],"length":1,"stats":{"Line":1}},{"line":351,"address":[2995411,2996316,2996272],"length":1,"stats":{"Line":6}},{"line":353,"address":[3306126],"length":1,"stats":{"Line":2}},{"line":354,"address":[2705408,2705415],"length":1,"stats":{"Line":8}},{"line":355,"address":[2183875,2183902],"length":1,"stats":{"Line":4}},{"line":357,"address":[2183895],"length":1,"stats":{"Line":0}},{"line":358,"address":[2985422],"length":1,"stats":{"Line":0}},{"line":361,"address":[2985022],"length":1,"stats":{"Line":1}},{"line":363,"address":[2985040],"length":1,"stats":{"Line":1}},{"line":364,"address":[3306145],"length":1,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[3305090],"length":1,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[2983850,2985472],"length":1,"stats":{"Line":2}},{"line":374,"address":[2184026,2182191],"length":1,"stats":{"Line":58}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[2182092],"length":1,"stats":{"Line":1}},{"line":381,"address":[],"length":0,"stats":{"Line":43}},{"line":384,"address":[2986001,2985616,2986007],"length":1,"stats":{"Line":3}},{"line":385,"address":[],"length":0,"stats":{"Line":3}},{"line":386,"address":[3306698,3306774],"length":1,"stats":{"Line":6}},{"line":387,"address":[2985868,2985799],"length":1,"stats":{"Line":6}},{"line":388,"address":[],"length":0,"stats":{"Line":3}},{"line":389,"address":[2985973],"length":1,"stats":{"Line":3}},{"line":390,"address":[],"length":0,"stats":{"Line":3}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":3}},{"line":398,"address":[2998196,2997792,2998202],"length":1,"stats":{"Line":2}},{"line":399,"address":[2997840],"length":1,"stats":{"Line":2}},{"line":400,"address":[2986586,2986662],"length":1,"stats":{"Line":4}},{"line":401,"address":[2185279,2185210],"length":1,"stats":{"Line":4}},{"line":402,"address":[2986828],"length":1,"stats":{"Line":2}},{"line":403,"address":[2986904],"length":1,"stats":{"Line":2}},{"line":404,"address":[2986920],"length":1,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[2998004],"length":1,"stats":{"Line":2}},{"line":412,"address":[2180338,2180309,2179472],"length":1,"stats":{"Line":5}},{"line":413,"address":[2179510],"length":1,"stats":{"Line":5}},{"line":414,"address":[2179552],"length":1,"stats":{"Line":6}},{"line":416,"address":[2179557],"length":1,"stats":{"Line":7}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[2992268,2992334],"length":1,"stats":{"Line":12}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[2992674],"length":1,"stats":{"Line":3}},{"line":424,"address":[3302550],"length":1,"stats":{"Line":3}},{"line":425,"address":[2992915,2992867],"length":1,"stats":{"Line":6}},{"line":427,"address":[3302644,3302685],"length":1,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[2179995,2180265],"length":1,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":12}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[3302189],"length":1,"stats":{"Line":1}},{"line":440,"address":[],"length":0,"stats":{"Line":12}},{"line":443,"address":[3302816],"length":1,"stats":{"Line":3}},{"line":444,"address":[2981830],"length":1,"stats":{"Line":3}},{"line":445,"address":[2993112],"length":1,"stats":{"Line":11}},{"line":446,"address":[2180454],"length":1,"stats":{"Line":6}},{"line":449,"address":[2981909],"length":1,"stats":{"Line":5}},{"line":450,"address":[2981994],"length":1,"stats":{"Line":5}},{"line":451,"address":[3303065,3303110],"length":1,"stats":{"Line":5}},{"line":452,"address":[3303100],"length":1,"stats":{"Line":5}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[2180574],"length":1,"stats":{"Line":5}},{"line":460,"address":[],"length":0,"stats":{"Line":3}},{"line":461,"address":[3303197,3303237],"length":1,"stats":{"Line":3}},{"line":463,"address":[],"length":0,"stats":{"Line":6}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":465,"address":[3303416,3303371],"length":1,"stats":{"Line":4}},{"line":466,"address":[2180940],"length":1,"stats":{"Line":4}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[3303128,3303429],"length":1,"stats":{"Line":26}},{"line":475,"address":[2982646],"length":1,"stats":{"Line":2}},{"line":476,"address":[2982746,2982651],"length":1,"stats":{"Line":4}},{"line":478,"address":[2994160,2993958,2994023],"length":1,"stats":{"Line":5}},{"line":479,"address":[2181408],"length":1,"stats":{"Line":1}},{"line":480,"address":[3303882,3303922],"length":1,"stats":{"Line":1}},{"line":483,"address":[2181348,2181466],"length":1,"stats":{"Line":4}},{"line":484,"address":[2994210],"length":1,"stats":{"Line":3}},{"line":485,"address":[2181571,2181528],"length":1,"stats":{"Line":2}},{"line":486,"address":[2994270],"length":1,"stats":{"Line":2}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[2993700],"length":1,"stats":{"Line":33}},{"line":494,"address":[2181038,2181138,2181615],"length":1,"stats":{"Line":18}},{"line":496,"address":[3026240,3026208],"length":1,"stats":{"Line":44}},{"line":498,"address":[2983101],"length":1,"stats":{"Line":45}},{"line":501,"address":[2184544],"length":1,"stats":{"Line":66}},{"line":502,"address":[3307094],"length":1,"stats":{"Line":41}},{"line":503,"address":[2184616],"length":1,"stats":{"Line":173}},{"line":504,"address":[2986152],"length":1,"stats":{"Line":41}},{"line":506,"address":[2184672],"length":1,"stats":{"Line":66}},{"line":507,"address":[],"length":0,"stats":{"Line":82}},{"line":508,"address":[],"length":0,"stats":{"Line":66}},{"line":509,"address":[2185000],"length":1,"stats":{"Line":41}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":66}},{"line":518,"address":[2986316],"length":1,"stats":{"Line":145}},{"line":520,"address":[],"length":0,"stats":{"Line":38}}],"covered":251,"coverable":311},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","lexer","tokens.rs"],"content":"use crate::error::SourceLocation;\n\n/// All token types in AWK\n#[derive(Debug, Clone, PartialEq)]\npub enum TokenKind {\n    // Literals\n    Number(f64),\n    String(String),\n    Regex(String),\n\n    // Identifiers and keywords\n    Identifier(String),\n    Begin,\n    End,\n    BeginFile,  // gawk extension\n    EndFile,    // gawk extension\n    If,\n    Else,\n    While,\n    For,\n    Do,\n    Break,\n    Continue,\n    Function,\n    Return,\n    Delete,\n    Exit,\n    Next,\n    Nextfile,\n    Getline,\n    Print,\n    Printf,\n    In,\n\n    // Operators - Arithmetic\n    Plus,        // +\n    Minus,       // -\n    Star,        // *\n    Slash,       // /\n    Percent,     // %\n    Caret,       // ^\n\n    // Operators - Comparison\n    Less,        // \u003c\n    LessEqual,   // \u003c=\n    Greater,     // \u003e\n    GreaterEqual,// \u003e=\n    Equal,       // ==\n    NotEqual,    // !=\n\n    // Operators - Logical\n    And,         // \u0026\u0026\n    Or,          // ||\n    Not,         // !\n\n    // Operators - Regex\n    Match,       // ~\n    NotMatch,    // !~\n\n    // Operators - Assignment\n    Assign,      // =\n    PlusAssign,  // +=\n    MinusAssign, // -=\n    StarAssign,  // *=\n    SlashAssign, // /=\n    PercentAssign, // %=\n    CaretAssign, // ^=\n\n    // Operators - Increment/Decrement\n    Increment,   // ++\n    Decrement,   // --\n\n    // Special operators\n    Dollar,      // $ (field access)\n    Question,    // ?\n    Colon,       // :\n    Pipe,        // |\n    Append,      // \u003e\u003e\n\n    // Delimiters\n    LeftParen,   // (\n    RightParen,  // )\n    LeftBrace,   // {\n    RightBrace,  // }\n    LeftBracket, // [\n    RightBracket,// ]\n    Semicolon,   // ;\n    Comma,       // ,\n    Newline,     // \\n (significant in AWK)\n\n    // End of file\n    Eof,\n}\n\nimpl TokenKind {\n    /// Check if this token is a keyword\n    pub fn is_keyword(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            TokenKind::Begin\n                | TokenKind::End\n                | TokenKind::If\n                | TokenKind::Else\n                | TokenKind::While\n                | TokenKind::For\n                | TokenKind::Do\n                | TokenKind::Break\n                | TokenKind::Continue\n                | TokenKind::Function\n                | TokenKind::Return\n                | TokenKind::Delete\n                | TokenKind::Exit\n                | TokenKind::Next\n                | TokenKind::Nextfile\n                | TokenKind::Getline\n                | TokenKind::Print\n                | TokenKind::Printf\n                | TokenKind::In\n        )\n    }\n\n    /// Check if this token can start an expression\n    pub fn can_start_expression(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            TokenKind::Number(_)\n                | TokenKind::String(_)\n                | TokenKind::Regex(_)\n                | TokenKind::Identifier(_)\n                | TokenKind::LeftParen\n                | TokenKind::Dollar\n                | TokenKind::Not\n                | TokenKind::Plus\n                | TokenKind::Minus\n                | TokenKind::Increment\n                | TokenKind::Decrement\n                | TokenKind::Getline\n        )\n    }\n\n    /// Check if this token produces a value (for regex vs division disambiguation)\n    pub fn produces_value(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            TokenKind::Number(_)\n                | TokenKind::String(_)\n                | TokenKind::Identifier(_)\n                | TokenKind::RightParen\n                | TokenKind::RightBracket\n                | TokenKind::Increment\n                | TokenKind::Decrement\n        )\n    }\n}\n\n/// A token with its location in the source\n#[derive(Debug, Clone)]\npub struct Token {\n    pub kind: TokenKind,\n    pub location: SourceLocation,\n}\n\nimpl Token {\n    pub fn new(kind: TokenKind, line: usize, column: usize) -\u003e Self {\n        Self {\n            kind,\n            location: SourceLocation::new(line, column),\n        }\n    }\n}\n\n/// Map keyword strings to token kinds\npub fn keyword_to_token(s: \u0026str) -\u003e Option\u003cTokenKind\u003e {\n    match s {\n        \"BEGIN\" =\u003e Some(TokenKind::Begin),\n        \"END\" =\u003e Some(TokenKind::End),\n        \"BEGINFILE\" =\u003e Some(TokenKind::BeginFile),\n        \"ENDFILE\" =\u003e Some(TokenKind::EndFile),\n        \"if\" =\u003e Some(TokenKind::If),\n        \"else\" =\u003e Some(TokenKind::Else),\n        \"while\" =\u003e Some(TokenKind::While),\n        \"for\" =\u003e Some(TokenKind::For),\n        \"do\" =\u003e Some(TokenKind::Do),\n        \"break\" =\u003e Some(TokenKind::Break),\n        \"continue\" =\u003e Some(TokenKind::Continue),\n        \"function\" =\u003e Some(TokenKind::Function),\n        \"return\" =\u003e Some(TokenKind::Return),\n        \"delete\" =\u003e Some(TokenKind::Delete),\n        \"exit\" =\u003e Some(TokenKind::Exit),\n        \"next\" =\u003e Some(TokenKind::Next),\n        \"nextfile\" =\u003e Some(TokenKind::Nextfile),\n        \"getline\" =\u003e Some(TokenKind::Getline),\n        \"print\" =\u003e Some(TokenKind::Print),\n        \"printf\" =\u003e Some(TokenKind::Printf),\n        \"in\" =\u003e Some(TokenKind::In),\n        _ =\u003e None,\n    }\n}\n","traces":[{"line":97,"address":[2875712],"length":1,"stats":{"Line":0}},{"line":98,"address":[2875725],"length":1,"stats":{"Line":0}},{"line":99,"address":[2875717],"length":1,"stats":{"Line":0}},{"line":123,"address":[2613488],"length":1,"stats":{"Line":27}},{"line":124,"address":[2887149],"length":1,"stats":{"Line":27}},{"line":125,"address":[2875877],"length":1,"stats":{"Line":9}},{"line":142,"address":[2887040],"length":1,"stats":{"Line":34}},{"line":143,"address":[2887053],"length":1,"stats":{"Line":36}},{"line":144,"address":[2875781],"length":1,"stats":{"Line":8}},{"line":164,"address":[3196720,3196528,3196714],"length":1,"stats":{"Line":8}},{"line":167,"address":[2875569],"length":1,"stats":{"Line":9}},{"line":173,"address":[2884592],"length":1,"stats":{"Line":66}},{"line":175,"address":[2884651,2884710],"length":1,"stats":{"Line":102}},{"line":176,"address":[2873533,2873418],"length":1,"stats":{"Line":8}},{"line":177,"address":[2611236,2611121],"length":1,"stats":{"Line":8}},{"line":178,"address":[3194616,3194734],"length":1,"stats":{"Line":7}},{"line":179,"address":[2873812,2873682],"length":1,"stats":{"Line":69}},{"line":180,"address":[2611530,2611400],"length":1,"stats":{"Line":46}},{"line":181,"address":[2885150,2885280],"length":1,"stats":{"Line":83}},{"line":182,"address":[2885382,2885252],"length":1,"stats":{"Line":51}},{"line":183,"address":[2885484,2885354],"length":1,"stats":{"Line":75}},{"line":184,"address":[2874192,2874322],"length":1,"stats":{"Line":42}},{"line":185,"address":[2874424,2874294],"length":1,"stats":{"Line":77}},{"line":186,"address":[2612012,2612142],"length":1,"stats":{"Line":46}},{"line":187,"address":[2612114,2612244],"length":1,"stats":{"Line":86}},{"line":188,"address":[3195624,3195754],"length":1,"stats":{"Line":45}},{"line":189,"address":[2612318,2612448],"length":1,"stats":{"Line":83}},{"line":190,"address":[2886068,2886198],"length":1,"stats":{"Line":46}},{"line":191,"address":[2612652,2612522],"length":1,"stats":{"Line":82}},{"line":192,"address":[2886272,2886402],"length":1,"stats":{"Line":45}},{"line":193,"address":[2612726,2612856],"length":1,"stats":{"Line":96}},{"line":194,"address":[2886476,2886606],"length":1,"stats":{"Line":54}},{"line":195,"address":[2875314,2875422],"length":1,"stats":{"Line":49}},{"line":196,"address":[2875408],"length":1,"stats":{"Line":61}}],"covered":31,"coverable":34},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","lib.rs"],"content":"//! rawk - A 100% POSIX-compatible AWK implementation in Rust\n//!\n//! This crate provides a complete AWK interpreter that aims for full compatibility\n//! with POSIX AWK and GNU AWK extensions.\n//!\n//! # Example\n//!\n//! ```\n//! use rawk::{Lexer, Parser, Interpreter};\n//! use std::io::BufReader;\n//!\n//! // Parse an AWK program\n//! let source = r#\"BEGIN { print \"Hello, World!\" }\"#;\n//! let mut lexer = Lexer::new(source);\n//! let tokens = lexer.tokenize().unwrap();\n//! let mut parser = Parser::new(tokens);\n//! let program = parser.parse().unwrap();\n//!\n//! // Run the program\n//! let mut interpreter = Interpreter::new(\u0026program);\n//! let mut output = Vec::new();\n//! let inputs: Vec\u003cBufReader\u003c\u0026[u8]\u003e\u003e = vec![];\n//! interpreter.run(inputs, \u0026mut output).unwrap();\n//!\n//! assert_eq!(String::from_utf8(output).unwrap(), \"Hello, World!\\n\");\n//! ```\n//!\n//! # Field Processing Example\n//!\n//! ```\n//! use rawk::{Lexer, Parser, Interpreter};\n//! use std::io::BufReader;\n//!\n//! let source = r#\"{ print $1, $2 }\"#;\n//! let mut lexer = Lexer::new(source);\n//! let tokens = lexer.tokenize().unwrap();\n//! let mut parser = Parser::new(tokens);\n//! let program = parser.parse().unwrap();\n//!\n//! let mut interpreter = Interpreter::new(\u0026program);\n//! interpreter.set_fs(\",\");  // Use comma as field separator\n//!\n//! let input = b\"hello,world\\nfoo,bar\\n\";\n//! let mut output = Vec::new();\n//! let inputs = vec![BufReader::new(\u0026input[..])];\n//! interpreter.run(inputs, \u0026mut output).unwrap();\n//!\n//! assert_eq!(String::from_utf8(output).unwrap(), \"hello world\\nfoo bar\\n\");\n//! ```\n//!\n//! # Pattern Matching Example\n//!\n//! ```\n//! use rawk::{Lexer, Parser, Interpreter};\n//! use std::io::BufReader;\n//!\n//! let source = r#\"/error/ { print \"Found:\", $0 }\"#;\n//! let mut lexer = Lexer::new(source);\n//! let tokens = lexer.tokenize().unwrap();\n//! let mut parser = Parser::new(tokens);\n//! let program = parser.parse().unwrap();\n//!\n//! let mut interpreter = Interpreter::new(\u0026program);\n//! let input = b\"info: ok\\nerror: failed\\ninfo: done\\n\";\n//! let mut output = Vec::new();\n//! let inputs = vec![BufReader::new(\u0026input[..])];\n//! interpreter.run(inputs, \u0026mut output).unwrap();\n//!\n//! assert_eq!(String::from_utf8(output).unwrap(), \"Found: error: failed\\n\");\n//! ```\n\npub mod ast;\npub mod error;\npub mod interpreter;\npub mod lexer;\npub mod parser;\npub mod value;\n\npub use error::{Error, Result, SourceLocation};\npub use interpreter::Interpreter;\npub use lexer::{Lexer, Token, TokenKind};\npub use parser::Parser;\npub use value::Value;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","main.rs"],"content":"use std::env;\nuse std::fs::{self, File};\nuse std::io::{self, BufReader};\nuse std::process;\n\nuse rawk::{Interpreter, Lexer, Parser};\n\nfn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    match run(\u0026args[1..]) {\n        Ok(code) =\u003e process::exit(code),\n        Err(e) =\u003e {\n            eprintln!(\"rawk: {}\", e);\n            process::exit(2);\n        }\n    }\n}\n\nfn run(args: \u0026[String]) -\u003e Result\u003ci32, Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut field_separator = \" \".to_string();\n    let mut program_source: Option\u003cString\u003e = None;\n    let mut input_files: Vec\u003cString\u003e = Vec::new();\n    let mut variables: Vec\u003c(String, String)\u003e = Vec::new();\n    let mut posix_mode = false;\n    let mut traditional_mode = false;\n\n    let mut i = 0;\n    while i \u003c args.len() {\n        let arg = \u0026args[i];\n\n        if arg == \"--help\" || arg == \"-h\" {\n            print_help();\n            return Ok(0);\n        }\n\n        if arg == \"--version\" {\n            println!(\"rawk {}\", env!(\"CARGO_PKG_VERSION\"));\n            return Ok(0);\n        }\n\n        if arg == \"--posix\" || arg == \"-P\" {\n            posix_mode = true;\n            traditional_mode = false;\n            i += 1;\n            continue;\n        }\n\n        if arg == \"--traditional\" || arg == \"--compat\" || arg == \"-c\" {\n            traditional_mode = true;\n            posix_mode = false;\n            i += 1;\n            continue;\n        }\n\n        if arg == \"-F\" {\n            i += 1;\n            if i \u003e= args.len() {\n                return Err(\"option -F requires an argument\".into());\n            }\n            field_separator = args[i].clone();\n        } else if let Some(fs) = arg.strip_prefix(\"-F\") {\n            field_separator = fs.to_string();\n        } else if arg == \"-v\" {\n            i += 1;\n            if i \u003e= args.len() {\n                return Err(\"option -v requires an argument\".into());\n            }\n            let var_assign = \u0026args[i];\n            if let Some((name, value)) = var_assign.split_once('=') {\n                variables.push((name.to_string(), value.to_string()));\n            } else {\n                return Err(format!(\"invalid variable assignment: {}\", var_assign).into());\n            }\n        } else if arg == \"-f\" {\n            i += 1;\n            if i \u003e= args.len() {\n                return Err(\"option -f requires an argument\".into());\n            }\n            let script_file = \u0026args[i];\n            program_source = Some(fs::read_to_string(script_file)?);\n        } else if arg == \"--\" {\n            // End of options\n            i += 1;\n            input_files.extend(args[i..].iter().cloned());\n            break;\n        } else if arg.starts_with('-') \u0026\u0026 arg != \"-\" {\n            return Err(format!(\"unknown option: {}\", arg).into());\n        } else if program_source.is_none() {\n            // First non-option argument is the program\n            program_source = Some(arg.clone());\n        } else {\n            // Rest are input files\n            input_files.push(arg.clone());\n        }\n\n        i += 1;\n    }\n\n    let program_source = program_source.ok_or(\"no program provided\")?;\n\n    // Parse the program\n    let mut lexer = Lexer::new(\u0026program_source);\n    let tokens = lexer.tokenize()?;\n    let mut parser = Parser::new(tokens);\n    let program = parser.parse()?;\n\n    // Create interpreter\n    let mut interpreter = Interpreter::new(\u0026program);\n\n    // Set mode flags\n    interpreter.set_posix_mode(posix_mode);\n    interpreter.set_traditional_mode(traditional_mode);\n\n    // Set field separator\n    interpreter.set_fs(\u0026field_separator);\n\n    // Set ARGC and ARGV (ARGV[0] is \"awk\", ARGV[1...] are input files)\n    let mut argv = vec![\"awk\".to_string()];\n    argv.extend(input_files.iter().cloned());\n    interpreter.set_args(argv);\n\n    // Set variables\n    for (name, value) in \u0026variables {\n        interpreter.set_variable(name, value);\n    }\n\n    // Prepare output\n    let stdout = io::stdout();\n    let mut output = stdout.lock();\n\n    // Prepare inputs\n    let exit_code = if input_files.is_empty() {\n        // Read from stdin\n        interpreter.set_filename(\"\");\n        let stdin = io::stdin();\n        let inputs = vec![BufReader::new(stdin.lock())];\n        interpreter.run(inputs, \u0026mut output)?\n    } else {\n        // Read from files\n        let mut exit_code = 0;\n        for filename in \u0026input_files {\n            interpreter.set_filename(filename);\n            if filename == \"-\" {\n                let stdin = io::stdin();\n                let inputs = vec![BufReader::new(stdin.lock())];\n                exit_code = interpreter.run(inputs, \u0026mut output)?;\n            } else {\n                let file = File::open(filename)?;\n                let inputs = vec![BufReader::new(file)];\n                exit_code = interpreter.run(inputs, \u0026mut output)?;\n            }\n        }\n        exit_code\n    };\n\n    Ok(exit_code)\n}\n\nfn print_help() {\n    println!(\n        r#\"Usage: rawk [OPTIONS] 'program' [file ...]\n       rawk [OPTIONS] -f progfile [file ...]\n\nA 100% POSIX-compatible AWK implementation in Rust with gawk extensions.\n\nOptions:\n  -F fs            Set the field separator to fs\n  -v var=val       Assign value to variable before execution\n  -f progfile      Read the AWK program from file\n  -P, --posix      Strict POSIX mode (disable gawk extensions)\n  -c, --traditional Traditional AWK mode (disable gawk extensions)\n  --version        Print version information\n  --help           Print this help message\n\nGAWK Extensions (disabled with --posix or --traditional):\n  FPAT             Field pattern for content-based splitting\n  FIELDWIDTHS      Fixed-width field splitting\n  BEGINFILE/ENDFILE Patterns for file processing\n  systime(), mktime(), strftime() Time functions\n  gensub(), patsplit(), asort(), asorti() String/array functions\n\nExamples:\n  rawk '{{ print $1 }}' file.txt\n  rawk -F: '{{ print $1 }}' /etc/passwd\n  rawk 'BEGIN {{ print \"Hello\" }}'\n  rawk '/pattern/ {{ print }}' file.txt\n\"#\n    );\n}\n","traces":[{"line":8,"address":[2221315,2220944,2221309],"length":1,"stats":{"Line":0}},{"line":9,"address":[2220951],"length":1,"stats":{"Line":0}},{"line":11,"address":[2221080,2220995],"length":1,"stats":{"Line":0}},{"line":12,"address":[2221163],"length":1,"stats":{"Line":0}},{"line":13,"address":[2221115],"length":1,"stats":{"Line":0}},{"line":14,"address":[2221224,2221140],"length":1,"stats":{"Line":0}},{"line":15,"address":[2221293],"length":1,"stats":{"Line":0}},{"line":20,"address":[2211616,2217286,2220926],"length":1,"stats":{"Line":0}},{"line":21,"address":[2211686],"length":1,"stats":{"Line":0}},{"line":22,"address":[2211747],"length":1,"stats":{"Line":0}},{"line":23,"address":[2211773],"length":1,"stats":{"Line":0}},{"line":24,"address":[2211841],"length":1,"stats":{"Line":0}},{"line":25,"address":[2211889],"length":1,"stats":{"Line":0}},{"line":26,"address":[2211897],"length":1,"stats":{"Line":0}},{"line":28,"address":[2211905],"length":1,"stats":{"Line":0}},{"line":29,"address":[2220578,2211925],"length":1,"stats":{"Line":0}},{"line":30,"address":[2212021,2212119],"length":1,"stats":{"Line":0}},{"line":32,"address":[2212238,2212074,2212186],"length":1,"stats":{"Line":0}},{"line":33,"address":[2212221],"length":1,"stats":{"Line":0}},{"line":34,"address":[2220772],"length":1,"stats":{"Line":0}},{"line":37,"address":[2212244],"length":1,"stats":{"Line":0}},{"line":38,"address":[2212315,2220718],"length":1,"stats":{"Line":0}},{"line":39,"address":[2220745],"length":1,"stats":{"Line":0}},{"line":42,"address":[2212286,2212451,2212356],"length":1,"stats":{"Line":0}},{"line":43,"address":[2212391],"length":1,"stats":{"Line":0}},{"line":44,"address":[2212399],"length":1,"stats":{"Line":0}},{"line":45,"address":[2220684,2212407],"length":1,"stats":{"Line":0}},{"line":49,"address":[2212588,2212457],"length":1,"stats":{"Line":0}},{"line":50,"address":[2212528],"length":1,"stats":{"Line":0}},{"line":51,"address":[2212536],"length":1,"stats":{"Line":0}},{"line":52,"address":[2220642,2212544],"length":1,"stats":{"Line":0}},{"line":56,"address":[2220557,2212636],"length":1,"stats":{"Line":0}},{"line":57,"address":[2220233,2212709,2220253],"length":1,"stats":{"Line":0}},{"line":58,"address":[2220241],"length":1,"stats":{"Line":0}},{"line":59,"address":[2220302,2220622],"length":1,"stats":{"Line":0}},{"line":61,"address":[2220282,2220354,2220434],"length":1,"stats":{"Line":0}},{"line":62,"address":[2212762,2212678],"length":1,"stats":{"Line":0}},{"line":63,"address":[2212962,2212892,2212943],"length":1,"stats":{"Line":0}},{"line":64,"address":[2212911,2213129],"length":1,"stats":{"Line":0}},{"line":65,"address":[2219492,2213164,2219472],"length":1,"stats":{"Line":0}},{"line":66,"address":[2219480],"length":1,"stats":{"Line":0}},{"line":67,"address":[2219541,2220205],"length":1,"stats":{"Line":0}},{"line":69,"address":[2219593,2219521,2219647],"length":1,"stats":{"Line":0}},{"line":70,"address":[2219691,2219609],"length":1,"stats":{"Line":0}},{"line":71,"address":[2219870,2219803],"length":1,"stats":{"Line":0}},{"line":73,"address":[2220025,2219830],"length":1,"stats":{"Line":0}},{"line":75,"address":[2213135,2219416,2213208],"length":1,"stats":{"Line":0}},{"line":76,"address":[2218907,2213243,2218927],"length":1,"stats":{"Line":0}},{"line":77,"address":[2218915],"length":1,"stats":{"Line":0}},{"line":78,"address":[2219444,2218976],"length":1,"stats":{"Line":0}},{"line":80,"address":[2218956,2219028,2219072],"length":1,"stats":{"Line":0}},{"line":81,"address":[2219052,2219277,2219109,2219421],"length":1,"stats":{"Line":0}},{"line":82,"address":[2213214,2213287],"length":1,"stats":{"Line":0}},{"line":84,"address":[2213324,2214020,2214066],"length":1,"stats":{"Line":0}},{"line":85,"address":[2214028,2214103],"length":1,"stats":{"Line":0}},{"line":87,"address":[2213377,2213293,2213435],"length":1,"stats":{"Line":0}},{"line":88,"address":[2213809,2213485],"length":1,"stats":{"Line":0}},{"line":89,"address":[2213421,2213522,2213804],"length":1,"stats":{"Line":0}},{"line":91,"address":[2213555,2213614,2213665],"length":1,"stats":{"Line":0}},{"line":94,"address":[2213582,2213528],"length":1,"stats":{"Line":0}},{"line":97,"address":[2213085,2220583,2220570],"length":1,"stats":{"Line":0}},{"line":100,"address":[2218886,2211935,2214221],"length":1,"stats":{"Line":0}},{"line":103,"address":[2214394,2214477],"length":1,"stats":{"Line":0}},{"line":104,"address":[2218884,2214496],"length":1,"stats":{"Line":0}},{"line":105,"address":[2214727],"length":1,"stats":{"Line":0}},{"line":106,"address":[2214835,2214919,2218827],"length":1,"stats":{"Line":0}},{"line":109,"address":[2215117],"length":1,"stats":{"Line":0}},{"line":112,"address":[2215188],"length":1,"stats":{"Line":0}},{"line":113,"address":[2215256],"length":1,"stats":{"Line":0}},{"line":116,"address":[2215291],"length":1,"stats":{"Line":0}},{"line":119,"address":[2218822,2215359],"length":1,"stats":{"Line":0}},{"line":120,"address":[2215618,2215710],"length":1,"stats":{"Line":0}},{"line":121,"address":[2215807],"length":1,"stats":{"Line":0}},{"line":124,"address":[2215882],"length":1,"stats":{"Line":0}},{"line":125,"address":[2216051,2218721],"length":1,"stats":{"Line":0}},{"line":129,"address":[2216077],"length":1,"stats":{"Line":0}},{"line":130,"address":[2216112],"length":1,"stats":{"Line":0}},{"line":133,"address":[2216155,2216228,2218434],"length":1,"stats":{"Line":0}},{"line":135,"address":[2216280],"length":1,"stats":{"Line":0}},{"line":136,"address":[2217883],"length":1,"stats":{"Line":0}},{"line":137,"address":[2218676,2217928],"length":1,"stats":{"Line":0}},{"line":138,"address":[2218274,2218603],"length":1,"stats":{"Line":0}},{"line":141,"address":[2216234],"length":1,"stats":{"Line":0}},{"line":142,"address":[2216245,2216327],"length":1,"stats":{"Line":0}},{"line":143,"address":[2216537,2216433],"length":1,"stats":{"Line":0}},{"line":144,"address":[2216556,2217868,2217269],"length":1,"stats":{"Line":0}},{"line":145,"address":[2216625,2217347],"length":1,"stats":{"Line":0}},{"line":146,"address":[2217365,2217878],"length":1,"stats":{"Line":0}},{"line":147,"address":[2217711,2217873],"length":1,"stats":{"Line":0}},{"line":149,"address":[2216598,2216663,2217319],"length":1,"stats":{"Line":0}},{"line":150,"address":[2216829,2217292,2216765],"length":1,"stats":{"Line":0}},{"line":151,"address":[2217274,2217104],"length":1,"stats":{"Line":0}},{"line":154,"address":[2216464],"length":1,"stats":{"Line":0}},{"line":157,"address":[2216486],"length":1,"stats":{"Line":0}},{"line":160,"address":[2211568],"length":1,"stats":{"Line":0}},{"line":161,"address":[2211572],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":96},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","parser","mod.rs"],"content":"use crate::ast::*;\nuse crate::error::{Error, Result, SourceLocation};\nuse crate::lexer::{Token, TokenKind};\n\n/// AWK parser using recursive descent\npub struct Parser {\n    tokens: Vec\u003cToken\u003e,\n    current: usize,\n}\n\nimpl Parser {\n    pub fn new(tokens: Vec\u003cToken\u003e) -\u003e Self {\n        Self { tokens, current: 0 }\n    }\n\n    /// Parse a complete AWK program\n    pub fn parse(\u0026mut self) -\u003e Result\u003cProgram\u003e {\n        let mut program = Program::new();\n\n        self.skip_newlines();\n\n        while !self.is_at_end() {\n            // Check for function definition\n            if self.check(\u0026TokenKind::Function) {\n                program.functions.push(self.parse_function()?);\n            } else {\n                program.rules.push(self.parse_rule()?);\n            }\n            self.skip_newlines();\n        }\n\n        Ok(program)\n    }\n\n    /// Parse a function definition\n    fn parse_function(\u0026mut self) -\u003e Result\u003cFunctionDef\u003e {\n        let location = self.current_location();\n        self.expect(\u0026TokenKind::Function)?;\n\n        let name = self.expect_identifier()?;\n        self.expect(\u0026TokenKind::LeftParen)?;\n\n        let mut params = Vec::new();\n        if !self.check(\u0026TokenKind::RightParen) {\n            params.push(self.expect_identifier()?);\n            while self.match_token(\u0026TokenKind::Comma) {\n                params.push(self.expect_identifier()?);\n            }\n        }\n        self.expect(\u0026TokenKind::RightParen)?;\n        self.skip_newlines();\n\n        let body = self.parse_block()?;\n\n        Ok(FunctionDef {\n            name,\n            params,\n            body,\n            location,\n        })\n    }\n\n    /// Parse a pattern-action rule\n    fn parse_rule(\u0026mut self) -\u003e Result\u003cRule\u003e {\n        let location = self.current_location();\n\n        // Check for BEGIN/END/BEGINFILE/ENDFILE\n        if self.check(\u0026TokenKind::Begin) {\n            self.advance();\n            self.skip_newlines();\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: Some(Pattern::Begin),\n                action,\n                location,\n            });\n        }\n\n        if self.check(\u0026TokenKind::End) {\n            self.advance();\n            self.skip_newlines();\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: Some(Pattern::End),\n                action,\n                location,\n            });\n        }\n\n        if self.check(\u0026TokenKind::BeginFile) {\n            self.advance();\n            self.skip_newlines();\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: Some(Pattern::BeginFile),\n                action,\n                location,\n            });\n        }\n\n        if self.check(\u0026TokenKind::EndFile) {\n            self.advance();\n            self.skip_newlines();\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: Some(Pattern::EndFile),\n                action,\n                location,\n            });\n        }\n\n        // Check for action-only rule (just a block)\n        if self.check(\u0026TokenKind::LeftBrace) {\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: None,\n                action,\n                location,\n            });\n        }\n\n        // Parse pattern\n        let pattern = Some(self.parse_pattern()?);\n        self.skip_newlines();\n\n        // Optional action\n        let action = if self.check(\u0026TokenKind::LeftBrace) {\n            Some(self.parse_block()?)\n        } else {\n            None\n        };\n\n        Ok(Rule {\n            pattern,\n            action,\n            location,\n        })\n    }\n\n    /// Parse a pattern (expression or regex)\n    fn parse_pattern(\u0026mut self) -\u003e Result\u003cPattern\u003e {\n        // Check for regex pattern\n        if let Some(TokenKind::Regex(pattern)) = self.peek_kind() {\n            let pattern = pattern.clone();\n            self.advance();\n\n            // Check for range pattern\n            if self.match_token(\u0026TokenKind::Comma) {\n                self.skip_newlines();\n                let end = self.parse_pattern()?;\n                return Ok(Pattern::Range {\n                    start: Box::new(Pattern::Regex(pattern)),\n                    end: Box::new(end),\n                });\n            }\n\n            return Ok(Pattern::Regex(pattern));\n        }\n\n        // Parse as expression pattern\n        let expr = self.parse_expression()?;\n\n        // Check for range pattern\n        if self.match_token(\u0026TokenKind::Comma) {\n            self.skip_newlines();\n            let end = self.parse_pattern()?;\n            return Ok(Pattern::Range {\n                start: Box::new(Pattern::Expr(expr)),\n                end: Box::new(end),\n            });\n        }\n\n        Ok(Pattern::Expr(expr))\n    }\n\n    /// Parse a block { ... }\n    fn parse_block(\u0026mut self) -\u003e Result\u003cBlock\u003e {\n        let location = self.current_location();\n        self.expect(\u0026TokenKind::LeftBrace)?;\n        self.skip_newlines();\n\n        let mut statements = Vec::new();\n\n        while !self.check(\u0026TokenKind::RightBrace) \u0026\u0026 !self.is_at_end() {\n            statements.push(self.parse_statement()?);\n            self.skip_terminators();\n        }\n\n        self.expect(\u0026TokenKind::RightBrace)?;\n\n        Ok(Block::new(statements, location))\n    }\n\n    /// Parse a single statement\n    fn parse_statement(\u0026mut self) -\u003e Result\u003cStmt\u003e {\n        self.skip_newlines();\n\n        let location = self.current_location();\n\n        // Empty statement\n        if self.check(\u0026TokenKind::Semicolon) {\n            self.advance();\n            return Ok(Stmt::Empty);\n        }\n\n        // Block\n        if self.check(\u0026TokenKind::LeftBrace) {\n            return Ok(Stmt::Block(self.parse_block()?));\n        }\n\n        // If statement\n        if self.match_token(\u0026TokenKind::If) {\n            return self.parse_if_statement(location);\n        }\n\n        // While statement\n        if self.match_token(\u0026TokenKind::While) {\n            return self.parse_while_statement(location);\n        }\n\n        // For statement\n        if self.match_token(\u0026TokenKind::For) {\n            return self.parse_for_statement(location);\n        }\n\n        // Do-while statement\n        if self.match_token(\u0026TokenKind::Do) {\n            return self.parse_do_while_statement(location);\n        }\n\n        // Break\n        if self.match_token(\u0026TokenKind::Break) {\n            return Ok(Stmt::Break { location });\n        }\n\n        // Continue\n        if self.match_token(\u0026TokenKind::Continue) {\n            return Ok(Stmt::Continue { location });\n        }\n\n        // Next\n        if self.match_token(\u0026TokenKind::Next) {\n            return Ok(Stmt::Next { location });\n        }\n\n        // Nextfile\n        if self.match_token(\u0026TokenKind::Nextfile) {\n            return Ok(Stmt::Nextfile { location });\n        }\n\n        // Exit\n        if self.match_token(\u0026TokenKind::Exit) {\n            let code = if self.can_start_expression() {\n                Some(self.parse_expression()?)\n            } else {\n                None\n            };\n            return Ok(Stmt::Exit { code, location });\n        }\n\n        // Return\n        if self.match_token(\u0026TokenKind::Return) {\n            let value = if self.can_start_expression() {\n                Some(self.parse_expression()?)\n            } else {\n                None\n            };\n            return Ok(Stmt::Return { value, location });\n        }\n\n        // Delete\n        if self.match_token(\u0026TokenKind::Delete) {\n            let name = self.expect_identifier()?;\n\n            // Check if there's an index (delete array[i]) or not (delete array)\n            let indices = if self.match_token(\u0026TokenKind::LeftBracket) {\n                let mut indices = vec![self.parse_expression()?];\n                while self.match_token(\u0026TokenKind::Comma) {\n                    indices.push(self.parse_expression()?);\n                }\n                self.expect(\u0026TokenKind::RightBracket)?;\n                indices\n            } else {\n                // delete array (entire array)\n                Vec::new()\n            };\n\n            return Ok(Stmt::Delete {\n                array: name,\n                index: indices,\n                location,\n            });\n        }\n\n        // Print statement\n        if self.match_token(\u0026TokenKind::Print) {\n            return self.parse_print_statement(location);\n        }\n\n        // Printf statement\n        if self.match_token(\u0026TokenKind::Printf) {\n            return self.parse_printf_statement(location);\n        }\n\n        // Expression statement\n        let expr = self.parse_expression()?;\n        Ok(Stmt::Expr(expr))\n    }\n\n    fn parse_if_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        self.expect(\u0026TokenKind::LeftParen)?;\n        let condition = self.parse_expression()?;\n        self.expect(\u0026TokenKind::RightParen)?;\n        self.skip_newlines();\n\n        let then_branch = Box::new(self.parse_statement()?);\n\n        // Skip terminators (semicolons and newlines) before checking for else\n        self.skip_terminators();\n        let else_branch = if self.match_token(\u0026TokenKind::Else) {\n            self.skip_newlines();\n            Some(Box::new(self.parse_statement()?))\n        } else {\n            None\n        };\n\n        Ok(Stmt::If {\n            condition,\n            then_branch,\n            else_branch,\n            location,\n        })\n    }\n\n    fn parse_while_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        self.expect(\u0026TokenKind::LeftParen)?;\n        let condition = self.parse_expression()?;\n        self.expect(\u0026TokenKind::RightParen)?;\n        self.skip_newlines();\n\n        let body = Box::new(self.parse_statement()?);\n\n        Ok(Stmt::While {\n            condition,\n            body,\n            location,\n        })\n    }\n\n    fn parse_for_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        self.expect(\u0026TokenKind::LeftParen)?;\n\n        // Check for for-in loop: for (var in array)\n        if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n            let name = name.clone();\n            let saved_pos = self.current;\n            self.advance();\n\n            if self.match_token(\u0026TokenKind::In) {\n                let array = self.expect_identifier()?;\n                self.expect(\u0026TokenKind::RightParen)?;\n                self.skip_newlines();\n                let body = Box::new(self.parse_statement()?);\n\n                return Ok(Stmt::ForIn {\n                    var: name,\n                    array,\n                    body,\n                    location,\n                });\n            }\n\n            // Not a for-in, backtrack\n            self.current = saved_pos;\n        }\n\n        // C-style for loop\n        let init = if !self.check(\u0026TokenKind::Semicolon) {\n            Some(Box::new(self.parse_statement()?))\n        } else {\n            None\n        };\n        self.expect(\u0026TokenKind::Semicolon)?;\n\n        let condition = if !self.check(\u0026TokenKind::Semicolon) {\n            Some(self.parse_expression()?)\n        } else {\n            None\n        };\n        self.expect(\u0026TokenKind::Semicolon)?;\n\n        let update = if !self.check(\u0026TokenKind::RightParen) {\n            Some(self.parse_expression()?)\n        } else {\n            None\n        };\n        self.expect(\u0026TokenKind::RightParen)?;\n        self.skip_newlines();\n\n        let body = Box::new(self.parse_statement()?);\n\n        Ok(Stmt::For {\n            init,\n            condition,\n            update,\n            body,\n            location,\n        })\n    }\n\n    fn parse_do_while_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        self.skip_newlines();\n        let body = Box::new(self.parse_statement()?);\n        self.skip_newlines();\n        self.expect(\u0026TokenKind::While)?;\n        self.expect(\u0026TokenKind::LeftParen)?;\n        let condition = self.parse_expression()?;\n        self.expect(\u0026TokenKind::RightParen)?;\n\n        Ok(Stmt::DoWhile {\n            body,\n            condition,\n            location,\n        })\n    }\n\n    fn parse_print_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        let mut args = Vec::new();\n\n        // Check for arguments (print without args prints $0)\n        if self.can_start_expression() \u0026\u0026 !self.check(\u0026TokenKind::Greater) \u0026\u0026 !self.check(\u0026TokenKind::Append) \u0026\u0026 !self.check(\u0026TokenKind::Pipe) {\n            args.push(self.parse_print_arg()?);\n            while self.match_token(\u0026TokenKind::Comma) {\n                args.push(self.parse_print_arg()?);\n            }\n        }\n\n        // Check for output redirection\n        let output = self.parse_output_redirect()?;\n\n        Ok(Stmt::Print {\n            args,\n            output,\n            location,\n        })\n    }\n\n    fn parse_printf_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        let format = self.parse_print_arg()?;\n        let mut args = Vec::new();\n\n        while self.match_token(\u0026TokenKind::Comma) {\n            args.push(self.parse_print_arg()?);\n        }\n\n        let output = self.parse_output_redirect()?;\n\n        Ok(Stmt::Printf {\n            format,\n            args,\n            output,\n            location,\n        })\n    }\n\n    fn parse_print_arg(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        // Print arguments don't include comparison operators with \u003e at the top level\n        // because \u003e is used for output redirection. We parse up to concatenation level.\n        self.parse_print_ternary()\n    }\n\n    fn parse_print_ternary(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_print_or()?;\n\n        if self.match_token(\u0026TokenKind::Question) {\n            let location = self.current_location();\n            let then_expr = self.parse_print_ternary()?;\n            self.expect(\u0026TokenKind::Colon)?;\n            let else_expr = self.parse_print_ternary()?;\n            return Ok(Expr::Ternary {\n                condition: Box::new(expr),\n                then_expr: Box::new(then_expr),\n                else_expr: Box::new(else_expr),\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_or(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_print_and()?;\n\n        while self.match_token(\u0026TokenKind::Or) {\n            let location = self.current_location();\n            let right = self.parse_print_and()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::Or,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_and(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_print_in()?;\n\n        while self.match_token(\u0026TokenKind::And) {\n            let location = self.current_location();\n            let right = self.parse_print_in()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::And,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_in(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_print_match()?;\n\n        if self.match_token(\u0026TokenKind::In) {\n            let location = self.current_location();\n            let array = self.expect_identifier()?;\n            return Ok(Expr::InArray {\n                key: vec![expr],\n                array,\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_match(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_print_comparison()?;\n\n        let location = self.current_location();\n        if self.match_token(\u0026TokenKind::Match) {\n            let pattern = self.parse_print_comparison()?;\n            return Ok(Expr::Match {\n                expr: Box::new(expr),\n                pattern: Box::new(pattern),\n                negated: false,\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::NotMatch) {\n            let pattern = self.parse_print_comparison()?;\n            return Ok(Expr::Match {\n                expr: Box::new(expr),\n                pattern: Box::new(pattern),\n                negated: true,\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_comparison(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_concat()?;\n\n        // For print args, we DON'T consume \u003e or \u003e\u003e because they're used for output redirection\n        // But we DO handle \u003e=, \u003c, \u003c=, ==, !=\n        loop {\n            let location = self.current_location();\n            let op = if self.match_token(\u0026TokenKind::Less) {\n                BinaryOp::Lt\n            } else if self.match_token(\u0026TokenKind::LessEqual) {\n                BinaryOp::Le\n            } else if self.match_token(\u0026TokenKind::GreaterEqual) {\n                BinaryOp::Ge\n            } else if self.match_token(\u0026TokenKind::Equal) {\n                BinaryOp::Eq\n            } else if self.match_token(\u0026TokenKind::NotEqual) {\n                BinaryOp::Ne\n            } else {\n                // Don't consume \u003e or \u003e\u003e for print arguments (used for output redirection)\n                break;\n            };\n\n            let right = self.parse_concat()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_output_redirect(\u0026mut self) -\u003e Result\u003cOption\u003cOutputRedirect\u003e\u003e {\n        if self.match_token(\u0026TokenKind::Greater) {\n            let target = self.parse_print_arg()?;\n            Ok(Some(OutputRedirect::Truncate(target)))\n        } else if self.match_token(\u0026TokenKind::Append) {\n            let target = self.parse_print_arg()?;\n            Ok(Some(OutputRedirect::Append(target)))\n        } else if self.match_token(\u0026TokenKind::Pipe) {\n            let target = self.parse_print_arg()?;\n            Ok(Some(OutputRedirect::Pipe(target)))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse an expression\n    fn parse_expression(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        self.parse_assignment()\n    }\n\n    fn parse_assignment(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_ternary()?;\n\n        // Check for assignment operators\n        let location = self.current_location();\n        let op = if self.match_token(\u0026TokenKind::Assign) {\n            Some(AssignOp::Assign)\n        } else if self.match_token(\u0026TokenKind::PlusAssign) {\n            Some(AssignOp::AddAssign)\n        } else if self.match_token(\u0026TokenKind::MinusAssign) {\n            Some(AssignOp::SubAssign)\n        } else if self.match_token(\u0026TokenKind::StarAssign) {\n            Some(AssignOp::MulAssign)\n        } else if self.match_token(\u0026TokenKind::SlashAssign) {\n            Some(AssignOp::DivAssign)\n        } else if self.match_token(\u0026TokenKind::PercentAssign) {\n            Some(AssignOp::ModAssign)\n        } else if self.match_token(\u0026TokenKind::CaretAssign) {\n            Some(AssignOp::PowAssign)\n        } else {\n            None\n        };\n\n        if let Some(op) = op {\n            let value = self.parse_assignment()?;\n            return Ok(Expr::Assign {\n                target: Box::new(expr),\n                op,\n                value: Box::new(value),\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_ternary(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_or()?;\n\n        if self.match_token(\u0026TokenKind::Question) {\n            let location = self.current_location();\n            let then_expr = self.parse_expression()?;\n            self.expect(\u0026TokenKind::Colon)?;\n            let else_expr = self.parse_ternary()?;\n            return Ok(Expr::Ternary {\n                condition: Box::new(expr),\n                then_expr: Box::new(then_expr),\n                else_expr: Box::new(else_expr),\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_or(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_and()?;\n\n        while self.match_token(\u0026TokenKind::Or) {\n            let location = self.current_location();\n            let right = self.parse_and()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::Or,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_and(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_in()?;\n\n        while self.match_token(\u0026TokenKind::And) {\n            let location = self.current_location();\n            let right = self.parse_in()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::And,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_in(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_pipe_getline()?;\n\n        // Check for \"in\" (array membership)\n        // Format: (expr) in array or expr in array\n        if self.match_token(\u0026TokenKind::In) {\n            let location = self.current_location();\n            let array = self.expect_identifier()?;\n            return Ok(Expr::InArray {\n                key: vec![expr],\n                array,\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    /// Handle `cmd | getline [var]` syntax\n    fn parse_pipe_getline(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_match()?;\n\n        // Check for pipe to getline: expr | getline [var]\n        if self.check(\u0026TokenKind::Pipe) {\n            // Look ahead to see if getline follows\n            let saved_pos = self.current;\n            self.advance(); // consume |\n\n            if self.check(\u0026TokenKind::Getline) {\n                let location = self.current_location();\n                self.advance(); // consume getline\n\n                // Optional variable name\n                let var = if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n                    let name = name.clone();\n                    self.advance();\n                    Some(name)\n                } else {\n                    None\n                };\n\n                return Ok(Expr::Getline {\n                    var,\n                    input: Some(GetlineInput::Pipe(Box::new(expr))),\n                    location,\n                });\n            } else {\n                // Not getline, backtrack\n                self.current = saved_pos;\n            }\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_match(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_comparison()?;\n\n        let location = self.current_location();\n        if self.match_token(\u0026TokenKind::Match) {\n            let pattern = self.parse_comparison()?;\n            return Ok(Expr::Match {\n                expr: Box::new(expr),\n                pattern: Box::new(pattern),\n                negated: false,\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::NotMatch) {\n            let pattern = self.parse_comparison()?;\n            return Ok(Expr::Match {\n                expr: Box::new(expr),\n                pattern: Box::new(pattern),\n                negated: true,\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_comparison(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_concat()?;\n\n        loop {\n            let location = self.current_location();\n            let op = if self.match_token(\u0026TokenKind::Less) {\n                BinaryOp::Lt\n            } else if self.match_token(\u0026TokenKind::LessEqual) {\n                BinaryOp::Le\n            } else if self.match_token(\u0026TokenKind::Greater) {\n                BinaryOp::Gt\n            } else if self.match_token(\u0026TokenKind::GreaterEqual) {\n                BinaryOp::Ge\n            } else if self.match_token(\u0026TokenKind::Equal) {\n                BinaryOp::Eq\n            } else if self.match_token(\u0026TokenKind::NotEqual) {\n                BinaryOp::Ne\n            } else {\n                break;\n            };\n\n            let right = self.parse_concat()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_concat(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_additive()?;\n\n        // Concatenation is implicit between adjacent expressions\n        // But we need to be careful about operators that could follow\n        while self.can_start_concat_operand() {\n            let right = self.parse_additive()?;\n            let location = expr.location();\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::Concat,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn can_start_concat_operand(\u0026mut self) -\u003e bool {\n        if let Some(kind) = self.peek_kind() {\n            matches!(\n                kind,\n                TokenKind::Number(_)\n                    | TokenKind::String(_)\n                    | TokenKind::Identifier(_)\n                    | TokenKind::Dollar\n                    | TokenKind::LeftParen\n                    | TokenKind::Not\n                    | TokenKind::Increment\n                    | TokenKind::Decrement\n            )\n        } else {\n            false\n        }\n    }\n\n    fn parse_additive(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_multiplicative()?;\n\n        loop {\n            let location = self.current_location();\n            let op = if self.match_token(\u0026TokenKind::Plus) {\n                BinaryOp::Add\n            } else if self.match_token(\u0026TokenKind::Minus) {\n                BinaryOp::Sub\n            } else {\n                break;\n            };\n\n            let right = self.parse_multiplicative()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_multiplicative(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_power()?;\n\n        loop {\n            let location = self.current_location();\n            let op = if self.match_token(\u0026TokenKind::Star) {\n                BinaryOp::Mul\n            } else if self.match_token(\u0026TokenKind::Slash) {\n                BinaryOp::Div\n            } else if self.match_token(\u0026TokenKind::Percent) {\n                BinaryOp::Mod\n            } else {\n                break;\n            };\n\n            let right = self.parse_power()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_power(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_unary()?;\n\n        // Exponentiation is right-associative\n        if self.match_token(\u0026TokenKind::Caret) {\n            let location = self.current_location();\n            let right = self.parse_power()?;\n            return Ok(Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::Pow,\n                right: Box::new(right),\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_unary(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let location = self.current_location();\n\n        if self.match_token(\u0026TokenKind::Not) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary {\n                op: UnaryOp::Not,\n                operand: Box::new(operand),\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::Minus) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary {\n                op: UnaryOp::Neg,\n                operand: Box::new(operand),\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::Plus) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary {\n                op: UnaryOp::Pos,\n                operand: Box::new(operand),\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::Increment) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::PreIncrement(Box::new(operand), location));\n        }\n\n        if self.match_token(\u0026TokenKind::Decrement) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::PreDecrement(Box::new(operand), location));\n        }\n\n        self.parse_postfix()\n    }\n\n    fn parse_postfix(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_field()?;\n\n        loop {\n            let location = self.current_location();\n\n            if self.match_token(\u0026TokenKind::Increment) {\n                expr = Expr::PostIncrement(Box::new(expr), location);\n            } else if self.match_token(\u0026TokenKind::Decrement) {\n                expr = Expr::PostDecrement(Box::new(expr), location);\n            } else if self.match_token(\u0026TokenKind::LeftBracket) {\n                // Array access\n                if let Expr::Var(name, _) = expr {\n                    let mut indices = vec![self.parse_expression()?];\n                    while self.match_token(\u0026TokenKind::Comma) {\n                        indices.push(self.parse_expression()?);\n                    }\n                    self.expect(\u0026TokenKind::RightBracket)?;\n                    expr = Expr::ArrayAccess {\n                        array: name,\n                        indices,\n                        location,\n                    };\n                } else {\n                    return Err(Error::parser(\"array access requires variable name\", location.line, location.column));\n                }\n            } else {\n                break;\n            }\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_field(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        if self.match_token(\u0026TokenKind::Dollar) {\n            let location = self.current_location();\n            let expr = self.parse_field()?;\n            return Ok(Expr::Field(Box::new(expr), location));\n        }\n\n        self.parse_primary()\n    }\n\n    fn parse_primary(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let location = self.current_location();\n\n        // Number literal\n        if let Some(TokenKind::Number(n)) = self.peek_kind() {\n            let n = *n;\n            self.advance();\n            return Ok(Expr::Number(n, location));\n        }\n\n        // String literal\n        if let Some(TokenKind::String(s)) = self.peek_kind() {\n            let s = s.clone();\n            self.advance();\n            return Ok(Expr::String(s, location));\n        }\n\n        // Regex literal\n        if let Some(TokenKind::Regex(r)) = self.peek_kind() {\n            let r = r.clone();\n            self.advance();\n            return Ok(Expr::Regex(r, location));\n        }\n\n        // Identifier (variable or function call)\n        if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n            let name = name.clone();\n            self.advance();\n\n            // Check for function call\n            if self.match_token(\u0026TokenKind::LeftParen) {\n                let mut args = Vec::new();\n                if !self.check(\u0026TokenKind::RightParen) {\n                    args.push(self.parse_expression()?);\n                    while self.match_token(\u0026TokenKind::Comma) {\n                        args.push(self.parse_expression()?);\n                    }\n                }\n                self.expect(\u0026TokenKind::RightParen)?;\n                return Ok(Expr::Call {\n                    name,\n                    args,\n                    location,\n                });\n            }\n\n            return Ok(Expr::Var(name, location));\n        }\n\n        // Getline\n        if self.match_token(\u0026TokenKind::Getline) {\n            let var = if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n                let name = name.clone();\n                self.advance();\n                Some(name)\n            } else {\n                None\n            };\n\n            let input = if self.match_token(\u0026TokenKind::Less) {\n                Some(GetlineInput::File(Box::new(self.parse_primary()?)))\n            } else {\n                None\n            };\n\n            return Ok(Expr::Getline {\n                var,\n                input,\n                location,\n            });\n        }\n\n        // Parenthesized expression\n        if self.match_token(\u0026TokenKind::LeftParen) {\n            let expr = self.parse_expression()?;\n            self.expect(\u0026TokenKind::RightParen)?;\n            return Ok(Expr::Group(Box::new(expr), location));\n        }\n\n        Err(Error::parser(\n            format!(\"unexpected token {:?}\", self.peek_kind()),\n            location.line,\n            location.column,\n        ))\n    }\n\n    // ===== Helper methods =====\n\n    fn peek_kind(\u0026self) -\u003e Option\u003c\u0026TokenKind\u003e {\n        self.tokens.get(self.current).map(|t| \u0026t.kind)\n    }\n\n    fn current_location(\u0026self) -\u003e SourceLocation {\n        self.tokens\n            .get(self.current)\n            .map(|t| t.location)\n            .unwrap_or(SourceLocation::new(0, 0))\n    }\n\n    fn is_at_end(\u0026self) -\u003e bool {\n        matches!(self.peek_kind(), None | Some(TokenKind::Eof))\n    }\n\n    fn check(\u0026self, kind: \u0026TokenKind) -\u003e bool {\n        self.peek_kind().map(|k| std::mem::discriminant(k) == std::mem::discriminant(kind)).unwrap_or(false)\n    }\n\n    fn advance(\u0026mut self) -\u003e Option\u003c\u0026Token\u003e {\n        if !self.is_at_end() {\n            self.current += 1;\n        }\n        self.tokens.get(self.current - 1)\n    }\n\n    fn match_token(\u0026mut self, kind: \u0026TokenKind) -\u003e bool {\n        if self.check(kind) {\n            self.advance();\n            true\n        } else {\n            false\n        }\n    }\n\n    fn expect(\u0026mut self, kind: \u0026TokenKind) -\u003e Result\u003c\u0026Token\u003e {\n        if self.check(kind) {\n            Ok(self.advance().unwrap())\n        } else {\n            let loc = self.current_location();\n            Err(Error::parser(\n                format!(\"expected {:?}, found {:?}\", kind, self.peek_kind()),\n                loc.line,\n                loc.column,\n            ))\n        }\n    }\n\n    fn expect_identifier(\u0026mut self) -\u003e Result\u003cString\u003e {\n        if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n            let name = name.clone();\n            self.advance();\n            Ok(name)\n        } else {\n            let loc = self.current_location();\n            Err(Error::parser(\n                format!(\"expected identifier, found {:?}\", self.peek_kind()),\n                loc.line,\n                loc.column,\n            ))\n        }\n    }\n\n    fn skip_newlines(\u0026mut self) {\n        while self.match_token(\u0026TokenKind::Newline) {}\n    }\n\n    fn skip_terminators(\u0026mut self) {\n        while self.match_token(\u0026TokenKind::Newline) || self.match_token(\u0026TokenKind::Semicolon) {}\n    }\n\n    fn can_start_expression(\u0026self) -\u003e bool {\n        self.peek_kind().map(|k| k.can_start_expression()).unwrap_or(false)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::lexer::Lexer;\n\n    fn parse(source: \u0026str) -\u003e Result\u003cProgram\u003e {\n        let mut lexer = Lexer::new(source);\n        let tokens = lexer.tokenize()?;\n        let mut parser = Parser::new(tokens);\n        parser.parse()\n    }\n\n    #[test]\n    fn test_simple_print() {\n        let program = parse(r#\"{ print \"hello\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_begin_end() {\n        let program = parse(r#\"BEGIN { x = 1 } END { print x }\"#).unwrap();\n        assert_eq!(program.rules.len(), 2);\n        assert!(matches!(program.rules[0].pattern, Some(Pattern::Begin)));\n        assert!(matches!(program.rules[1].pattern, Some(Pattern::End)));\n    }\n\n    #[test]\n    fn test_regex_pattern() {\n        let program = parse(r#\"/foo/ { print }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n        assert!(matches!(\n            \u0026program.rules[0].pattern,\n            Some(Pattern::Regex(r)) if r == \"foo\"\n        ));\n    }\n\n    #[test]\n    fn test_arithmetic() {\n        let program = parse(r#\"{ x = 1 + 2 * 3 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_function_def() {\n        let program = parse(r#\"function add(a, b) { return a + b }\"#).unwrap();\n        assert_eq!(program.functions.len(), 1);\n        assert_eq!(program.functions[0].name, \"add\");\n        assert_eq!(program.functions[0].params, vec![\"a\", \"b\"]);\n    }\n\n    #[test]\n    fn test_if_else() {\n        let program = parse(r#\"{ if (x) print 1; else print 2 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_while_loop() {\n        let program = parse(r#\"{ while (x \u003c 10) x++ }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_for_loop() {\n        let program = parse(r#\"{ for (i=0; i\u003c10; i++) print i }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_for_in_loop() {\n        let program = parse(r#\"{ for (k in a) print k }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_do_while() {\n        let program = parse(r#\"{ do { x++ } while (x \u003c 10) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_delete() {\n        let program = parse(r#\"{ delete a[1] }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_delete_array() {\n        let program = parse(r#\"{ delete a }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_break_continue() {\n        let program = parse(r#\"{ break; continue }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_next_nextfile() {\n        let program = parse(r#\"{ next } { nextfile }\"#).unwrap();\n        assert_eq!(program.rules.len(), 2);\n    }\n\n    #[test]\n    fn test_exit() {\n        let program = parse(r#\"{ exit 0 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_return() {\n        let program = parse(r#\"function f() { return 42 }\"#).unwrap();\n        assert_eq!(program.functions.len(), 1);\n    }\n\n    #[test]\n    fn test_printf() {\n        let program = parse(r#\"{ printf \"%d\", x }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_getline() {\n        let program = parse(r#\"{ getline x \u003c \"file\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_pipe_getline() {\n        let program = parse(r#\"{ \"cmd\" | getline x }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_output_redirect() {\n        let program = parse(r#\"{ print \"x\" \u003e \"file\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_output_append() {\n        let program = parse(r#\"{ print \"x\" \u003e\u003e \"file\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_output_pipe() {\n        let program = parse(r#\"{ print \"x\" | \"cmd\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_ternary() {\n        let program = parse(r#\"{ x = a ? b : c }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_logical_and_or() {\n        let program = parse(r#\"{ x = a \u0026\u0026 b || c }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_array_in() {\n        let program = parse(r#\"{ x = (1 in a) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_regex_match() {\n        let program = parse(r#\"{ x = ($0 ~ /foo/) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_concatenation() {\n        let program = parse(r#\"{ x = a b c }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_field_access() {\n        let program = parse(r#\"{ print $1, $NF, $(2+1) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_array_multi_index() {\n        let program = parse(r#\"{ a[1,2,3] = x }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_function_call() {\n        let program = parse(r#\"{ x = substr(s, 1, 5) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_pre_increment() {\n        let program = parse(r#\"{ ++x; --y }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_post_increment() {\n        let program = parse(r#\"{ x++; y-- }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_compound_assign() {\n        let program = parse(r#\"{ x += 1; y -= 1; z *= 2; w /= 2; v %= 3; p ^= 2 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_range_pattern() {\n        let program = parse(r#\"/start/,/end/ { print }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n        assert!(matches!(\u0026program.rules[0].pattern, Some(Pattern::Range { .. })));\n    }\n\n    #[test]\n    fn test_expression_pattern() {\n        let program = parse(r#\"NR \u003e 5 { print }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_beginfile_endfile() {\n        let program = parse(r#\"BEGINFILE { x = 1 } ENDFILE { print }\"#).unwrap();\n        assert_eq!(program.rules.len(), 2);\n        assert!(matches!(program.rules[0].pattern, Some(Pattern::BeginFile)));\n        assert!(matches!(program.rules[1].pattern, Some(Pattern::EndFile)));\n    }\n\n    #[test]\n    fn test_empty_statement() {\n        let program = parse(r#\"{ ; ; ; }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_block_statement() {\n        let program = parse(r#\"{ { { x = 1 } } }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_multiple_rules() {\n        let program = parse(r#\"BEGIN { } { } END { }\"#).unwrap();\n        assert_eq!(program.rules.len(), 3);\n    }\n\n    #[test]\n    fn test_parenthesized_expression() {\n        let program = parse(r#\"{ x = (1 + 2) * 3 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_unary_ops() {\n        let program = parse(r#\"{ x = -a + +b }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_not_operator() {\n        let program = parse(r#\"{ x = !a }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_comparison_ops() {\n        let program = parse(r#\"{ x = a \u003c b \u0026\u0026 b \u003c= c \u0026\u0026 c \u003e d \u0026\u0026 d \u003e= e \u0026\u0026 e == f \u0026\u0026 f != g }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_exponentiation() {\n        let program = parse(r#\"{ x = 2^3^4 }\"#).unwrap();  // right associative\n        assert_eq!(program.rules.len(), 1);\n    }\n}\n","traces":[{"line":12,"address":[2475520],"length":1,"stats":{"Line":14}},{"line":17,"address":[2475632,2476502,2476508],"length":1,"stats":{"Line":7}},{"line":18,"address":[2966750],"length":1,"stats":{"Line":39}},{"line":20,"address":[2475677,2475721],"length":1,"stats":{"Line":78}},{"line":22,"address":[2966824],"length":1,"stats":{"Line":65}},{"line":24,"address":[3276610,3276699],"length":1,"stats":{"Line":94}},{"line":25,"address":[2475874,2476484,2476235],"length":1,"stats":{"Line":6}},{"line":27,"address":[2967313,2966998,2966958],"length":1,"stats":{"Line":32}},{"line":29,"address":[3277063,3277360],"length":1,"stats":{"Line":9}},{"line":32,"address":[3276628],"length":1,"stats":{"Line":5}},{"line":36,"address":[3244874,3244882,3242976],"length":1,"stats":{"Line":3}},{"line":37,"address":[3243014],"length":1,"stats":{"Line":3}},{"line":38,"address":[2922026],"length":1,"stats":{"Line":3}},{"line":40,"address":[3243180],"length":1,"stats":{"Line":3}},{"line":41,"address":[2443253,2443335,2444724],"length":1,"stats":{"Line":6}},{"line":43,"address":[2443464],"length":1,"stats":{"Line":3}},{"line":44,"address":[2922588,2922654],"length":1,"stats":{"Line":8}},{"line":45,"address":[2934450,2933937,2933974],"length":1,"stats":{"Line":8}},{"line":46,"address":[2922913],"length":1,"stats":{"Line":4}},{"line":47,"address":[2443849],"length":1,"stats":{"Line":2}},{"line":50,"address":[2934452,2935093,2933949],"length":1,"stats":{"Line":8}},{"line":51,"address":[2923346],"length":1,"stats":{"Line":4}},{"line":53,"address":[2935088,2934630],"length":1,"stats":{"Line":4}},{"line":55,"address":[2934900],"length":1,"stats":{"Line":3}},{"line":56,"address":[2923540],"length":1,"stats":{"Line":3}},{"line":57,"address":[2444456],"length":1,"stats":{"Line":3}},{"line":64,"address":[2907280,2908736,2908742],"length":1,"stats":{"Line":64}},{"line":65,"address":[2417510],"length":1,"stats":{"Line":29}},{"line":68,"address":[2896090],"length":1,"stats":{"Line":29}},{"line":69,"address":[3217158],"length":1,"stats":{"Line":53}},{"line":70,"address":[3217168],"length":1,"stats":{"Line":30}},{"line":71,"address":[2907418,2909754],"length":1,"stats":{"Line":44}},{"line":72,"address":[3219652],"length":1,"stats":{"Line":5}},{"line":73,"address":[2898594],"length":1,"stats":{"Line":3}},{"line":79,"address":[3217135],"length":1,"stats":{"Line":11}},{"line":80,"address":[2907512],"length":1,"stats":{"Line":3}},{"line":81,"address":[2907522],"length":1,"stats":{"Line":4}},{"line":82,"address":[2419666,2417723],"length":1,"stats":{"Line":4}},{"line":83,"address":[2909644],"length":1,"stats":{"Line":4}},{"line":84,"address":[2898346],"length":1,"stats":{"Line":4}},{"line":90,"address":[2896225],"length":1,"stats":{"Line":12}},{"line":91,"address":[3217392],"length":1,"stats":{"Line":3}},{"line":92,"address":[3217402],"length":1,"stats":{"Line":3}},{"line":93,"address":[3219000,3217412],"length":1,"stats":{"Line":3}},{"line":94,"address":[2909387],"length":1,"stats":{"Line":3}},{"line":95,"address":[3219113],"length":1,"stats":{"Line":3}},{"line":101,"address":[2907609],"length":1,"stats":{"Line":9}},{"line":102,"address":[2896492],"length":1,"stats":{"Line":2}},{"line":103,"address":[2417955],"length":1,"stats":{"Line":2}},{"line":104,"address":[3218743,3217536],"length":1,"stats":{"Line":2}},{"line":105,"address":[2897866],"length":1,"stats":{"Line":2}},{"line":106,"address":[2419266],"length":1,"stats":{"Line":2}},{"line":113,"address":[2417918],"length":1,"stats":{"Line":10}},{"line":114,"address":[2418927,2418112],"length":1,"stats":{"Line":6}},{"line":115,"address":[2908873],"length":1,"stats":{"Line":4}},{"line":116,"address":[2908865],"length":1,"stats":{"Line":4}},{"line":123,"address":[2907997,2907853],"length":1,"stats":{"Line":4}},{"line":124,"address":[2908223],"length":1,"stats":{"Line":4}},{"line":127,"address":[2908702,2908325,2908279],"length":1,"stats":{"Line":9}},{"line":128,"address":[2908340,2908512],"length":1,"stats":{"Line":7}},{"line":130,"address":[2418488],"length":1,"stats":{"Line":1}},{"line":133,"address":[3218162],"length":1,"stats":{"Line":4}},{"line":134,"address":[2897086],"length":1,"stats":{"Line":3}},{"line":135,"address":[3218136],"length":1,"stats":{"Line":3}},{"line":141,"address":[2908384,2909566,2909629],"length":1,"stats":{"Line":7}},{"line":143,"address":[3229603,3229446],"length":1,"stats":{"Line":9}},{"line":144,"address":[2429827],"length":1,"stats":{"Line":3}},{"line":145,"address":[3229647],"length":1,"stats":{"Line":6}},{"line":148,"address":[3229700],"length":1,"stats":{"Line":4}},{"line":149,"address":[2920105],"length":1,"stats":{"Line":3}},{"line":150,"address":[2430798,2430111],"length":1,"stats":{"Line":3}},{"line":151,"address":[3230527],"length":1,"stats":{"Line":3}},{"line":152,"address":[2909332,2909188],"length":1,"stats":{"Line":6}},{"line":153,"address":[2430559],"length":1,"stats":{"Line":3}},{"line":157,"address":[2908713],"length":1,"stats":{"Line":5}},{"line":161,"address":[3230682,3229532],"length":1,"stats":{"Line":4}},{"line":164,"address":[3230916,3230979],"length":1,"stats":{"Line":8}},{"line":165,"address":[3231086],"length":1,"stats":{"Line":0}},{"line":166,"address":[2922161,2921346],"length":1,"stats":{"Line":0}},{"line":167,"address":[2922069],"length":1,"stats":{"Line":0}},{"line":168,"address":[2431591,2431825],"length":1,"stats":{"Line":0}},{"line":169,"address":[2921903],"length":1,"stats":{"Line":0}},{"line":173,"address":[2909961],"length":1,"stats":{"Line":4}},{"line":177,"address":[2421133,2421161,2420240],"length":1,"stats":{"Line":6}},{"line":178,"address":[2898838],"length":1,"stats":{"Line":29}},{"line":179,"address":[2898882],"length":1,"stats":{"Line":6}},{"line":180,"address":[3220036],"length":1,"stats":{"Line":11}},{"line":182,"address":[2899017],"length":1,"stats":{"Line":55}},{"line":184,"address":[2910427,2910308,2910371],"length":1,"stats":{"Line":102}},{"line":185,"address":[2910661,2910446],"length":1,"stats":{"Line":70}},{"line":186,"address":[2899385],"length":1,"stats":{"Line":4}},{"line":189,"address":[2910690,2910980,2910398],"length":1,"stats":{"Line":9}},{"line":191,"address":[3220613],"length":1,"stats":{"Line":5}},{"line":195,"address":[2942054,2939024,2941944],"length":1,"stats":{"Line":16}},{"line":196,"address":[3248837],"length":1,"stats":{"Line":72}},{"line":198,"address":[2448663],"length":1,"stats":{"Line":17}},{"line":201,"address":[2939131],"length":1,"stats":{"Line":72}},{"line":202,"address":[2939175],"length":1,"stats":{"Line":2}},{"line":203,"address":[2448753],"length":1,"stats":{"Line":2}},{"line":207,"address":[2939152],"length":1,"stats":{"Line":17}},{"line":208,"address":[2448810,2452214],"length":1,"stats":{"Line":4}},{"line":212,"address":[2939219],"length":1,"stats":{"Line":72}},{"line":213,"address":[2928093],"length":1,"stats":{"Line":4}},{"line":217,"address":[2448886],"length":1,"stats":{"Line":17}},{"line":218,"address":[2448977],"length":1,"stats":{"Line":3}},{"line":222,"address":[3249132],"length":1,"stats":{"Line":72}},{"line":223,"address":[2939463],"length":1,"stats":{"Line":9}},{"line":227,"address":[2448992],"length":1,"stats":{"Line":17}},{"line":228,"address":[2939516],"length":1,"stats":{"Line":2}},{"line":232,"address":[2449045],"length":1,"stats":{"Line":63}},{"line":233,"address":[2928300],"length":1,"stats":{"Line":3}},{"line":237,"address":[3249291],"length":1,"stats":{"Line":17}},{"line":238,"address":[2449220],"length":1,"stats":{"Line":3}},{"line":242,"address":[3249380],"length":1,"stats":{"Line":63}},{"line":243,"address":[2928478],"length":1,"stats":{"Line":3}},{"line":247,"address":[2939709],"length":1,"stats":{"Line":17}},{"line":248,"address":[3249591],"length":1,"stats":{"Line":2}},{"line":252,"address":[2928534],"length":1,"stats":{"Line":63}},{"line":253,"address":[2939910,2942397,2942706],"length":1,"stats":{"Line":5}},{"line":254,"address":[3252353,3252164],"length":1,"stats":{"Line":2}},{"line":256,"address":[2451894],"length":1,"stats":{"Line":1}},{"line":258,"address":[2931207],"length":1,"stats":{"Line":2}},{"line":262,"address":[2449454],"length":1,"stats":{"Line":17}},{"line":263,"address":[3249716,3252144,3251835],"length":1,"stats":{"Line":12}},{"line":264,"address":[3252031,3251842],"length":1,"stats":{"Line":8}},{"line":266,"address":[2930803],"length":1,"stats":{"Line":1}},{"line":268,"address":[2930885],"length":1,"stats":{"Line":3}},{"line":272,"address":[2928669],"length":1,"stats":{"Line":63}},{"line":273,"address":[2928738,2929124],"length":1,"stats":{"Line":2}},{"line":276,"address":[2929324,2930385,2929258],"length":1,"stats":{"Line":6}},{"line":277,"address":[2940916,2941950,2940623,2942044],"length":1,"stats":{"Line":4}},{"line":278,"address":[2450872,2450934],"length":1,"stats":{"Line":4}},{"line":279,"address":[2930430,2930177],"length":1,"stats":{"Line":0}},{"line":281,"address":[2930142,2930187,2930409],"length":1,"stats":{"Line":4}},{"line":282,"address":[3251361],"length":1,"stats":{"Line":2}},{"line":285,"address":[3250398,3250354],"length":1,"stats":{"Line":6}},{"line":288,"address":[2940759],"length":1,"stats":{"Line":2}},{"line":289,"address":[3250415],"length":1,"stats":{"Line":2}},{"line":290,"address":[2929447],"length":1,"stats":{"Line":2}},{"line":296,"address":[2939979],"length":1,"stats":{"Line":17}},{"line":297,"address":[2940117],"length":1,"stats":{"Line":27}},{"line":301,"address":[2928815],"length":1,"stats":{"Line":36}},{"line":302,"address":[2449781],"length":1,"stats":{"Line":3}},{"line":306,"address":[2940226,2940132],"length":1,"stats":{"Line":27}},{"line":307,"address":[2929046],"length":1,"stats":{"Line":7}},{"line":310,"address":[2949120,2950633,2950623],"length":1,"stats":{"Line":4}},{"line":311,"address":[2949176],"length":1,"stats":{"Line":5}},{"line":312,"address":[3259072],"length":1,"stats":{"Line":5}},{"line":313,"address":[2938336,2939367,2938402],"length":1,"stats":{"Line":10}},{"line":314,"address":[2459184],"length":1,"stats":{"Line":5}},{"line":316,"address":[3259604,3260389],"length":1,"stats":{"Line":5}},{"line":319,"address":[2950062],"length":1,"stats":{"Line":4}},{"line":320,"address":[2459902,2459502,2459462],"length":1,"stats":{"Line":12}},{"line":321,"address":[2938901],"length":1,"stats":{"Line":4}},{"line":322,"address":[3260122],"length":1,"stats":{"Line":3}},{"line":324,"address":[2950146],"length":1,"stats":{"Line":4}},{"line":327,"address":[2938963],"length":1,"stats":{"Line":5}},{"line":328,"address":[2950175],"length":1,"stats":{"Line":4}},{"line":329,"address":[2459545],"length":1,"stats":{"Line":5}},{"line":330,"address":[2938950],"length":1,"stats":{"Line":5}},{"line":335,"address":[3272054,3272060,3270960],"length":1,"stats":{"Line":3}},{"line":336,"address":[2961256],"length":1,"stats":{"Line":3}},{"line":337,"address":[2470440],"length":1,"stats":{"Line":3}},{"line":338,"address":[2470726,2470804,2471319],"length":1,"stats":{"Line":6}},{"line":339,"address":[2961898],"length":1,"stats":{"Line":3}},{"line":341,"address":[2961918,2962274],"length":1,"stats":{"Line":3}},{"line":343,"address":[2950893],"length":1,"stats":{"Line":3}},{"line":344,"address":[2962131],"length":1,"stats":{"Line":3}},{"line":350,"address":[2942195,2940672,2942242],"length":1,"stats":{"Line":9}},{"line":351,"address":[3261767],"length":1,"stats":{"Line":9}},{"line":354,"address":[2940895,2940983,2941167],"length":1,"stats":{"Line":27}},{"line":355,"address":[2952267],"length":1,"stats":{"Line":9}},{"line":356,"address":[3262057],"length":1,"stats":{"Line":9}},{"line":357,"address":[2941050],"length":1,"stats":{"Line":9}},{"line":359,"address":[2952367],"length":1,"stats":{"Line":9}},{"line":360,"address":[3262209,3263225],"length":1,"stats":{"Line":4}},{"line":361,"address":[2461972,2462054,2462700],"length":1,"stats":{"Line":8}},{"line":362,"address":[3262654],"length":1,"stats":{"Line":4}},{"line":363,"address":[2953416,2952914],"length":1,"stats":{"Line":4}},{"line":365,"address":[2941990],"length":1,"stats":{"Line":3}},{"line":366,"address":[2462424],"length":1,"stats":{"Line":3}},{"line":367,"address":[2462480],"length":1,"stats":{"Line":3}},{"line":374,"address":[2952405],"length":1,"stats":{"Line":9}},{"line":378,"address":[2940958,2942356],"length":1,"stats":{"Line":10}},{"line":379,"address":[3263303,3263382],"length":1,"stats":{"Line":9}},{"line":381,"address":[2953608],"length":1,"stats":{"Line":1}},{"line":383,"address":[3263496,3263562,3265196],"length":1,"stats":{"Line":18}},{"line":385,"address":[2942696,2942752],"length":1,"stats":{"Line":12}},{"line":386,"address":[2942969,2942737,2942757],"length":1,"stats":{"Line":22}},{"line":388,"address":[2463275],"length":1,"stats":{"Line":1}},{"line":390,"address":[2942947,2944167,2943034],"length":1,"stats":{"Line":19}},{"line":392,"address":[2954512,2954456],"length":1,"stats":{"Line":12}},{"line":393,"address":[3264257,3264489,3264277],"length":1,"stats":{"Line":19}},{"line":395,"address":[2943240],"length":1,"stats":{"Line":1}},{"line":397,"address":[2943443,2943533,2944165],"length":1,"stats":{"Line":19}},{"line":398,"address":[2464177],"length":1,"stats":{"Line":8}},{"line":400,"address":[2943711,2944141],"length":1,"stats":{"Line":11}},{"line":402,"address":[3265018],"length":1,"stats":{"Line":7}},{"line":403,"address":[2464398],"length":1,"stats":{"Line":5}},{"line":404,"address":[3264961],"length":1,"stats":{"Line":7}},{"line":405,"address":[2955227],"length":1,"stats":{"Line":7}},{"line":411,"address":[2966576,2966588,2965200],"length":1,"stats":{"Line":2}},{"line":412,"address":[2954000],"length":1,"stats":{"Line":2}},{"line":413,"address":[3275034],"length":1,"stats":{"Line":2}},{"line":414,"address":[2965445],"length":1,"stats":{"Line":2}},{"line":415,"address":[3276346,3275258],"length":1,"stats":{"Line":2}},{"line":416,"address":[3276344,3275438],"length":1,"stats":{"Line":2}},{"line":417,"address":[2965866,2966582],"length":1,"stats":{"Line":2}},{"line":418,"address":[2475178,2475100],"length":1,"stats":{"Line":4}},{"line":420,"address":[2955168],"length":1,"stats":{"Line":2}},{"line":421,"address":[2966393],"length":1,"stats":{"Line":2}},{"line":422,"address":[2475316],"length":1,"stats":{"Line":2}},{"line":427,"address":[2469104,2470243,2470237],"length":1,"stats":{"Line":7}},{"line":428,"address":[2948792],"length":1,"stats":{"Line":27}},{"line":431,"address":[2948867,2948811,2948901],"length":1,"stats":{"Line":38}},{"line":432,"address":[2949549,2949008],"length":1,"stats":{"Line":7}},{"line":433,"address":[3270262],"length":1,"stats":{"Line":10}},{"line":434,"address":[3270306],"length":1,"stats":{"Line":5}},{"line":439,"address":[2948886,2949551,2949905],"length":1,"stats":{"Line":11}},{"line":441,"address":[2961017],"length":1,"stats":{"Line":7}},{"line":442,"address":[2949714],"length":1,"stats":{"Line":6}},{"line":448,"address":[2473970,2473976,2472816],"length":1,"stats":{"Line":3}},{"line":449,"address":[2963880],"length":1,"stats":{"Line":3}},{"line":450,"address":[2473146,2473190],"length":1,"stats":{"Line":6}},{"line":452,"address":[2964278,2964215],"length":1,"stats":{"Line":6}},{"line":453,"address":[2964317,2964751],"length":1,"stats":{"Line":6}},{"line":456,"address":[2964327,2964297,2964727],"length":1,"stats":{"Line":6}},{"line":458,"address":[2964561],"length":1,"stats":{"Line":3}},{"line":459,"address":[2964490],"length":1,"stats":{"Line":3}},{"line":460,"address":[2473483],"length":1,"stats":{"Line":3}},{"line":466,"address":[2448560],"length":1,"stats":{"Line":20}},{"line":469,"address":[2939009],"length":1,"stats":{"Line":4}},{"line":472,"address":[3267236,3265216,3267369],"length":1,"stats":{"Line":20}},{"line":473,"address":[2464686],"length":1,"stats":{"Line":4}},{"line":475,"address":[2465061,2464998],"length":1,"stats":{"Line":14}},{"line":476,"address":[3265698,3265743],"length":1,"stats":{"Line":4}},{"line":477,"address":[2946317,2944759],"length":1,"stats":{"Line":2}},{"line":478,"address":[3267278,3266099,3266162],"length":1,"stats":{"Line":4}},{"line":479,"address":[3267264,3266328],"length":1,"stats":{"Line":2}},{"line":480,"address":[2466538],"length":1,"stats":{"Line":2}},{"line":481,"address":[3266639,3266791],"length":1,"stats":{"Line":4}},{"line":482,"address":[3266799,3266960],"length":1,"stats":{"Line":4}},{"line":483,"address":[2466370],"length":1,"stats":{"Line":2}},{"line":488,"address":[2465067],"length":1,"stats":{"Line":7}},{"line":491,"address":[2936432,2937623,2937683],"length":1,"stats":{"Line":24}},{"line":492,"address":[3246222],"length":1,"stats":{"Line":8}},{"line":494,"address":[2936663,2936726,2937618],"length":1,"stats":{"Line":14}},{"line":495,"address":[2446444,2446399],"length":1,"stats":{"Line":0}},{"line":496,"address":[3246646],"length":1,"stats":{"Line":0}},{"line":497,"address":[3247283],"length":1,"stats":{"Line":0}},{"line":498,"address":[2937197,2937346],"length":1,"stats":{"Line":0}},{"line":500,"address":[2937354],"length":1,"stats":{"Line":0}},{"line":505,"address":[2936732],"length":1,"stats":{"Line":7}},{"line":508,"address":[2448520,2448465,2447296],"length":1,"stats":{"Line":24}},{"line":509,"address":[2937742],"length":1,"stats":{"Line":8}},{"line":511,"address":[3247703,3247766,3248658],"length":1,"stats":{"Line":14}},{"line":512,"address":[2926862,2926817],"length":1,"stats":{"Line":2}},{"line":513,"address":[3247926],"length":1,"stats":{"Line":1}},{"line":514,"address":[2927539],"length":1,"stats":{"Line":1}},{"line":515,"address":[2938477,2938626],"length":1,"stats":{"Line":2}},{"line":517,"address":[2927370],"length":1,"stats":{"Line":1}},{"line":522,"address":[2926748],"length":1,"stats":{"Line":6}},{"line":525,"address":[3244896,3246157,3246123],"length":1,"stats":{"Line":24}},{"line":526,"address":[2923902],"length":1,"stats":{"Line":8}},{"line":528,"address":[2924197,2924260],"length":1,"stats":{"Line":13}},{"line":529,"address":[2935644,2935599],"length":1,"stats":{"Line":0}},{"line":530,"address":[2935684,2936369],"length":1,"stats":{"Line":0}},{"line":531,"address":[2924949],"length":1,"stats":{"Line":0}},{"line":532,"address":[3245662,3245718],"length":1,"stats":{"Line":0}},{"line":533,"address":[3245925],"length":1,"stats":{"Line":0}},{"line":538,"address":[3245290],"length":1,"stats":{"Line":7}},{"line":541,"address":[3258845,3256656,3258016],"length":1,"stats":{"Line":24}},{"line":542,"address":[2456350],"length":1,"stats":{"Line":8}},{"line":544,"address":[3257003,3257076],"length":1,"stats":{"Line":13}},{"line":545,"address":[2936084],"length":1,"stats":{"Line":7}},{"line":546,"address":[2937793,2936148,2937041],"length":1,"stats":{"Line":0}},{"line":547,"address":[2948948],"length":1,"stats":{"Line":0}},{"line":548,"address":[2948764,2948609],"length":1,"stats":{"Line":0}},{"line":549,"address":[2458158],"length":1,"stats":{"Line":0}},{"line":555,"address":[2936162,2936117],"length":1,"stats":{"Line":13}},{"line":556,"address":[2457682,2456931,2456967],"length":1,"stats":{"Line":0}},{"line":557,"address":[3257932],"length":1,"stats":{"Line":0}},{"line":558,"address":[2947833,2947988],"length":1,"stats":{"Line":0}},{"line":559,"address":[2457406],"length":1,"stats":{"Line":0}},{"line":565,"address":[2947432],"length":1,"stats":{"Line":6}},{"line":568,"address":[2952459,2952519,2951056],"length":1,"stats":{"Line":24}},{"line":569,"address":[2471374],"length":1,"stats":{"Line":8}},{"line":573,"address":[2963718],"length":1,"stats":{"Line":1}},{"line":574,"address":[2962624,2962551],"length":1,"stats":{"Line":13}},{"line":575,"address":[2951451,2951392],"length":1,"stats":{"Line":7}},{"line":576,"address":[2962707],"length":1,"stats":{"Line":1}},{"line":577,"address":[2962724,2962761,2962689],"length":1,"stats":{"Line":13}},{"line":578,"address":[3272513],"length":1,"stats":{"Line":0}},{"line":579,"address":[3272567,3272530,3272495],"length":1,"stats":{"Line":14}},{"line":580,"address":[2471821],"length":1,"stats":{"Line":1}},{"line":581,"address":[3272541,3272576,3272697,3272613],"length":1,"stats":{"Line":16}},{"line":582,"address":[2951581],"length":1,"stats":{"Line":1}},{"line":583,"address":[2951595,2951563],"length":1,"stats":{"Line":13}},{"line":584,"address":[2962929],"length":1,"stats":{"Line":0}},{"line":590,"address":[2951701],"length":1,"stats":{"Line":1}},{"line":591,"address":[2952359],"length":1,"stats":{"Line":1}},{"line":592,"address":[3273036,3273188],"length":1,"stats":{"Line":2}},{"line":593,"address":[2472446],"length":1,"stats":{"Line":1}},{"line":594,"address":[2952183],"length":1,"stats":{"Line":1}},{"line":599,"address":[2962865],"length":1,"stats":{"Line":7}},{"line":602,"address":[2468208],"length":1,"stats":{"Line":6}},{"line":603,"address":[2948727,2947876],"length":1,"stats":{"Line":7}},{"line":604,"address":[3268942,3269579],"length":1,"stats":{"Line":2}},{"line":605,"address":[2959900],"length":1,"stats":{"Line":2}},{"line":606,"address":[2947896,2948550],"length":1,"stats":{"Line":9}},{"line":607,"address":[3269396,3269027],"length":1,"stats":{"Line":2}},{"line":608,"address":[3269483],"length":1,"stats":{"Line":2}},{"line":609,"address":[2468731,2468348,2468475],"length":1,"stats":{"Line":13}},{"line":610,"address":[2948192,2948115],"length":1,"stats":{"Line":3}},{"line":611,"address":[2959540],"length":1,"stats":{"Line":3}},{"line":613,"address":[2959343],"length":1,"stats":{"Line":6}},{"line":618,"address":[3256032],"length":1,"stats":{"Line":21}},{"line":619,"address":[2935025],"length":1,"stats":{"Line":21}},{"line":622,"address":[2944683,2944617,2942992],"length":1,"stats":{"Line":21}},{"line":623,"address":[2931758],"length":1,"stats":{"Line":21}},{"line":626,"address":[2452887,2452814],"length":1,"stats":{"Line":104}},{"line":627,"address":[2452978,2452919],"length":1,"stats":{"Line":55}},{"line":628,"address":[2943484],"length":1,"stats":{"Line":21}},{"line":629,"address":[2452987,2453024,2452952],"length":1,"stats":{"Line":73}},{"line":630,"address":[3253290],"length":1,"stats":{"Line":3}},{"line":631,"address":[3253272,3253307,3253344],"length":1,"stats":{"Line":71}},{"line":632,"address":[2932312],"length":1,"stats":{"Line":3}},{"line":633,"address":[2453044,2453079,2453116],"length":1,"stats":{"Line":107}},{"line":634,"address":[2453108],"length":1,"stats":{"Line":3}},{"line":635,"address":[2943673,2943604,2943636],"length":1,"stats":{"Line":107}},{"line":636,"address":[3253425],"length":1,"stats":{"Line":2}},{"line":637,"address":[2453165,2453133,2453202],"length":1,"stats":{"Line":107}},{"line":638,"address":[2453194],"length":1,"stats":{"Line":2}},{"line":639,"address":[2932472,2932426,2932458],"length":1,"stats":{"Line":148}},{"line":640,"address":[2932474],"length":1,"stats":{"Line":2}},{"line":642,"address":[3253488],"length":1,"stats":{"Line":64}},{"line":645,"address":[2943746],"length":1,"stats":{"Line":21}},{"line":646,"address":[2454107,2453290,2453380],"length":1,"stats":{"Line":26}},{"line":647,"address":[2933259],"length":1,"stats":{"Line":13}},{"line":648,"address":[2453660,2453808],"length":1,"stats":{"Line":34}},{"line":650,"address":[3254102],"length":1,"stats":{"Line":21}},{"line":655,"address":[2943811],"length":1,"stats":{"Line":64}},{"line":658,"address":[2441454,2441334,2439360],"length":1,"stats":{"Line":21}},{"line":659,"address":[2918382],"length":1,"stats":{"Line":22}},{"line":661,"address":[2930023,2929960],"length":1,"stats":{"Line":105}},{"line":662,"address":[2439840,2439885],"length":1,"stats":{"Line":6}},{"line":663,"address":[2920477,2918919],"length":1,"stats":{"Line":3}},{"line":664,"address":[2919235,2920414,2919298],"length":1,"stats":{"Line":6}},{"line":665,"address":[2440454,2441358],"length":1,"stats":{"Line":3}},{"line":666,"address":[2931544],"length":1,"stats":{"Line":3}},{"line":667,"address":[2919775,2919927],"length":1,"stats":{"Line":6}},{"line":668,"address":[3240959,3241120],"length":1,"stats":{"Line":6}},{"line":669,"address":[2441074],"length":1,"stats":{"Line":3}},{"line":674,"address":[2439771],"length":1,"stats":{"Line":62}},{"line":677,"address":[3280563,3279312,3280503],"length":1,"stats":{"Line":22}},{"line":678,"address":[3279342],"length":1,"stats":{"Line":24}},{"line":680,"address":[3280498,3279606,3279543],"length":1,"stats":{"Line":107}},{"line":681,"address":[2478783,2478828],"length":1,"stats":{"Line":4}},{"line":682,"address":[2478868],"length":1,"stats":{"Line":2}},{"line":683,"address":[2970643],"length":1,"stats":{"Line":2}},{"line":684,"address":[3280077,3280226],"length":1,"stats":{"Line":4}},{"line":686,"address":[2959210],"length":1,"stats":{"Line":2}},{"line":691,"address":[2969852],"length":1,"stats":{"Line":42}},{"line":694,"address":[2960915,2960855,2959664],"length":1,"stats":{"Line":24}},{"line":695,"address":[2959694],"length":1,"stats":{"Line":24}},{"line":697,"address":[3280919,3280982,3281874],"length":1,"stats":{"Line":108}},{"line":698,"address":[2480143,2480188],"length":1,"stats":{"Line":4}},{"line":699,"address":[2480228],"length":1,"stats":{"Line":2}},{"line":700,"address":[3281779],"length":1,"stats":{"Line":2}},{"line":701,"address":[2971693,2971842],"length":1,"stats":{"Line":4}},{"line":703,"address":[3281610],"length":1,"stats":{"Line":2}},{"line":708,"address":[2971228],"length":1,"stats":{"Line":63}},{"line":711,"address":[2958219,2956992,2958253],"length":1,"stats":{"Line":24}},{"line":712,"address":[3278046],"length":1,"stats":{"Line":24}},{"line":716,"address":[2477522,2477459],"length":1,"stats":{"Line":104}},{"line":717,"address":[2957500,2957455],"length":1,"stats":{"Line":4}},{"line":718,"address":[2968804,2969489],"length":1,"stats":{"Line":2}},{"line":719,"address":[3279093],"length":1,"stats":{"Line":2}},{"line":720,"address":[2969078,2969022],"length":1,"stats":{"Line":4}},{"line":721,"address":[2958021],"length":1,"stats":{"Line":2}},{"line":726,"address":[2968650],"length":1,"stats":{"Line":42}},{"line":730,"address":[2951905,2950656,2951713],"length":1,"stats":{"Line":42}},{"line":731,"address":[2950686],"length":1,"stats":{"Line":30}},{"line":734,"address":[2951193,2950984,2951047],"length":1,"stats":{"Line":104}},{"line":736,"address":[2951122],"length":1,"stats":{"Line":2}},{"line":737,"address":[2939875],"length":1,"stats":{"Line":2}},{"line":739,"address":[2460477],"length":1,"stats":{"Line":2}},{"line":740,"address":[2951203,2951248],"length":1,"stats":{"Line":6}},{"line":741,"address":[2460606],"length":1,"stats":{"Line":2}},{"line":744,"address":[3261052,3261140],"length":1,"stats":{"Line":3}},{"line":745,"address":[2940141],"length":1,"stats":{"Line":3}},{"line":746,"address":[2460755],"length":1,"stats":{"Line":3}},{"line":747,"address":[3261240],"length":1,"stats":{"Line":3}},{"line":749,"address":[2940098],"length":1,"stats":{"Line":1}},{"line":752,"address":[2940518],"length":1,"stats":{"Line":4}},{"line":753,"address":[2940312],"length":1,"stats":{"Line":2}},{"line":754,"address":[2951608],"length":1,"stats":{"Line":4}},{"line":759,"address":[2460515],"length":1,"stats":{"Line":0}},{"line":763,"address":[3260813],"length":1,"stats":{"Line":62}},{"line":766,"address":[2423162,2421824,2423962],"length":1,"stats":{"Line":42}},{"line":767,"address":[3221486],"length":1,"stats":{"Line":30}},{"line":769,"address":[3221803,3221876],"length":1,"stats":{"Line":102}},{"line":770,"address":[2422274],"length":1,"stats":{"Line":61}},{"line":771,"address":[2423935,2422338,2423223],"length":1,"stats":{"Line":4}},{"line":772,"address":[2423830],"length":1,"stats":{"Line":3}},{"line":773,"address":[2423503,2423654],"length":1,"stats":{"Line":5}},{"line":774,"address":[2423662],"length":1,"stats":{"Line":2}},{"line":780,"address":[2900917,2900962],"length":1,"stats":{"Line":104}},{"line":781,"address":[2913084,2912309,2912329],"length":1,"stats":{"Line":4}},{"line":782,"address":[2423078],"length":1,"stats":{"Line":2}},{"line":783,"address":[2422751,2422902],"length":1,"stats":{"Line":4}},{"line":784,"address":[3222556],"length":1,"stats":{"Line":2}},{"line":790,"address":[2900968],"length":1,"stats":{"Line":42}},{"line":793,"address":[2944720,2946229,2946169],"length":1,"stats":{"Line":42}},{"line":794,"address":[2933486],"length":1,"stats":{"Line":30}},{"line":796,"address":[2934900],"length":1,"stats":{"Line":5}},{"line":797,"address":[3254711,3254784],"length":1,"stats":{"Line":106}},{"line":798,"address":[2454510,2454569],"length":1,"stats":{"Line":67}},{"line":799,"address":[2933843],"length":1,"stats":{"Line":3}},{"line":800,"address":[2454615,2454543,2454578],"length":1,"stats":{"Line":112}},{"line":801,"address":[2933889],"length":1,"stats":{"Line":8}},{"line":802,"address":[2454589,2454661,2454624],"length":1,"stats":{"Line":106}},{"line":803,"address":[2454653],"length":1,"stats":{"Line":3}},{"line":804,"address":[3254976,3254941,3255013],"length":1,"stats":{"Line":103}},{"line":805,"address":[2454699],"length":1,"stats":{"Line":2}},{"line":806,"address":[2945299,2945383,2945262,2945227],"length":1,"stats":{"Line":105}},{"line":807,"address":[2454745],"length":1,"stats":{"Line":4}},{"line":808,"address":[2934041,2934009],"length":1,"stats":{"Line":100}},{"line":809,"address":[2454829],"length":1,"stats":{"Line":2}},{"line":814,"address":[2945411],"length":1,"stats":{"Line":3}},{"line":815,"address":[2934805],"length":1,"stats":{"Line":4}},{"line":816,"address":[2455168,2455316],"length":1,"stats":{"Line":7}},{"line":817,"address":[2934618],"length":1,"stats":{"Line":4}},{"line":818,"address":[2945893],"length":1,"stats":{"Line":4}},{"line":823,"address":[2934047],"length":1,"stats":{"Line":41}},{"line":826,"address":[3228128,3229376,3229316],"length":1,"stats":{"Line":30}},{"line":827,"address":[2428398],"length":1,"stats":{"Line":11}},{"line":831,"address":[2428653,2428597,2429525],"length":1,"stats":{"Line":142}},{"line":832,"address":[2428736,2428772],"length":1,"stats":{"Line":4}},{"line":833,"address":[2429125,2429057],"length":1,"stats":{"Line":4}},{"line":834,"address":[2908192],"length":1,"stats":{"Line":2}},{"line":835,"address":[2919171],"length":1,"stats":{"Line":2}},{"line":837,"address":[3229047],"length":1,"stats":{"Line":2}},{"line":842,"address":[2428659],"length":1,"stats":{"Line":20}},{"line":845,"address":[3274800],"length":1,"stats":{"Line":48}},{"line":846,"address":[2953905,2953785],"length":1,"stats":{"Line":70}},{"line":847,"address":[2474131,2474064],"length":1,"stats":{"Line":118}},{"line":848,"address":[3274857],"length":1,"stats":{"Line":48}},{"line":859,"address":[2965164],"length":1,"stats":{"Line":0}},{"line":863,"address":[2921857,2921917,2920592],"length":1,"stats":{"Line":30}},{"line":864,"address":[2931886],"length":1,"stats":{"Line":11}},{"line":866,"address":[2933116],"length":1,"stats":{"Line":4}},{"line":867,"address":[3241920,3241847],"length":1,"stats":{"Line":90}},{"line":868,"address":[2932192,2932251,2932335],"length":1,"stats":{"Line":49}},{"line":869,"address":[2932243],"length":1,"stats":{"Line":4}},{"line":870,"address":[2920961,2920993],"length":1,"stats":{"Line":117}},{"line":871,"address":[2932327],"length":1,"stats":{"Line":4}},{"line":876,"address":[3242123],"length":1,"stats":{"Line":4}},{"line":877,"address":[2442679],"length":1,"stats":{"Line":4}},{"line":878,"address":[2442492,2442344],"length":1,"stats":{"Line":8}},{"line":879,"address":[3242594],"length":1,"stats":{"Line":4}},{"line":880,"address":[2932845],"length":1,"stats":{"Line":4}},{"line":885,"address":[2932263],"length":1,"stats":{"Line":48}},{"line":888,"address":[3267456,3268767,3268827],"length":1,"stats":{"Line":30}},{"line":889,"address":[3267486],"length":1,"stats":{"Line":13}},{"line":891,"address":[3268762],"length":1,"stats":{"Line":4}},{"line":892,"address":[2467134,2467061],"length":1,"stats":{"Line":74}},{"line":893,"address":[2946768,2946827],"length":1,"stats":{"Line":45}},{"line":894,"address":[2467217],"length":1,"stats":{"Line":3}},{"line":895,"address":[2958137,2958065,2958100,2958221],"length":1,"stats":{"Line":77}},{"line":896,"address":[3267889],"length":1,"stats":{"Line":2}},{"line":897,"address":[2958143,2958111],"length":1,"stats":{"Line":89}},{"line":898,"address":[2958213],"length":1,"stats":{"Line":2}},{"line":903,"address":[2467383],"length":1,"stats":{"Line":3}},{"line":904,"address":[2468021],"length":1,"stats":{"Line":4}},{"line":905,"address":[2958560,2958712],"length":1,"stats":{"Line":6}},{"line":906,"address":[3268480],"length":1,"stats":{"Line":3}},{"line":907,"address":[2947467],"length":1,"stats":{"Line":3}},{"line":912,"address":[3267909],"length":1,"stats":{"Line":49}},{"line":915,"address":[2425270,2425321,2424000],"length":1,"stats":{"Line":30}},{"line":916,"address":[3223710],"length":1,"stats":{"Line":13}},{"line":919,"address":[2902989,2903052],"length":1,"stats":{"Line":66}},{"line":920,"address":[2903172,2903127],"length":1,"stats":{"Line":8}},{"line":921,"address":[2424554,2425294],"length":1,"stats":{"Line":4}},{"line":922,"address":[2425176],"length":1,"stats":{"Line":4}},{"line":923,"address":[2903523,2903672],"length":1,"stats":{"Line":8}},{"line":925,"address":[3224704],"length":1,"stats":{"Line":4}},{"line":930,"address":[2424400],"length":1,"stats":{"Line":26}},{"line":933,"address":[3226187,3225072,3226155],"length":1,"stats":{"Line":30}},{"line":934,"address":[2425398],"length":1,"stats":{"Line":13}},{"line":936,"address":[2425474],"length":1,"stats":{"Line":30}},{"line":937,"address":[2917898,2915470],"length":1,"stats":{"Line":2}},{"line":938,"address":[2918276],"length":1,"stats":{"Line":2}},{"line":940,"address":[2918118],"length":1,"stats":{"Line":2}},{"line":945,"address":[2904183],"length":1,"stats":{"Line":17}},{"line":946,"address":[2427423,2425616],"length":1,"stats":{"Line":3}},{"line":947,"address":[2906541],"length":1,"stats":{"Line":3}},{"line":949,"address":[2427651],"length":1,"stats":{"Line":3}},{"line":954,"address":[3225306],"length":1,"stats":{"Line":51}},{"line":955,"address":[3226676,3225428],"length":1,"stats":{"Line":2}},{"line":956,"address":[3227074],"length":1,"stats":{"Line":2}},{"line":958,"address":[3226905],"length":1,"stats":{"Line":2}},{"line":963,"address":[3225405],"length":1,"stats":{"Line":17}},{"line":964,"address":[2904503,2905169],"length":1,"stats":{"Line":3}},{"line":965,"address":[3226591,3226422],"length":1,"stats":{"Line":6}},{"line":968,"address":[2915744],"length":1,"stats":{"Line":54}},{"line":969,"address":[2904596,2904673],"length":1,"stats":{"Line":2}},{"line":970,"address":[3226092,3225926],"length":1,"stats":{"Line":4}},{"line":973,"address":[2425892],"length":1,"stats":{"Line":17}},{"line":976,"address":[2434823,2434448,2432128],"length":1,"stats":{"Line":59}},{"line":977,"address":[3232014],"length":1,"stats":{"Line":22}},{"line":980,"address":[2911288,2911215],"length":1,"stats":{"Line":7}},{"line":982,"address":[2434818,2432486],"length":1,"stats":{"Line":10}},{"line":983,"address":[2913650,2911371],"length":1,"stats":{"Line":6}},{"line":984,"address":[2922759,2924196,2922617,2924894],"length":1,"stats":{"Line":49}},{"line":985,"address":[3234583,3232548],"length":1,"stats":{"Line":4}},{"line":986,"address":[2922912,2922770],"length":1,"stats":{"Line":71}},{"line":988,"address":[2432892,2432918],"length":1,"stats":{"Line":36}},{"line":989,"address":[2432976,2434462,2434529,2433079],"length":1,"stats":{"Line":36}},{"line":990,"address":[2912407,2912344],"length":1,"stats":{"Line":36}},{"line":991,"address":[2923717,2924307],"length":1,"stats":{"Line":4}},{"line":993,"address":[2923682,2923727,2924283],"length":1,"stats":{"Line":34}},{"line":994,"address":[2433868,2434079,2434072],"length":1,"stats":{"Line":19}},{"line":995,"address":[2923890],"length":1,"stats":{"Line":19}},{"line":996,"address":[2923946],"length":1,"stats":{"Line":17}},{"line":1000,"address":[2432998,2434566],"length":1,"stats":{"Line":0}},{"line":1007,"address":[3232678],"length":1,"stats":{"Line":26}},{"line":1010,"address":[2421168,2421785,2421810],"length":1,"stats":{"Line":59}},{"line":1011,"address":[2421206],"length":1,"stats":{"Line":22}},{"line":1012,"address":[2899844],"length":1,"stats":{"Line":4}},{"line":1013,"address":[2421364,2421288],"length":1,"stats":{"Line":4}},{"line":1014,"address":[2421577,2421722],"length":1,"stats":{"Line":8}},{"line":1017,"address":[3220856],"length":1,"stats":{"Line":66}},{"line":1020,"address":[3234832,3235484,3235490],"length":1,"stats":{"Line":22}},{"line":1021,"address":[3234870],"length":1,"stats":{"Line":66}},{"line":1024,"address":[2925178,2925286],"length":1,"stats":{"Line":28}},{"line":1025,"address":[2914042],"length":1,"stats":{"Line":6}},{"line":1026,"address":[3235086],"length":1,"stats":{"Line":6}},{"line":1027,"address":[3235112],"length":1,"stats":{"Line":6}},{"line":1031,"address":[3235161,3234992,3235233],"length":1,"stats":{"Line":91}},{"line":1032,"address":[2435317],"length":1,"stats":{"Line":6}},{"line":1033,"address":[2914251],"length":1,"stats":{"Line":6}},{"line":1034,"address":[2435405],"length":1,"stats":{"Line":6}},{"line":1038,"address":[2925743,2925420,2925815],"length":1,"stats":{"Line":82}},{"line":1039,"address":[2925835],"length":1,"stats":{"Line":4}},{"line":1040,"address":[2435681],"length":1,"stats":{"Line":4}},{"line":1041,"address":[3235683],"length":1,"stats":{"Line":5}},{"line":1045,"address":[2435890,2435586,2435934],"length":1,"stats":{"Line":133}},{"line":1046,"address":[2435954],"length":1,"stats":{"Line":18}},{"line":1047,"address":[3235920],"length":1,"stats":{"Line":55}},{"line":1050,"address":[2926213],"length":1,"stats":{"Line":18}},{"line":1051,"address":[2436240],"length":1,"stats":{"Line":11}},{"line":1052,"address":[2926525,2926451],"length":1,"stats":{"Line":31}},{"line":1053,"address":[2915884,2915317,2915280],"length":1,"stats":{"Line":33}},{"line":1054,"address":[2915567],"length":1,"stats":{"Line":20}},{"line":1055,"address":[2915611],"length":1,"stats":{"Line":11}},{"line":1058,"address":[2436372,2436958,2437357],"length":1,"stats":{"Line":29}},{"line":1059,"address":[2916166],"length":1,"stats":{"Line":22}},{"line":1060,"address":[2437102],"length":1,"stats":{"Line":22}},{"line":1061,"address":[3237134],"length":1,"stats":{"Line":17}},{"line":1066,"address":[2926260],"length":1,"stats":{"Line":44}},{"line":1070,"address":[2926085],"length":1,"stats":{"Line":6}},{"line":1071,"address":[2928782,2927693,2928742],"length":1,"stats":{"Line":5}},{"line":1072,"address":[2438566],"length":1,"stats":{"Line":3}},{"line":1073,"address":[3238589],"length":1,"stats":{"Line":3}},{"line":1074,"address":[2928880],"length":1,"stats":{"Line":3}},{"line":1076,"address":[2917492],"length":1,"stats":{"Line":1}},{"line":1079,"address":[3238749,3238833,3238815,3239321],"length":1,"stats":{"Line":7}},{"line":1080,"address":[2439321,2439067,2438843],"length":1,"stats":{"Line":4}},{"line":1082,"address":[2438816],"length":1,"stats":{"Line":1}},{"line":1085,"address":[2438940],"length":1,"stats":{"Line":2}},{"line":1086,"address":[2438868],"length":1,"stats":{"Line":2}},{"line":1087,"address":[2929169],"length":1,"stats":{"Line":2}},{"line":1093,"address":[2927666],"length":1,"stats":{"Line":6}},{"line":1094,"address":[2916719],"length":1,"stats":{"Line":6}},{"line":1095,"address":[2438453,2438055,2438134],"length":1,"stats":{"Line":8}},{"line":1096,"address":[2917231],"length":1,"stats":{"Line":4}},{"line":1099,"address":[2927916],"length":1,"stats":{"Line":0}},{"line":1100,"address":[3237511],"length":1,"stats":{"Line":0}},{"line":1108,"address":[2960944],"length":1,"stats":{"Line":22}},{"line":1109,"address":[2884584,2884576],"length":1,"stats":{"Line":146}},{"line":1112,"address":[2931616],"length":1,"stats":{"Line":65}},{"line":1113,"address":[2452398],"length":1,"stats":{"Line":30}},{"line":1114,"address":[2452414],"length":1,"stats":{"Line":65}},{"line":1115,"address":[2931666],"length":1,"stats":{"Line":125}},{"line":1116,"address":[2942949],"length":1,"stats":{"Line":65}},{"line":1119,"address":[2959568],"length":1,"stats":{"Line":28}},{"line":1120,"address":[2970841],"length":1,"stats":{"Line":65}},{"line":1123,"address":[2955392],"length":1,"stats":{"Line":12}},{"line":1124,"address":[2207296,2207328],"length":1,"stats":{"Line":149}},{"line":1127,"address":[2476960],"length":1,"stats":{"Line":20}},{"line":1128,"address":[2956934,2956830],"length":1,"stats":{"Line":50}},{"line":1129,"address":[2476988,2477073,2477079],"length":1,"stats":{"Line":51}},{"line":1131,"address":[3277988,3277999,3277896],"length":1,"stats":{"Line":51}},{"line":1134,"address":[2910000],"length":1,"stats":{"Line":12}},{"line":1135,"address":[2898769,2898755],"length":1,"stats":{"Line":123}},{"line":1136,"address":[2910040],"length":1,"stats":{"Line":5}},{"line":1137,"address":[2910045],"length":1,"stats":{"Line":5}},{"line":1139,"address":[2420204],"length":1,"stats":{"Line":25}},{"line":1143,"address":[2956384],"length":1,"stats":{"Line":27}},{"line":1144,"address":[2956748,2956427],"length":1,"stats":{"Line":5}},{"line":1145,"address":[2968019],"length":1,"stats":{"Line":51}},{"line":1147,"address":[2967714],"length":1,"stats":{"Line":0}},{"line":1148,"address":[2476854],"length":1,"stats":{"Line":0}},{"line":1149,"address":[3277510],"length":1,"stats":{"Line":0}},{"line":1156,"address":[3256128,3256638,3256632],"length":1,"stats":{"Line":4}},{"line":1157,"address":[2455830,2456126],"length":1,"stats":{"Line":4}},{"line":1158,"address":[2935462],"length":1,"stats":{"Line":4}},{"line":1159,"address":[2946745],"length":1,"stats":{"Line":4}},{"line":1160,"address":[2456217],"length":1,"stats":{"Line":5}},{"line":1162,"address":[3256224],"length":1,"stats":{"Line":0}},{"line":1163,"address":[2946665],"length":1,"stats":{"Line":0}},{"line":1164,"address":[3256260],"length":1,"stats":{"Line":0}},{"line":1171,"address":[2931808],"length":1,"stats":{"Line":12}},{"line":1172,"address":[2931827],"length":1,"stats":{"Line":56}},{"line":1175,"address":[2935040],"length":1,"stats":{"Line":5}},{"line":1176,"address":[2455747],"length":1,"stats":{"Line":4}},{"line":1179,"address":[2957648],"length":1,"stats":{"Line":27}},{"line":1180,"address":[2873193,2873184],"length":1,"stats":{"Line":43}}],"covered":582,"coverable":619},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","value.rs"],"content":"use std::borrow::Cow;\nuse std::cmp::Ordering;\nuse std::fmt;\n\n/// AWK value type with dynamic typing and automatic coercion\n///\n/// AWK has a unique type system where values can be strings, numbers, or\n/// \"numeric strings\" (strings that look like numbers). This enum captures\n/// all three cases.\n///\n/// # Examples\n///\n/// ```\n/// use rawk::Value;\n///\n/// // Numbers\n/// let num = Value::Number(42.0);\n/// assert_eq!(num.to_number(), 42.0);\n/// assert_eq!(num.to_string_val(), \"42\");\n///\n/// // Strings\n/// let s = Value::from_string(\"hello\".to_string());\n/// assert_eq!(s.to_string_val(), \"hello\");\n/// assert_eq!(s.to_number(), 0.0);  // Non-numeric string coerces to 0\n///\n/// // Numeric strings\n/// let ns = Value::from_string(\"123\".to_string());\n/// assert_eq!(ns.to_number(), 123.0);\n/// assert_eq!(ns.to_string_val(), \"123\");\n///\n/// // Truthiness\n/// assert!(Value::Number(1.0).is_truthy());\n/// assert!(!Value::Number(0.0).is_truthy());\n/// assert!(Value::from_string(\"hello\".to_string()).is_truthy());\n/// assert!(!Value::from_string(\"\".to_string()).is_truthy());\n/// ```\n#[derive(Debug, Clone)]\npub enum Value {\n    /// Uninitialized value - coerces to \"\" or 0 depending on context\n    Uninitialized,\n    /// Numeric value\n    Number(f64),\n    /// String value\n    String(String),\n    /// Numeric string - a string that looks like a number\n    /// (used for comparison semantics)\n    NumericString(String, f64),\n}\n\nimpl Default for Value {\n    fn default() -\u003e Self {\n        Value::Uninitialized\n    }\n}\n\nimpl Value {\n    /// Create a new string value, detecting if it's a numeric string\n    #[inline]\n    pub fn from_string(s: String) -\u003e Self {\n        if let Some(num) = parse_numeric_string(\u0026s) {\n            Value::NumericString(s, num)\n        } else {\n            Value::String(s)\n        }\n    }\n\n    /// Create a numeric value\n    #[inline]\n    pub fn from_number(n: f64) -\u003e Self {\n        Value::Number(n)\n    }\n\n    /// Check if this value is \"true\" in boolean context\n    /// - Uninitialized is false\n    /// - Number 0 is false\n    /// - Empty string is false\n    /// - Everything else is true\n    #[inline]\n    pub fn is_truthy(\u0026self) -\u003e bool {\n        match self {\n            Value::Uninitialized =\u003e false,\n            Value::Number(n) =\u003e *n != 0.0,\n            Value::String(s) =\u003e !s.is_empty(),\n            Value::NumericString(s, _) =\u003e !s.is_empty(),\n        }\n    }\n\n    /// Coerce to numeric value\n    #[inline]\n    pub fn to_number(\u0026self) -\u003e f64 {\n        match self {\n            Value::Uninitialized =\u003e 0.0,\n            Value::Number(n) =\u003e *n,\n            Value::String(s) =\u003e parse_leading_number(s),\n            Value::NumericString(_, n) =\u003e *n,\n        }\n    }\n\n    /// Coerce to string value\n    #[inline]\n    pub fn to_string_val(\u0026self) -\u003e String {\n        self.to_string_with_format(\"%.6g\")\n    }\n\n    /// Get string as Cow to avoid allocation when possible\n    #[inline]\n    pub fn as_str(\u0026self) -\u003e Cow\u003c'_, str\u003e {\n        match self {\n            Value::Uninitialized =\u003e Cow::Borrowed(\"\"),\n            Value::Number(n) =\u003e Cow::Owned(format_number(*n, \"%.6g\")),\n            Value::String(s) =\u003e Cow::Borrowed(s),\n            Value::NumericString(s, _) =\u003e Cow::Borrowed(s),\n        }\n    }\n\n    /// Coerce to string with specific format (for OFMT/CONVFMT)\n    pub fn to_string_with_format(\u0026self, format: \u0026str) -\u003e String {\n        match self {\n            Value::Uninitialized =\u003e String::new(),\n            Value::Number(n) =\u003e format_number(*n, format),\n            Value::String(s) =\u003e s.clone(),\n            Value::NumericString(s, _) =\u003e s.clone(),\n        }\n    }\n\n    /// Check if this value is definitely numeric\n    #[inline]\n    pub fn is_numeric(\u0026self) -\u003e bool {\n        matches!(self, Value::Number(_))\n    }\n\n    /// Check if this value is a numeric string\n    #[inline]\n    pub fn is_numeric_string(\u0026self) -\u003e bool {\n        matches!(self, Value::NumericString(_, _))\n    }\n\n    /// Check if this value should compare as a number\n    #[inline]\n    pub fn compares_as_number(\u0026self) -\u003e bool {\n        matches!(self, Value::Number(_) | Value::NumericString(_, _) | Value::Uninitialized)\n    }\n}\n\nimpl fmt::Display for Value {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Value::Uninitialized =\u003e Ok(()),\n            Value::Number(n) =\u003e write!(f, \"{}\", format_number(*n, \"%.6g\")),\n            Value::String(s) =\u003e write!(f, \"{}\", s),\n            Value::NumericString(s, _) =\u003e write!(f, \"{}\", s),\n        }\n    }\n}\n\n/// Compare two AWK values according to AWK comparison rules\n#[inline]\npub fn compare_values(left: \u0026Value, right: \u0026Value) -\u003e Ordering {\n    // If both are numeric or numeric strings, compare numerically\n    if left.compares_as_number() \u0026\u0026 right.compares_as_number() {\n        let l = left.to_number();\n        let r = right.to_number();\n        l.partial_cmp(\u0026r).unwrap_or(Ordering::Equal)\n    } else {\n        // Otherwise compare as strings - use as_str to avoid allocation\n        left.as_str().cmp(\u0026right.as_str())\n    }\n}\n\n/// Parse the leading numeric portion of a string using optimized byte-based parsing\n/// \"42abc\" -\u003e 42.0\n/// \"  3.14  \" -\u003e 3.14\n/// \"abc\" -\u003e 0.0\n#[inline]\npub fn parse_leading_number(s: \u0026str) -\u003e f64 {\n    let bytes = s.as_bytes();\n    let mut i = 0;\n\n    // Skip leading whitespace\n    while i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_whitespace() {\n        i += 1;\n    }\n\n    if i \u003e= bytes.len() {\n        return 0.0;\n    }\n\n    let start = i;\n\n    // Optional sign\n    if i \u003c bytes.len() \u0026\u0026 (bytes[i] == b'+' || bytes[i] == b'-') {\n        i += 1;\n    }\n\n    let mut has_digits = false;\n\n    // Digits before decimal\n    while i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_digit() {\n        i += 1;\n        has_digits = true;\n    }\n\n    // Decimal point and digits after\n    if i \u003c bytes.len() \u0026\u0026 bytes[i] == b'.' {\n        i += 1;\n        while i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_digit() {\n            i += 1;\n            has_digits = true;\n        }\n    }\n\n    // Exponent\n    if i \u003c bytes.len() \u0026\u0026 (bytes[i] == b'e' || bytes[i] == b'E') {\n        let exp_start = i;\n        i += 1;\n        if i \u003c bytes.len() \u0026\u0026 (bytes[i] == b'+' || bytes[i] == b'-') {\n            i += 1;\n        }\n        if i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_digit() {\n            while i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_digit() {\n                i += 1;\n            }\n        } else {\n            // Invalid exponent, back up\n            i = exp_start;\n        }\n    }\n\n    if !has_digits {\n        return 0.0;\n    }\n\n    // Fast path for common integer case\n    let num_str = \u0026s[start..i];\n    if !num_str.contains('.') \u0026\u0026 !num_str.contains('e') \u0026\u0026 !num_str.contains('E') {\n        if let Ok(n) = num_str.parse::\u003ci64\u003e() {\n            return n as f64;\n        }\n    }\n\n    num_str.parse().unwrap_or(0.0)\n}\n\n/// Check if a string is a numeric string (looks entirely like a number)\n#[inline]\nfn parse_numeric_string(s: \u0026str) -\u003e Option\u003cf64\u003e {\n    let trimmed = s.trim();\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    // Fast path: check if it's a simple integer\n    if trimmed.bytes().all(|b| b.is_ascii_digit()) {\n        return trimmed.parse().ok();\n    }\n\n    // Check for leading sign\n    let check = if trimmed.starts_with('-') || trimmed.starts_with('+') {\n        \u0026trimmed[1..]\n    } else {\n        trimmed\n    };\n\n    // Simple float pattern check\n    let mut has_dot = false;\n    let mut has_e = false;\n    for (i, b) in check.bytes().enumerate() {\n        match b {\n            b'0'..=b'9' =\u003e continue,\n            b'.' if !has_dot \u0026\u0026 !has_e =\u003e has_dot = true,\n            b'e' | b'E' if !has_e \u0026\u0026 i \u003e 0 =\u003e {\n                has_e = true;\n                // Check for sign after e\n                if i + 1 \u003c check.len() {\n                    let next = check.as_bytes()[i + 1];\n                    if next == b'+' || next == b'-' {\n                        continue;\n                    }\n                }\n            }\n            b'+' | b'-' if has_e =\u003e continue,\n            _ =\u003e return None,\n        }\n    }\n\n    trimmed.parse().ok()\n}\n\n/// Format a number according to printf-style format\npub fn format_number(n: f64, format: \u0026str) -\u003e String {\n    if n.is_nan() {\n        return \"nan\".to_string();\n    }\n    if n.is_infinite() {\n        return if n \u003e 0.0 { \"inf\" } else { \"-inf\" }.to_string();\n    }\n\n    // Handle %.6g (default OFMT) - optimized path\n    if format == \"%.6g\" {\n        // If it's an integer, print without decimal\n        if n.fract() == 0.0 \u0026\u0026 n.abs() \u003c 1e15 {\n            return itoa_fast(n as i64);\n        }\n        // Otherwise use default formatting with reasonable precision\n        let s = format!(\"{:.6}\", n);\n        // Trim trailing zeros after decimal point\n        if s.contains('.') {\n            let trimmed = s.trim_end_matches('0');\n            if trimmed.ends_with('.') {\n                return trimmed[..trimmed.len()-1].to_string();\n            }\n            return trimmed.to_string();\n        }\n        return s;\n    }\n\n    // Fallback\n    format!(\"{}\", n)\n}\n\n/// Fast integer to string conversion\n#[inline]\nfn itoa_fast(n: i64) -\u003e String {\n    if n == 0 {\n        return \"0\".to_string();\n    }\n\n    let mut result = String::with_capacity(20);\n    let mut num = n;\n    let negative = num \u003c 0;\n    if negative {\n        num = -num;\n    }\n\n    while num \u003e 0 {\n        result.push((b'0' + (num % 10) as u8) as char);\n        num /= 10;\n    }\n\n    if negative {\n        result.push('-');\n    }\n\n    result.chars().rev().collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_uninitialized() {\n        let v = Value::Uninitialized;\n        assert_eq!(v.to_number(), 0.0);\n        assert_eq!(v.to_string_val(), \"\");\n        assert!(!v.is_truthy());\n    }\n\n    #[test]\n    fn test_number() {\n        let v = Value::Number(42.0);\n        assert_eq!(v.to_number(), 42.0);\n        assert_eq!(v.to_string_val(), \"42\");\n        assert!(v.is_truthy());\n\n        let zero = Value::Number(0.0);\n        assert!(!zero.is_truthy());\n    }\n\n    #[test]\n    fn test_string() {\n        let v = Value::from_string(\"hello\".to_string());\n        assert_eq!(v.to_number(), 0.0);\n        assert_eq!(v.to_string_val(), \"hello\");\n        assert!(v.is_truthy());\n\n        let empty = Value::from_string(\"\".to_string());\n        assert!(!empty.is_truthy());\n    }\n\n    #[test]\n    fn test_numeric_string() {\n        let v = Value::from_string(\"42\".to_string());\n        assert!(v.is_numeric_string());\n        assert_eq!(v.to_number(), 42.0);\n        assert_eq!(v.to_string_val(), \"42\");\n    }\n\n    #[test]\n    fn test_leading_number() {\n        assert_eq!(parse_leading_number(\"42abc\"), 42.0);\n        assert_eq!(parse_leading_number(\"  3.14  \"), 3.14);\n        assert_eq!(parse_leading_number(\"abc\"), 0.0);\n        assert_eq!(parse_leading_number(\"-5.5\"), -5.5);\n        assert_eq!(parse_leading_number(\"1e10\"), 1e10);\n    }\n\n    #[test]\n    fn test_comparison() {\n        let n1 = Value::Number(10.0);\n        let n2 = Value::Number(2.0);\n        assert_eq!(compare_values(\u0026n1, \u0026n2), Ordering::Greater);\n\n        let s1 = Value::from_string(\"10\".to_string());\n        let s2 = Value::from_string(\"2\".to_string());\n        // Both numeric strings -\u003e compare numerically\n        assert_eq!(compare_values(\u0026s1, \u0026s2), Ordering::Greater);\n\n        let s3 = Value::from_string(\"abc\".to_string());\n        let s4 = Value::from_string(\"def\".to_string());\n        // Both pure strings -\u003e compare lexically\n        assert_eq!(compare_values(\u0026s3, \u0026s4), Ordering::Less);\n    }\n\n    #[test]\n    fn test_itoa_fast() {\n        assert_eq!(itoa_fast(0), \"0\");\n        assert_eq!(itoa_fast(42), \"42\");\n        assert_eq!(itoa_fast(-123), \"-123\");\n        assert_eq!(itoa_fast(1000000), \"1000000\");\n    }\n\n    #[test]\n    fn test_format_number_nan() {\n        assert_eq!(format_number(f64::NAN, \"%.6g\"), \"nan\");\n    }\n\n    #[test]\n    fn test_format_number_inf() {\n        assert_eq!(format_number(f64::INFINITY, \"%.6g\"), \"inf\");\n        assert_eq!(format_number(f64::NEG_INFINITY, \"%.6g\"), \"-inf\");\n    }\n\n    #[test]\n    fn test_format_number_integer() {\n        assert_eq!(format_number(42.0, \"%.6g\"), \"42\");\n        assert_eq!(format_number(-100.0, \"%.6g\"), \"-100\");\n    }\n\n    #[test]\n    fn test_format_number_float() {\n        assert_eq!(format_number(3.14, \"%.6g\"), \"3.14\");\n    }\n\n    #[test]\n    fn test_from_number() {\n        let v = Value::from_number(3.14);\n        assert_eq!(v.to_number(), 3.14);\n    }\n\n    #[test]\n    fn test_is_truthy_numeric_string() {\n        let v = Value::NumericString(\"42\".to_string(), 42.0);\n        assert!(v.is_truthy());\n        \n        let empty = Value::NumericString(\"\".to_string(), 0.0);\n        assert!(!empty.is_truthy());\n    }\n\n    #[test]\n    fn test_comparison_number_vs_string() {\n        let n = Value::Number(10.0);\n        let s = Value::from_string(\"hello\".to_string());\n        // Number vs non-numeric string\n        assert!(compare_values(\u0026n, \u0026s) != Ordering::Equal);\n    }\n\n    #[test]\n    fn test_comparison_uninitialized() {\n        let u = Value::Uninitialized;\n        let n = Value::Number(1.0);\n        // Uninitialized (0) vs 1 should be Less\n        assert_eq!(compare_values(\u0026u, \u0026n), Ordering::Less);\n    }\n\n    #[test]\n    fn test_parse_leading_with_sign() {\n        assert_eq!(parse_leading_number(\"+42\"), 42.0);\n        assert_eq!(parse_leading_number(\"  +3.14\"), 3.14);\n    }\n\n    #[test]\n    fn test_parse_leading_exponent() {\n        assert_eq!(parse_leading_number(\"1e-5\"), 1e-5);\n        assert_eq!(parse_leading_number(\"2E+3\"), 2000.0);\n    }\n\n    #[test]\n    fn test_numeric_string_with_exponent() {\n        let v = Value::from_string(\"1e5\".to_string());\n        assert!(v.is_numeric_string());\n        assert_eq!(v.to_number(), 1e5);\n    }\n\n    #[test]\n    fn test_numeric_string_with_sign() {\n        let v = Value::from_string(\"-42.5\".to_string());\n        assert!(v.is_numeric_string());\n        assert_eq!(v.to_number(), -42.5);\n    }\n\n    #[test]\n    fn test_numeric_string_whitespace() {\n        let v = Value::from_string(\"  123  \".to_string());\n        assert!(v.is_numeric_string());\n        assert_eq!(v.to_number(), 123.0);\n    }\n\n    #[test]\n    fn test_to_string_val_uninitialized() {\n        let v = Value::Uninitialized;\n        assert_eq!(v.to_string_val(), \"\");\n    }\n\n    #[test]\n    fn test_to_number_uninitialized() {\n        let v = Value::Uninitialized;\n        assert_eq!(v.to_number(), 0.0);\n    }\n}\n","traces":[{"line":51,"address":[3216720],"length":1,"stats":{"Line":0}},{"line":52,"address":[2906963],"length":1,"stats":{"Line":0}},{"line":59,"address":[2158800,2159122],"length":1,"stats":{"Line":11}},{"line":60,"address":[2158898,2159031,2158830],"length":1,"stats":{"Line":32}},{"line":61,"address":[2892462],"length":1,"stats":{"Line":5}},{"line":63,"address":[2903795],"length":1,"stats":{"Line":15}},{"line":69,"address":[2903520],"length":1,"stats":{"Line":1}},{"line":70,"address":[2545193],"length":1,"stats":{"Line":1}},{"line":79,"address":[2893376],"length":1,"stats":{"Line":11}},{"line":80,"address":[],"length":0,"stats":{"Line":10}},{"line":81,"address":[2904712],"length":1,"stats":{"Line":1}},{"line":82,"address":[2159683],"length":1,"stats":{"Line":10}},{"line":83,"address":[2893503],"length":1,"stats":{"Line":1}},{"line":84,"address":[2159755],"length":1,"stats":{"Line":1}},{"line":90,"address":[2893568],"length":1,"stats":{"Line":5}},{"line":91,"address":[3214605],"length":1,"stats":{"Line":5}},{"line":92,"address":[2325096],"length":1,"stats":{"Line":4}},{"line":93,"address":[3214679],"length":1,"stats":{"Line":6}},{"line":94,"address":[2546612],"length":1,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":8}},{"line":101,"address":[2892640],"length":1,"stats":{"Line":9}},{"line":102,"address":[2159169],"length":1,"stats":{"Line":16}},{"line":107,"address":[2190192],"length":1,"stats":{"Line":3}},{"line":108,"address":[2190215],"length":1,"stats":{"Line":3}},{"line":109,"address":[2190279],"length":1,"stats":{"Line":0}},{"line":110,"address":[2546126],"length":1,"stats":{"Line":1}},{"line":111,"address":[2904539],"length":1,"stats":{"Line":2}},{"line":112,"address":[3214348],"length":1,"stats":{"Line":0}},{"line":117,"address":[2892848],"length":1,"stats":{"Line":7}},{"line":118,"address":[2892892],"length":1,"stats":{"Line":5}},{"line":119,"address":[2904220],"length":1,"stats":{"Line":2}},{"line":120,"address":[2545911],"length":1,"stats":{"Line":5}},{"line":121,"address":[2904282],"length":1,"stats":{"Line":6}},{"line":122,"address":[2904309],"length":1,"stats":{"Line":4}},{"line":128,"address":[3213216],"length":1,"stats":{"Line":0}},{"line":129,"address":[2892197],"length":1,"stats":{"Line":0}},{"line":134,"address":[2892688],"length":1,"stats":{"Line":2}},{"line":135,"address":[3213717],"length":1,"stats":{"Line":2}},{"line":140,"address":[2324432,2324496],"length":1,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":15}},{"line":146,"address":[2547968,2548590,2548584],"length":1,"stats":{"Line":0}},{"line":147,"address":[2895089],"length":1,"stats":{"Line":0}},{"line":148,"address":[2906412],"length":1,"stats":{"Line":0}},{"line":149,"address":[2548452,2548075],"length":1,"stats":{"Line":0}},{"line":150,"address":[2895254],"length":1,"stats":{"Line":0}},{"line":151,"address":[3216423],"length":1,"stats":{"Line":0}},{"line":158,"address":[2186510,2186504,2186208],"length":1,"stats":{"Line":6}},{"line":160,"address":[2541737,2541691],"length":1,"stats":{"Line":14}},{"line":161,"address":[2320633],"length":1,"stats":{"Line":8}},{"line":162,"address":[2900073],"length":1,"stats":{"Line":5}},{"line":163,"address":[2900084],"length":1,"stats":{"Line":6}},{"line":166,"address":[2155463,2155358],"length":1,"stats":{"Line":2}},{"line":175,"address":[2320864],"length":1,"stats":{"Line":4}},{"line":176,"address":[2155671],"length":1,"stats":{"Line":4}},{"line":177,"address":[2186604],"length":1,"stats":{"Line":5}},{"line":180,"address":[3212224,3210144,3210186],"length":1,"stats":{"Line":11}},{"line":181,"address":[2321082,2323045,2323032],"length":1,"stats":{"Line":4}},{"line":184,"address":[2186642],"length":1,"stats":{"Line":4}},{"line":185,"address":[3210347],"length":1,"stats":{"Line":0}},{"line":188,"address":[2155895],"length":1,"stats":{"Line":4}},{"line":191,"address":[2900575,2900737,2900625,2900830],"length":1,"stats":{"Line":14}},{"line":192,"address":[2321398,2321411,2321275],"length":1,"stats":{"Line":2}},{"line":195,"address":[2542300],"length":1,"stats":{"Line":4}},{"line":198,"address":[2188670,2186852,2187138,2187096],"length":1,"stats":{"Line":18}},{"line":199,"address":[2902414,2902435,2900978],"length":1,"stats":{"Line":8}},{"line":200,"address":[2891158],"length":1,"stats":{"Line":4}},{"line":204,"address":[2321450,2321626],"length":1,"stats":{"Line":4}},{"line":205,"address":[2156508,2156468],"length":1,"stats":{"Line":2}},{"line":206,"address":[2156529,2156671,2156506],"length":1,"stats":{"Line":5}},{"line":207,"address":[2187572,2187521],"length":1,"stats":{"Line":2}},{"line":208,"address":[2187559],"length":1,"stats":{"Line":2}},{"line":213,"address":[2890108,2889759,2890229],"length":1,"stats":{"Line":7}},{"line":214,"address":[2187677],"length":1,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[3211502,3211402,3211342,3211583],"length":1,"stats":{"Line":4}},{"line":217,"address":[2543524,2543511,2543403],"length":1,"stats":{"Line":2}},{"line":219,"address":[2890351,2890590],"length":1,"stats":{"Line":1}},{"line":220,"address":[2157290,2157424],"length":1,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[2188086],"length":1,"stats":{"Line":0}},{"line":229,"address":[2321921],"length":1,"stats":{"Line":2}},{"line":230,"address":[2890834],"length":1,"stats":{"Line":1}},{"line":234,"address":[2157480],"length":1,"stats":{"Line":3}},{"line":235,"address":[2890925,2890969,2891048],"length":1,"stats":{"Line":9}},{"line":236,"address":[2891073],"length":1,"stats":{"Line":3}},{"line":237,"address":[2902387],"length":1,"stats":{"Line":3}},{"line":241,"address":[2902260],"length":1,"stats":{"Line":1}},{"line":246,"address":[2157840],"length":1,"stats":{"Line":17}},{"line":247,"address":[],"length":0,"stats":{"Line":11}},{"line":248,"address":[2188796],"length":1,"stats":{"Line":17}},{"line":249,"address":[2157951],"length":1,"stats":{"Line":3}},{"line":253,"address":[2391120,2391136],"length":1,"stats":{"Line":25}},{"line":254,"address":[2188898],"length":1,"stats":{"Line":5}},{"line":258,"address":[2891367,2891442,2891497],"length":1,"stats":{"Line":31}},{"line":259,"address":[2323309],"length":1,"stats":{"Line":2}},{"line":261,"address":[3212533],"length":1,"stats":{"Line":20}},{"line":265,"address":[3212543],"length":1,"stats":{"Line":19}},{"line":266,"address":[2544466],"length":1,"stats":{"Line":20}},{"line":267,"address":[2902901,2902799],"length":1,"stats":{"Line":39}},{"line":268,"address":[2158400],"length":1,"stats":{"Line":15}},{"line":269,"address":[3212866,3212736],"length":1,"stats":{"Line":42}},{"line":270,"address":[2189435,2189367],"length":1,"stats":{"Line":6}},{"line":271,"address":[2544821,2544893,2544809,2544936],"length":1,"stats":{"Line":12}},{"line":272,"address":[2891970],"length":1,"stats":{"Line":2}},{"line":274,"address":[2544947,2544912],"length":1,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":3}},{"line":276,"address":[2545088],"length":1,"stats":{"Line":3}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[2903163,2903179],"length":1,"stats":{"Line":1}},{"line":282,"address":[2891852],"length":1,"stats":{"Line":21}},{"line":286,"address":[2323570],"length":1,"stats":{"Line":3}},{"line":290,"address":[2898672,2899851,2899857],"length":1,"stats":{"Line":7}},{"line":291,"address":[3208480],"length":1,"stats":{"Line":6}},{"line":292,"address":[2898774],"length":1,"stats":{"Line":1}},{"line":294,"address":[2887482],"length":1,"stats":{"Line":7}},{"line":295,"address":[2887564,2888606],"length":1,"stats":{"Line":2}},{"line":299,"address":[2887533],"length":1,"stats":{"Line":6}},{"line":301,"address":[2898999,2899248],"length":1,"stats":{"Line":14}},{"line":302,"address":[2899291],"length":1,"stats":{"Line":8}},{"line":305,"address":[2540764],"length":1,"stats":{"Line":2}},{"line":307,"address":[3208982,3209171],"length":1,"stats":{"Line":6}},{"line":308,"address":[2888284,2888238],"length":1,"stats":{"Line":5}},{"line":309,"address":[3209376],"length":1,"stats":{"Line":2}},{"line":310,"address":[2888443,2888421],"length":1,"stats":{"Line":2}},{"line":312,"address":[2888400,2888433],"length":1,"stats":{"Line":5}},{"line":314,"address":[2541156],"length":1,"stats":{"Line":0}},{"line":318,"address":[2887591],"length":1,"stats":{"Line":0}},{"line":323,"address":[3215409,3215415,3214784],"length":1,"stats":{"Line":7}},{"line":324,"address":[2893790],"length":1,"stats":{"Line":8}},{"line":325,"address":[3214825],"length":1,"stats":{"Line":3}},{"line":328,"address":[2893821],"length":1,"stats":{"Line":7}},{"line":329,"address":[2546769],"length":1,"stats":{"Line":8}},{"line":330,"address":[2905113],"length":1,"stats":{"Line":7}},{"line":331,"address":[2905219,2905141],"length":1,"stats":{"Line":11}},{"line":332,"address":[2546837,2546885],"length":1,"stats":{"Line":3}},{"line":335,"address":[2894359,2893896],"length":1,"stats":{"Line":10}},{"line":336,"address":[2546956,2547112],"length":1,"stats":{"Line":12}},{"line":337,"address":[2547284,2547224],"length":1,"stats":{"Line":8}},{"line":340,"address":[3215046],"length":1,"stats":{"Line":5}},{"line":341,"address":[],"length":0,"stats":{"Line":3}},{"line":344,"address":[],"length":0,"stats":{"Line":16}}],"covered":124,"coverable":141},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","tests","cli.rs"],"content":"//! CLI integration tests for rawk\n//!\n//! These tests run the rawk binary and verify command-line behavior.\n\nuse std::process::Command;\nuse std::io::Write;\nuse tempfile::NamedTempFile;\n\n/// Run rawk with the given arguments and input, returning stdout\nfn run_rawk(args: \u0026[\u0026str], input: Option\u003c\u0026str\u003e) -\u003e Result\u003cString, String\u003e {\n    let mut cmd = Command::new(\"cargo\");\n    cmd.args([\"run\", \"--quiet\", \"--\"]);\n    cmd.args(args);\n\n    if let Some(input_str) = input {\n        cmd.stdin(std::process::Stdio::piped());\n    }\n    cmd.stdout(std::process::Stdio::piped());\n    cmd.stderr(std::process::Stdio::piped());\n\n    let mut child = cmd.spawn().map_err(|e| e.to_string())?;\n\n    if let Some(input_str) = input {\n        if let Some(mut stdin) = child.stdin.take() {\n            stdin.write_all(input_str.as_bytes()).map_err(|e| e.to_string())?;\n        }\n    }\n\n    let output = child.wait_with_output().map_err(|e| e.to_string())?;\n\n    if output.status.success() {\n        String::from_utf8(output.stdout).map_err(|e| e.to_string())\n    } else {\n        Err(String::from_utf8_lossy(\u0026output.stderr).to_string())\n    }\n}\n\n#[test]\nfn test_cli_help() {\n    let output = run_rawk(\u0026[\"--help\"], None).unwrap();\n    assert!(output.contains(\"Usage:\"));\n    assert!(output.contains(\"rawk\"));\n}\n\n#[test]\nfn test_cli_version() {\n    let output = run_rawk(\u0026[\"--version\"], None).unwrap();\n    assert!(output.contains(\"rawk\"));\n}\n\n#[test]\nfn test_cli_simple_program() {\n    let output = run_rawk(\u0026[\"BEGIN { print \\\"hello\\\" }\"], None).unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_cli_with_input() {\n    let output = run_rawk(\u0026[\"{ print $1 }\"], Some(\"a b c\")).unwrap();\n    assert_eq!(output, \"a\\n\");\n}\n\n#[test]\nfn test_cli_field_separator() {\n    let output = run_rawk(\u0026[\"-F:\", \"{ print $1 }\"], Some(\"a:b:c\")).unwrap();\n    assert_eq!(output, \"a\\n\");\n}\n\n#[test]\nfn test_cli_field_separator_attached() {\n    let output = run_rawk(\u0026[\"-F,\", \"{ print $2 }\"], Some(\"a,b,c\")).unwrap();\n    assert_eq!(output, \"b\\n\");\n}\n\n#[test]\nfn test_cli_variable() {\n    let output = run_rawk(\u0026[\"-v\", \"x=5\", \"BEGIN { print x }\"], None).unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_cli_program_file() {\n    let mut file = NamedTempFile::new().unwrap();\n    writeln!(file, r#\"BEGIN {{ print \"from file\" }}\"#).unwrap();\n\n    let path = file.path().to_str().unwrap();\n    let output = run_rawk(\u0026[\"-f\", path], None).unwrap();\n    assert_eq!(output, \"from file\\n\");\n}\n\n#[test]\nfn test_cli_posix_mode() {\n    // In posix mode, FPAT should not work\n    let output = run_rawk(\u0026[\"--posix\", \"BEGIN { print \\\"posix\\\" }\"], None).unwrap();\n    assert_eq!(output, \"posix\\n\");\n}\n\n#[test]\nfn test_cli_traditional_mode() {\n    let output = run_rawk(\u0026[\"--traditional\", \"BEGIN { print \\\"trad\\\" }\"], None).unwrap();\n    assert_eq!(output, \"trad\\n\");\n}\n\n#[test]\nfn test_cli_separator_end_of_options() {\n    // -- marks end of options, program comes before it\n    let output = run_rawk(\u0026[\"BEGIN { print \\\"test\\\" }\", \"--\"], None).unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n#[test]\nfn test_cli_stdin_dash() {\n    let output = run_rawk(\u0026[\"{ print }\", \"-\"], Some(\"hello\")).unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_cli_multiple_inputs() {\n    let mut file1 = NamedTempFile::new().unwrap();\n    writeln!(file1, \"a\").unwrap();\n    let mut file2 = NamedTempFile::new().unwrap();\n    writeln!(file2, \"b\").unwrap();\n\n    let path1 = file1.path().to_str().unwrap();\n    let path2 = file2.path().to_str().unwrap();\n    let output = run_rawk(\u0026[\"{ print }\", path1, path2], None).unwrap();\n    assert!(output.contains(\"a\") \u0026\u0026 output.contains(\"b\"));\n}\n\n#[test]\nfn test_cli_error_no_program() {\n    let result = run_rawk(\u0026[], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_unknown_option() {\n    let result = run_rawk(\u0026[\"--unknown\"], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_missing_f_arg() {\n    let result = run_rawk(\u0026[\"-f\"], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_missing_v_arg() {\n    let result = run_rawk(\u0026[\"-v\"], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_invalid_v_arg() {\n    let result = run_rawk(\u0026[\"-v\", \"invalid\"], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_missing_F_arg() {\n    let result = run_rawk(\u0026[\"-F\"], None);\n    assert!(result.is_err());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","tests","e2e.rs"],"content":"//! End-to-end tests for rawk\n//!\n//! These tests run complete AWK programs and verify the output matches expected results.\n\nuse std::io::{BufReader, Cursor};\n\nuse rawk::{Interpreter, Lexer, Parser};\n\n/// Run an AWK program with the given input and return the output\nfn run_awk(program: \u0026str, input: \u0026str) -\u003e Result\u003cString, String\u003e {\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().map_err(|e| e.to_string())?;\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse().map_err(|e| e.to_string())?;\n\n    let mut interpreter = Interpreter::new(\u0026ast);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        interpreter.run(inputs, \u0026mut output).map_err(|e| e.to_string())?;\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        interpreter.run(inputs, \u0026mut output).map_err(|e| e.to_string())?;\n    }\n\n    String::from_utf8(output).map_err(|e| e.to_string())\n}\n\n/// Run an AWK program with a custom field separator\nfn run_awk_with_fs(program: \u0026str, input: \u0026str, fs: \u0026str) -\u003e Result\u003cString, String\u003e {\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().map_err(|e| e.to_string())?;\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse().map_err(|e| e.to_string())?;\n\n    let mut interpreter = Interpreter::new(\u0026ast);\n    interpreter.set_fs(fs);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        interpreter.run(inputs, \u0026mut output).map_err(|e| e.to_string())?;\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        interpreter.run(inputs, \u0026mut output).map_err(|e| e.to_string())?;\n    }\n\n    String::from_utf8(output).map_err(|e| e.to_string())\n}\n\n// ============================================================================\n// Basic Output Tests\n// ============================================================================\n\n#[test]\nfn test_hello_world() {\n    let output = run_awk(r#\"BEGIN { print \"Hello, World!\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"Hello, World!\\n\");\n}\n\n#[test]\nfn test_print_number() {\n    let output = run_awk(\"BEGIN { print 42 }\", \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_print_float() {\n    let output = run_awk(\"BEGIN { print 3.14159 }\", \"\").unwrap();\n    assert_eq!(output, \"3.14159\\n\");\n}\n\n#[test]\nfn test_print_multiple_values() {\n    let output = run_awk(r#\"BEGIN { print \"a\", \"b\", \"c\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"a b c\\n\");\n}\n\n#[test]\nfn test_print_concatenation() {\n    let output = run_awk(r#\"BEGIN { print \"hello\" \"world\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"helloworld\\n\");\n}\n\n// ============================================================================\n// Field Access Tests\n// ============================================================================\n\n#[test]\nfn test_print_record() {\n    let output = run_awk(\"{ print $0 }\", \"hello world\").unwrap();\n    assert_eq!(output, \"hello world\\n\");\n}\n\n#[test]\nfn test_print_first_field() {\n    let output = run_awk(\"{ print $1 }\", \"one two three\").unwrap();\n    assert_eq!(output, \"one\\n\");\n}\n\n#[test]\nfn test_print_multiple_fields() {\n    let output = run_awk(\"{ print $1, $3 }\", \"one two three\").unwrap();\n    assert_eq!(output, \"one three\\n\");\n}\n\n#[test]\nfn test_print_nf() {\n    let output = run_awk(\"{ print NF }\", \"one two three four\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_print_last_field() {\n    let output = run_awk(\"{ print $NF }\", \"one two three four\").unwrap();\n    assert_eq!(output, \"four\\n\");\n}\n\n#[test]\nfn test_field_separator_colon() {\n    let output = run_awk_with_fs(\"{ print $1 }\", \"root:x:0:0:root:/root:/bin/bash\", \":\").unwrap();\n    assert_eq!(output, \"root\\n\");\n}\n\n#[test]\nfn test_field_separator_in_begin() {\n    let output = run_awk(\n        r#\"BEGIN { FS = \":\" } { print $1, $3 }\"#,\n        \"root:x:0:0:root:/root:/bin/bash\",\n    )\n    .unwrap();\n    assert_eq!(output, \"root 0\\n\");\n}\n\n#[test]\nfn test_multiple_lines() {\n    let output = run_awk(\"{ print $1 }\", \"one two\\nthree four\\nfive six\").unwrap();\n    assert_eq!(output, \"one\\nthree\\nfive\\n\");\n}\n\n// ============================================================================\n// Arithmetic Tests\n// ============================================================================\n\n#[test]\nfn test_addition() {\n    let output = run_awk(\"BEGIN { print 1 + 2 }\", \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_subtraction() {\n    let output = run_awk(\"BEGIN { print 10 - 3 }\", \"\").unwrap();\n    assert_eq!(output, \"7\\n\");\n}\n\n#[test]\nfn test_multiplication() {\n    let output = run_awk(\"BEGIN { print 6 * 7 }\", \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_division() {\n    let output = run_awk(\"BEGIN { print 15 / 3 }\", \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_modulo() {\n    let output = run_awk(\"BEGIN { print 17 % 5 }\", \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_exponentiation() {\n    let output = run_awk(\"BEGIN { print 2 ^ 10 }\", \"\").unwrap();\n    assert_eq!(output, \"1024\\n\");\n}\n\n#[test]\nfn test_operator_precedence() {\n    let output = run_awk(\"BEGIN { print 2 + 3 * 4 }\", \"\").unwrap();\n    assert_eq!(output, \"14\\n\");\n}\n\n#[test]\nfn test_parentheses() {\n    let output = run_awk(\"BEGIN { print (2 + 3) * 4 }\", \"\").unwrap();\n    assert_eq!(output, \"20\\n\");\n}\n\n#[test]\nfn test_unary_minus() {\n    let output = run_awk(\"BEGIN { print -5 }\", \"\").unwrap();\n    assert_eq!(output, \"-5\\n\");\n}\n\n#[test]\nfn test_unary_plus() {\n    let output = run_awk(\"BEGIN { x = -3; print +x }\", \"\").unwrap();\n    assert_eq!(output, \"-3\\n\");\n}\n\n// ============================================================================\n// Variable Tests\n// ============================================================================\n\n#[test]\nfn test_variable_assignment() {\n    let output = run_awk(\"BEGIN { x = 42; print x }\", \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_uninitialized_variable_numeric() {\n    let output = run_awk(\"BEGIN { print x + 1 }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_uninitialized_variable_string() {\n    let output = run_awk(r#\"BEGIN { print x \"\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_increment_prefix() {\n    let output = run_awk(\"BEGIN { x = 5; print ++x }\", \"\").unwrap();\n    assert_eq!(output, \"6\\n\");\n}\n\n#[test]\nfn test_increment_postfix() {\n    let output = run_awk(\"BEGIN { x = 5; print x++ }\", \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_decrement() {\n    let output = run_awk(\"BEGIN { x = 5; print --x, x-- }\", \"\").unwrap();\n    assert_eq!(output, \"4 4\\n\");\n}\n\n#[test]\nfn test_compound_assignment() {\n    let output = run_awk(\"BEGIN { x = 10; x += 5; x -= 3; x *= 2; print x }\", \"\").unwrap();\n    assert_eq!(output, \"24\\n\");\n}\n\n// ============================================================================\n// Comparison Tests\n// ============================================================================\n\n#[test]\nfn test_numeric_comparison() {\n    let output = run_awk(\"BEGIN { print (5 \u003e 3), (5 \u003c 3), (5 == 5) }\", \"\").unwrap();\n    assert_eq!(output, \"1 0 1\\n\");\n}\n\n#[test]\nfn test_string_comparison() {\n    let output = run_awk(r#\"BEGIN { print (\"abc\" \u003c \"def\"), (\"abc\" == \"abc\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 1\\n\");\n}\n\n#[test]\nfn test_numeric_string_comparison() {\n    // Both are numeric strings, should compare numerically\n    let output = run_awk(r#\"BEGIN { print (\"10\" \u003e \"9\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// ============================================================================\n// Control Flow Tests\n// ============================================================================\n\n#[test]\nfn test_if_true() {\n    let output = run_awk(r#\"BEGIN { if (1) print \"yes\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_if_false() {\n    let output = run_awk(r#\"BEGIN { if (0) print \"yes\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_if_else() {\n    // Use block syntax instead of semicolon before else\n    let output = run_awk(r#\"BEGIN { if (0) { print \"yes\" } else { print \"no\" } }\"#, \"\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n#[test]\nfn test_if_else_chain() {\n    // Use block syntax for if-else chain\n    let output = run_awk(\n        r#\"BEGIN { x = 2; if (x == 1) { print \"one\" } else if (x == 2) { print \"two\" } else { print \"other\" } }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"two\\n\");\n}\n\n#[test]\nfn test_while_loop() {\n    let output = run_awk(\"BEGIN { i = 0; while (i \u003c 3) { print i; i++ } }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n1\\n2\\n\");\n}\n\n#[test]\nfn test_for_loop() {\n    let output = run_awk(\"BEGIN { for (i = 1; i \u003c= 3; i++) print i }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n2\\n3\\n\");\n}\n\n#[test]\nfn test_do_while() {\n    let output = run_awk(\"BEGIN { i = 0; do { print i; i++ } while (i \u003c 3) }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n1\\n2\\n\");\n}\n\n#[test]\nfn test_break() {\n    let output = run_awk(\"BEGIN { for (i = 1; i \u003c= 10; i++) { if (i \u003e 3) break; print i } }\", \"\")\n        .unwrap();\n    assert_eq!(output, \"1\\n2\\n3\\n\");\n}\n\n#[test]\nfn test_continue() {\n    let output = run_awk(\n        \"BEGIN { for (i = 1; i \u003c= 5; i++) { if (i == 3) continue; print i } }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"1\\n2\\n4\\n5\\n\");\n}\n\n#[test]\nfn test_next() {\n    let output = run_awk(\"/skip/ { next } { print }\", \"line1\\nskip\\nline2\").unwrap();\n    assert_eq!(output, \"line1\\nline2\\n\");\n}\n\n// ============================================================================\n// Pattern Tests\n// ============================================================================\n\n#[test]\nfn test_begin_pattern() {\n    let output = run_awk(r#\"BEGIN { print \"start\" } { print \"line\" }\"#, \"a\\nb\").unwrap();\n    assert_eq!(output, \"start\\nline\\nline\\n\");\n}\n\n#[test]\nfn test_end_pattern() {\n    let output = run_awk(r#\"{ print \"line\" } END { print \"end\" }\"#, \"a\\nb\").unwrap();\n    assert_eq!(output, \"line\\nline\\nend\\n\");\n}\n\n#[test]\nfn test_regex_pattern() {\n    let output = run_awk(\"/error/ { print }\", \"info: ok\\nerror: fail\\ninfo: done\").unwrap();\n    assert_eq!(output, \"error: fail\\n\");\n}\n\n#[test]\nfn test_expression_pattern() {\n    let output = run_awk(\"$1 \u003e 5 { print }\", \"3 a\\n7 b\\n2 c\\n10 d\").unwrap();\n    assert_eq!(output, \"7 b\\n10 d\\n\");\n}\n\n#[test]\nfn test_negated_regex() {\n    let output = run_awk(\"!/skip/ { print }\", \"keep\\nskip\\nalso keep\").unwrap();\n    assert_eq!(output, \"keep\\nalso keep\\n\");\n}\n\n#[test]\nfn test_range_pattern() {\n    let output = run_awk(\"/start/,/end/ { print }\", \"before\\nstart\\nmiddle\\nend\\nafter\").unwrap();\n    assert_eq!(output, \"start\\nmiddle\\nend\\n\");\n}\n\n// ============================================================================\n// Array Tests\n// ============================================================================\n\n#[test]\nfn test_array_assignment() {\n    let output = run_awk(\"BEGIN { a[1] = 10; a[2] = 20; print a[1], a[2] }\", \"\").unwrap();\n    assert_eq!(output, \"10 20\\n\");\n}\n\n#[test]\nfn test_array_string_keys() {\n    let output =\n        run_awk(r#\"BEGIN { a[\"foo\"] = 1; a[\"bar\"] = 2; print a[\"foo\"], a[\"bar\"] }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 2\\n\");\n}\n\n#[test]\nfn test_array_in_operator() {\n    let output = run_awk(\n        r#\"BEGIN { a[1] = 1; print (1 in a), (2 in a) }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"1 0\\n\");\n}\n\n#[test]\nfn test_for_in_loop() {\n    let output = run_awk(\n        \"BEGIN { a[1]=1; a[2]=2; a[3]=3; sum=0; for (k in a) sum += a[k]; print sum }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"6\\n\");\n}\n\n#[test]\nfn test_delete_array_element() {\n    let output = run_awk(\n        \"BEGIN { a[1]=1; a[2]=2; delete a[1]; print (1 in a), (2 in a) }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"0 1\\n\");\n}\n\n#[test]\nfn test_word_count() {\n    let output = run_awk(\n        \"{ for (i=1; i\u003c=NF; i++) count[$i]++ } END { for (w in count) print w, count[w] }\",\n        \"a b a c b a\",\n    )\n    .unwrap();\n    // Order may vary, so check that we have the right counts\n    assert!(output.contains(\"a 3\"));\n    assert!(output.contains(\"b 2\"));\n    assert!(output.contains(\"c 1\"));\n}\n\n// ============================================================================\n// Built-in Function Tests\n// ============================================================================\n\n#[test]\nfn test_length() {\n    let output = run_awk(r#\"BEGIN { print length(\"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_length_no_arg() {\n    let output = run_awk(\"{ print length() }\", \"hello world\").unwrap();\n    assert_eq!(output, \"11\\n\");\n}\n\n#[test]\nfn test_substr() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 2, 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"ell\\n\");\n}\n\n#[test]\nfn test_substr_to_end() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"llo\\n\");\n}\n\n#[test]\nfn test_index() {\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"ll\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_index_not_found() {\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"x\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_split_manual() {\n    // split() requires special lvalue handling for the array argument\n    // For now, test field splitting which uses similar logic\n    let output = run_awk_with_fs(\"{ print $1, $2, $3 }\", \"a:b:c\", \":\").unwrap();\n    assert_eq!(output, \"a b c\\n\");\n}\n\n#[test]\nfn test_tolower() {\n    let output = run_awk(r#\"BEGIN { print tolower(\"HeLLo\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_toupper() {\n    let output = run_awk(r#\"BEGIN { print toupper(\"HeLLo\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"HELLO\\n\");\n}\n\n#[test]\nfn test_gsub() {\n    // gsub on $0 (default target)\n    // Note: Use string pattern instead of regex literal for now\n    let output = run_awk(r#\"{ gsub(\"o\", \"0\"); print }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"hell0 w0rld\\n\");\n}\n\n#[test]\nfn test_sub() {\n    // sub on $0 (default target)\n    // Note: Use string pattern instead of regex literal for now\n    let output = run_awk(r#\"{ sub(\"o\", \"0\"); print }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"hell0 world\\n\");\n}\n\n#[test]\nfn test_match() {\n    // Note: Use string pattern instead of regex literal for now\n    let output = run_awk(\n        r#\"BEGIN { print match(\"hello world\", \"wor\"), RSTART, RLENGTH }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"7 7 3\\n\");\n}\n\n#[test]\nfn test_sprintf() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%05d\", 42) }\"#, \"\").unwrap();\n    assert_eq!(output, \"00042\\n\");\n}\n\n#[test]\nfn test_sqrt() {\n    let output = run_awk(\"BEGIN { print sqrt(16) }\", \"\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_int() {\n    let output = run_awk(\"BEGIN { print int(3.7), int(-3.7) }\", \"\").unwrap();\n    assert_eq!(output, \"3 -3\\n\");\n}\n\n#[test]\nfn test_sin_cos() {\n    let output = run_awk(\"BEGIN { print int(sin(0) * 100), int(cos(0) * 100) }\", \"\").unwrap();\n    assert_eq!(output, \"0 100\\n\");\n}\n\n#[test]\nfn test_exp_log() {\n    let output = run_awk(\"BEGIN { print int(log(exp(1)) * 1000) }\", \"\").unwrap();\n    assert_eq!(output, \"1000\\n\");\n}\n\n// ============================================================================\n// Printf Tests\n// ============================================================================\n\n#[test]\nfn test_printf_string() {\n    let output = run_awk(r#\"BEGIN { printf \"%s\\n\", \"hello\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_printf_integer() {\n    let output = run_awk(r#\"BEGIN { printf \"%d\\n\", 42 }\"#, \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_printf_float() {\n    let output = run_awk(r#\"BEGIN { printf \"%.2f\\n\", 3.14159 }\"#, \"\").unwrap();\n    assert_eq!(output, \"3.14\\n\");\n}\n\n#[test]\nfn test_printf_width() {\n    let output = run_awk(r#\"BEGIN { printf \"%10s|\\n\", \"hi\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"        hi|\\n\");\n}\n\n#[test]\nfn test_printf_left_align() {\n    let output = run_awk(r#\"BEGIN { printf \"%-10s|\\n\", \"hi\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"hi        |\\n\");\n}\n\n#[test]\nfn test_printf_zero_pad() {\n    let output = run_awk(r#\"BEGIN { printf \"%05d\\n\", 42 }\"#, \"\").unwrap();\n    assert_eq!(output, \"00042\\n\");\n}\n\n#[test]\nfn test_printf_hex() {\n    let output = run_awk(r#\"BEGIN { printf \"%x %X\\n\", 255, 255 }\"#, \"\").unwrap();\n    assert_eq!(output, \"ff FF\\n\");\n}\n\n#[test]\nfn test_printf_octal() {\n    let output = run_awk(r#\"BEGIN { printf \"%o\\n\", 8 }\"#, \"\").unwrap();\n    assert_eq!(output, \"10\\n\");\n}\n\n#[test]\nfn test_printf_char() {\n    let output = run_awk(r#\"BEGIN { printf \"%c%c%c\\n\", 65, 66, 67 }\"#, \"\").unwrap();\n    assert_eq!(output, \"ABC\\n\");\n}\n\n#[test]\nfn test_printf_percent() {\n    let output = run_awk(r#\"BEGIN { printf \"100%%\\n\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"100%\\n\");\n}\n\n// ============================================================================\n// User-Defined Function Tests\n// ============================================================================\n\n#[test]\nfn test_function_definition() {\n    let output = run_awk(\n        \"function double(x) { return x * 2 } BEGIN { print double(21) }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_function_with_side_effect() {\n    // Function that modifies a global variable\n    let output = run_awk(\n        r#\"function increment() { count++ } BEGIN { count = 0; increment(); increment(); print count }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_function_string_return() {\n    // Function that returns a formatted string\n    let output = run_awk(\n        r#\"function greet(name) { return \"Hello, \" name } BEGIN { print greet(\"World\") }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"Hello, World\\n\");\n}\n\n#[test]\nfn test_function_recursion() {\n    let output = run_awk(\n        \"function fact(n) { if (n \u003c= 1) return 1; return n * fact(n-1) } BEGIN { print fact(5) }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"120\\n\");\n}\n\n#[test]\nfn test_function_fibonacci() {\n    let output = run_awk(\n        \"function fib(n) { if (n \u003c= 2) return 1; return fib(n-1) + fib(n-2) } BEGIN { print fib(10) }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"55\\n\");\n}\n\n// ============================================================================\n// NR/FNR Tests\n// ============================================================================\n\n#[test]\nfn test_nr() {\n    let output = run_awk(\"{ print NR, $0 }\", \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"1 a\\n2 b\\n3 c\\n\");\n}\n\n#[test]\nfn test_nr_in_end() {\n    let output = run_awk(\"END { print NR }\", \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n// ============================================================================\n// Regex Match Operator Tests\n// ============================================================================\n\n#[test]\nfn test_match_operator() {\n    let output = run_awk(r#\"BEGIN { print (\"hello\" ~ /ell/) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_not_match_operator() {\n    let output = run_awk(r#\"BEGIN { print (\"hello\" !~ /xyz/) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_match_in_pattern() {\n    let output = run_awk(\"$1 ~ /^[0-9]+$/ { print }\", \"123 num\\nabc text\\n456 num\").unwrap();\n    assert_eq!(output, \"123 num\\n456 num\\n\");\n}\n\n// ============================================================================\n// Ternary Operator Tests\n// ============================================================================\n\n#[test]\nfn test_ternary_true() {\n    let output = run_awk(r#\"BEGIN { print (1 ? \"yes\" : \"no\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_ternary_false() {\n    let output = run_awk(r#\"BEGIN { print (0 ? \"yes\" : \"no\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n#[test]\nfn test_ternary_expression() {\n    let output = run_awk(\"BEGIN { x = 5; print (x \u003e 3 ? x * 2 : x / 2) }\", \"\").unwrap();\n    assert_eq!(output, \"10\\n\");\n}\n\n// ============================================================================\n// Logical Operator Tests\n// ============================================================================\n\n#[test]\nfn test_logical_and() {\n    let output = run_awk(\"BEGIN { print (1 \u0026\u0026 1), (1 \u0026\u0026 0), (0 \u0026\u0026 1), (0 \u0026\u0026 0) }\", \"\").unwrap();\n    assert_eq!(output, \"1 0 0 0\\n\");\n}\n\n#[test]\nfn test_logical_or() {\n    let output = run_awk(\"BEGIN { print (1 || 1), (1 || 0), (0 || 1), (0 || 0) }\", \"\").unwrap();\n    assert_eq!(output, \"1 1 1 0\\n\");\n}\n\n#[test]\nfn test_logical_not() {\n    let output = run_awk(\"BEGIN { print !0, !1, !!1 }\", \"\").unwrap();\n    assert_eq!(output, \"1 0 1\\n\");\n}\n\n#[test]\nfn test_short_circuit_and() {\n    // Second expression should not be evaluated\n    let output = run_awk(\"BEGIN { x = 0; if (0 \u0026\u0026 (x = 1)) {}; print x }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_short_circuit_or() {\n    // Second expression should not be evaluated\n    let output = run_awk(\"BEGIN { x = 0; if (1 || (x = 1)) {}; print x }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n// ============================================================================\n// Special Variable Tests\n// ============================================================================\n\n#[test]\nfn test_ofs() {\n    let output = run_awk(r#\"BEGIN { OFS = \",\" } { print $1, $2 }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"a,b\\n\");\n}\n\n#[test]\nfn test_modify_field_rebuilds_record() {\n    let output = run_awk(r#\"BEGIN { OFS = \":\" } { $2 = \"X\"; print $0 }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"a:X:c\\n\");\n}\n\n// ============================================================================\n// Complex Program Tests\n// ============================================================================\n\n#[test]\nfn test_sum_column() {\n    let output = run_awk(\"{ sum += $1 } END { print sum }\", \"1\\n2\\n3\\n4\\n5\").unwrap();\n    assert_eq!(output, \"15\\n\");\n}\n\n#[test]\nfn test_average() {\n    let output =\n        run_awk(\"{ sum += $1; count++ } END { print sum / count }\", \"10\\n20\\n30\").unwrap();\n    assert_eq!(output, \"20\\n\");\n}\n\n#[test]\nfn test_max_value() {\n    let output = run_awk(\n        \"NR == 1 || $1 \u003e max { max = $1 } END { print max }\",\n        \"5\\n3\\n8\\n2\\n9\\n1\",\n    )\n    .unwrap();\n    assert_eq!(output, \"9\\n\");\n}\n\n#[test]\nfn test_line_count() {\n    let output = run_awk(\"END { print NR }\", \"a\\nb\\nc\\nd\\ne\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_field_sum_per_line() {\n    let output = run_awk(\n        \"{ sum = 0; for (i = 1; i \u003c= NF; i++) sum += $i; print sum }\",\n        \"1 2 3\\n4 5 6\",\n    )\n    .unwrap();\n    assert_eq!(output, \"6\\n15\\n\");\n}\n\n#[test]\nfn test_reverse_fields() {\n    let output = run_awk(\n        r#\"{ for (i = NF; i \u003e= 1; i--) printf \"%s \", $i; print \"\" }\"#,\n        \"a b c\",\n    )\n    .unwrap();\n    assert_eq!(output, \"c b a \\n\");\n}\n\n#[test]\nfn test_duplicate_lines() {\n    let output = run_awk(\"seen[$0]++ == 0 { print }\", \"a\\nb\\na\\nc\\nb\\na\").unwrap();\n    assert_eq!(output, \"a\\nb\\nc\\n\");\n}\n\n// ============================================================================\n// Edge Cases\n// ============================================================================\n\n#[test]\nfn test_empty_input() {\n    let output = run_awk(\"{ print }\", \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_empty_line() {\n    let output = run_awk(\"{ print NF }\", \"\\n\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_whitespace_only() {\n    let output = run_awk(\"{ print NF }\", \"   \\t  \").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_nonexistent_field() {\n    let output = run_awk(\"{ print $100 }\", \"a b c\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_zero_field() {\n    let output = run_awk(\"{ print $0 }\", \"hello\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_negative_field() {\n    // Negative field access via expression\n    let output = run_awk(\"{ x = -1; print $x }\", \"hello world\").unwrap();\n    // Most AWKs return empty for negative fields\n    assert!(output == \"\\n\" || output == \"hello world\\n\");\n}\n\n// ============================================================================\n// REGEX LITERALS IN FUNCTION CALLS\n// ============================================================================\n\n#[test]\nfn test_sub_with_regex_literal() {\n    let output = run_awk(\"BEGIN { s = \\\"hello\\\"; sub(/l/, \\\"L\\\", s); print s }\", \"\").unwrap();\n    assert_eq!(output, \"heLlo\\n\");\n}\n\n#[test]\nfn test_gsub_with_regex_literal() {\n    let output = run_awk(\"BEGIN { s = \\\"hello\\\"; gsub(/l/, \\\"L\\\", s); print s }\", \"\").unwrap();\n    assert_eq!(output, \"heLLo\\n\");\n}\n\n#[test]\nfn test_match_with_regex_literal() {\n    let output = run_awk(\"BEGIN { print match(\\\"hello\\\", /l+/) }\", \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_match_rstart_rlength() {\n    let output = run_awk(\"BEGIN { match(\\\"hello world\\\", /wor/); print RSTART, RLENGTH }\", \"\").unwrap();\n    assert_eq!(output, \"7 3\\n\");\n}\n\n#[test]\nfn test_split_with_regex_literal() {\n    let output = run_awk(\"BEGIN { n = split(\\\"a:b:c\\\", arr, /:/); print n, arr[1], arr[2], arr[3] }\", \"\").unwrap();\n    assert_eq!(output, \"3 a b c\\n\");\n}\n\n// ============================================================================\n// RANDOM NUMBER GENERATION\n// ============================================================================\n\n#[test]\nfn test_rand() {\n    let output = run_awk(\"BEGIN { x = rand(); print (x \u003e= 0 \u0026\u0026 x \u003c 1) ? \\\"ok\\\" : \\\"fail\\\" }\", \"\").unwrap();\n    assert_eq!(output, \"ok\\n\");\n}\n\n#[test]\nfn test_srand() {\n    // srand returns the previous seed and sets deterministic random state\n    // We use parentheses because print X \u003e Y is output redirection, not comparison\n    let output = run_awk(\"BEGIN { srand(42); print (rand() \u003e 0) }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// ============================================================================\n// ELSE AFTER SEMICOLON\n// ============================================================================\n\n#[test]\nfn test_else_after_semicolon() {\n    let output = run_awk(\"BEGIN { if (1) print \\\"yes\\\"; else print \\\"no\\\" }\", \"\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_else_after_semicolon_false() {\n    let output = run_awk(\"BEGIN { if (0) print \\\"yes\\\"; else print \\\"no\\\" }\", \"\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n// ============================================================================\n// DELETE ENTIRE ARRAY\n// ============================================================================\n\n#[test]\nfn test_delete_entire_array() {\n    let output = run_awk(\"BEGIN { a[1]=1; a[2]=2; delete a; print length(a) }\", \"\").unwrap();\n    // After deleting, iterating should find nothing\n    let output2 = run_awk(\"BEGIN { a[1]=1; a[2]=2; delete a; for(i in a) c++; print c+0 }\", \"\").unwrap();\n    assert!(output == \"0\\n\" || output2 == \"0\\n\");\n}\n\n// ============================================================================\n// FUNCTION OUTPUT\n// ============================================================================\n\n#[test]\nfn test_function_with_print() {\n    let output = run_awk(\"\n        function greet(name) { print \\\"Hello, \\\" name }\n        BEGIN { greet(\\\"World\\\") }\n    \", \"\").unwrap();\n    assert_eq!(output, \"Hello, World\\n\");\n}\n\n#[test]\nfn test_function_with_multiple_prints() {\n    let output = run_awk(\"\n        function count_to(n) { for (i=1; i\u003c=n; i++) print i }\n        BEGIN { count_to(3) }\n    \", \"\").unwrap();\n    assert_eq!(output, \"1\\n2\\n3\\n\");\n}\n\n// ============================================================================\n// SPECIAL ARRAYS (partial - ARGC/ARGV/ENVIRON need main.rs)\n// ============================================================================\n\n#[test]\nfn test_argc_zero() {\n    // When no files given, ARGC should be at least 1 (program name)\n    let output = run_awk(\"BEGIN { print (ARGC \u003e= 0) }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// ============================================================================\n// OUTPUT REDIRECTION TESTS (run via run_rawk_binary, not library)\n// These tests verify the parser handles \u003e properly for redirection\n// ============================================================================\n\n#[test]\nfn test_print_redirect_parsing() {\n    // Verify that print \"hello\" \u003e \"file\" parses correctly\n    // (doesn't treat \u003e as comparison)\n    let result = run_awk(r#\"BEGIN { print \"test\" \u003e \"/dev/null\" }\"#, \"\");\n    assert!(result.is_ok(), \"print with \u003e redirection should parse\");\n}\n\n#[test]\nfn test_print_append_parsing() {\n    // Verify that print \"hello\" \u003e\u003e \"file\" parses correctly\n    let result = run_awk(r#\"BEGIN { print \"test\" \u003e\u003e \"/dev/null\" }\"#, \"\");\n    assert!(result.is_ok(), \"print with \u003e\u003e append should parse\");\n}\n\n#[test]\nfn test_print_pipe_parsing() {\n    // Verify that print \"hello\" | \"cmd\" parses correctly\n    let result = run_awk(r#\"BEGIN { print \"test\" | \"cat \u003e /dev/null\" }\"#, \"\");\n    assert!(result.is_ok(), \"print with | pipe should parse\");\n}\n\n#[test]\nfn test_printf_redirect_parsing() {\n    // Verify printf with redirection parses\n    let result = run_awk(r#\"BEGIN { printf \"%s\\n\", \"test\" \u003e \"/dev/null\" }\"#, \"\");\n    assert!(result.is_ok(), \"printf with \u003e redirection should parse\");\n}\n\n#[test]\nfn test_comparison_in_print_with_parens() {\n    // If you want comparison in print, use parentheses\n    let output = run_awk(\"BEGIN { print (5 \u003e 3) }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_comparison_in_print_less_than() {\n    // \u003c doesn't need parens since it's not used for redirection in AWK\n    let output = run_awk(\"BEGIN { print 5 \u003c 3 }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_comparison_ge_in_print() {\n    // \u003e= works without parens since it's unambiguous\n    let output = run_awk(\"BEGIN { print 5 \u003e= 3 }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// === Hex and Octal Escape Sequences ===\n\n#[test]\nfn test_hex_escape_sequence() {\n    // \\x41 is 'A'\n    let output = run_awk(r#\"BEGIN { print \"\\x41\\x42\\x43\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"ABC\\n\");\n}\n\n#[test]\nfn test_hex_escape_lowercase() {\n    // \\x61 is 'a'\n    let output = run_awk(r#\"BEGIN { print \"\\x61\\x62\\x63\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"abc\\n\");\n}\n\n#[test]\nfn test_octal_escape_sequence() {\n    // \\101 is 'A' in octal\n    let output = run_awk(r#\"BEGIN { print \"\\101\\102\\103\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"ABC\\n\");\n}\n\n#[test]\nfn test_octal_escape_tab_newline() {\n    // \\011 is tab, \\012 is newline\n    let output = run_awk(r#\"BEGIN { print \"a\\011b\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"a\\tb\\n\");\n}\n\n#[test]\nfn test_mixed_escape_sequences() {\n    // Mix of hex and standard escapes\n    let output = run_awk(r#\"BEGIN { print \"\\x48ello\\n\\x57orld\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"Hello\\nWorld\\n\");\n}\n\n// === Paragraph Mode (RS = \"\") ===\n\n#[test]\nfn test_paragraph_mode_basic() {\n    let input = \"line1\\nline2\\n\\nline3\\nline4\\n\";\n    let output = run_awk(r#\"BEGIN { RS = \"\" } { print \"para:\", NR, $0 }\"#, input).unwrap();\n    // Should produce two paragraphs\n    assert!(output.contains(\"para: 1 line1\\nline2\"));\n    assert!(output.contains(\"para: 2 line3\\nline4\"));\n}\n\n#[test]\nfn test_paragraph_mode_multiple_blanks() {\n    // Multiple blank lines should count as one separator\n    let input = \"para1\\n\\n\\n\\npara2\\n\";\n    let output = run_awk(r#\"BEGIN { RS = \"\" } { print NR, $0 }\"#, input).unwrap();\n    let lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n    assert_eq!(lines.len(), 2);\n    assert!(output.contains(\"1 para1\"));\n    assert!(output.contains(\"2 para2\"));\n}\n\n#[test]\nfn test_paragraph_mode_nf() {\n    // In paragraph mode with default FS, fields are still whitespace-separated\n    let input = \"word1 word2\\nword3\\n\\nword4 word5\\n\";\n    let output = run_awk(r#\"BEGIN { RS = \"\" } { print NR, NF, $1, $NF }\"#, input).unwrap();\n    assert!(output.contains(\"1 3 word1 word3\"));\n    assert!(output.contains(\"2 2 word4 word5\"));\n}\n\n// === cmd | getline ===\n\n#[test]\nfn test_pipe_getline_basic() {\n    let output = run_awk(r#\"BEGIN { \"echo hello\" | getline x; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_pipe_getline_multiple() {\n    let output = run_awk(r#\"BEGIN {\n        while ((\"echo -e 'a\\nb\\nc'\" | getline line) \u003e 0) {\n            print \"got:\", line\n        }\n    }\"#, \"\").unwrap();\n    // The output depends on the shell's echo behavior\n    assert!(output.contains(\"got:\"));\n}\n\n#[test]\nfn test_pipe_getline_no_var() {\n    // Without var, getline sets $0\n    let output = run_awk(r#\"BEGIN { \"echo test\" | getline; print $0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n// === Array by Reference ===\n\n#[test]\nfn test_array_in_function() {\n    // Arrays should be passed by reference (modification visible outside)\n    let output = run_awk(r#\"\n        function modify(arr) { arr[1] = \"modified\" }\n        BEGIN {\n            a[1] = \"original\"\n            modify(a)\n            print a[1]\n        }\n    \"#, \"\").unwrap();\n    assert_eq!(output, \"modified\\n\");\n}\n\n// === FILENAME Variable ===\n\n#[test]\nfn test_filename_variable() {\n    // FILENAME should be set correctly\n    let output = run_awk(r#\"{ print FILENAME, $0 }\"#, \"test\").unwrap();\n    // When reading from stdin/input string, FILENAME may be empty\n    assert!(output.contains(\"test\"));\n}\n\n// === UTF-8 / Unicode Support ===\n\n#[test]\nfn test_utf8_length() {\n    // Length should count characters, not bytes\n    // \"hello\" is 5 chars, \"hllo\" is 5 chars, \"\" is 2 chars\n    let output = run_awk(r#\"BEGIN { print length(\"hello\"), length(\"hllo\"), length(\"\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"5 5 2\\n\");\n}\n\n#[test]\nfn test_utf8_substr() {\n    // Substr should use character positions\n    let output = run_awk(r#\"BEGIN { print substr(\"\", 2, 2) }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_utf8_index() {\n    // Index should return character position\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"6\\n\");\n}\n\n// === GAWK Extensions ===\n\n#[test]\nfn test_systime() {\n    // systime() should return a positive number (seconds since epoch)\n    let output = run_awk(r#\"BEGIN { print (systime() \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_strftime_basic() {\n    // strftime with explicit timestamp\n    let output = run_awk(r#\"BEGIN { print strftime(\"%Y-%m-%d\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1970-01-01\\n\");\n}\n\n#[test]\nfn test_strftime_time() {\n    // strftime for time\n    let output = run_awk(r#\"BEGIN { print strftime(\"%H:%M:%S\", 3661) }\"#, \"\").unwrap();\n    assert_eq!(output, \"01:01:01\\n\");\n}\n\n#[test]\nfn test_mktime() {\n    // mktime should parse date string to timestamp\n    let output = run_awk(r#\"BEGIN { print mktime(\"1970 1 1 0 0 0\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_mktime_date() {\n    // mktime with a specific date\n    let output = run_awk(r#\"BEGIN { print mktime(\"2000 1 1 0 0 0\") }\"#, \"\").unwrap();\n    // 2000-01-01 00:00:00 UTC = 946684800 seconds since epoch\n    assert_eq!(output, \"946684800\\n\");\n}\n\n#[test]\nfn test_gensub_global() {\n    // gensub with global replacement\n    let output = run_awk(r#\"BEGIN { print gensub(\"o\", \"0\", \"g\", \"hello world\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hell0 w0rld\\n\");\n}\n\n#[test]\nfn test_gensub_first() {\n    // gensub with first occurrence\n    let output = run_awk(r#\"BEGIN { print gensub(\"o\", \"0\", 1, \"hello world\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hell0 world\\n\");\n}\n\n#[test]\nfn test_gensub_nth() {\n    // gensub with nth occurrence\n    let output = run_awk(r#\"BEGIN { print gensub(\"o\", \"0\", 2, \"hello world\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello w0rld\\n\");\n}\n\n#[test]\nfn test_gensub_returns_original() {\n    // gensub returns result, doesn't modify original (unlike gsub)\n    let output = run_awk(r#\"BEGIN { x = \"hello\"; y = gensub(\"l\", \"L\", \"g\", x); print x, y }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello heLLo\\n\");\n}\n\n#[test]\nfn test_beginfile() {\n    // BEGINFILE is executed at start of each input\n    let output = run_awk(r#\"BEGINFILE { print \"start\" } { print $0 }\"#, \"a\\nb\\n\").unwrap();\n    assert!(output.starts_with(\"start\\n\"));\n    assert!(output.contains(\"a\\n\"));\n    assert!(output.contains(\"b\\n\"));\n}\n\n#[test]\nfn test_endfile() {\n    // ENDFILE is executed at end of each input\n    let output = run_awk(r#\"{ print $0 } ENDFILE { print \"done\" }\"#, \"x\\ny\\n\").unwrap();\n    assert!(output.ends_with(\"done\\n\"));\n}\n\n#[test]\nfn test_asort() {\n    // asort sorts array values\n    let output = run_awk(r#\"BEGIN {\n        a[1] = \"cherry\"\n        a[2] = \"apple\"\n        a[3] = \"banana\"\n        n = asort(a)\n        for (i = 1; i \u003c= n; i++) print a[i]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"apple\\nbanana\\ncherry\\n\");\n}\n\n#[test]\nfn test_asorti() {\n    // asorti sorts array indices\n    let output = run_awk(r#\"BEGIN {\n        a[\"cherry\"] = 1\n        a[\"apple\"] = 2\n        a[\"banana\"] = 3\n        n = asorti(a, b)\n        for (i = 1; i \u003c= n; i++) print b[i]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"apple\\nbanana\\ncherry\\n\");\n}\n\n#[test]\nfn test_patsplit() {\n    // patsplit extracts matching fields\n    let output = run_awk(r#\"BEGIN {\n        n = patsplit(\"the:quick:fox\", a, \"[a-z]+\")\n        for (i = 1; i \u003c= n; i++) print a[i]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"the\\nquick\\nfox\\n\");\n}\n\n// === FPAT and FIELDWIDTHS ===\n\n#[test]\nfn test_fpat_basic() {\n    // FPAT matches field content, not separators\n    let output = run_awk(r#\"BEGIN { FPAT = \"[^,]+\" } { print $1, $2 }\"#, \"hello,world\").unwrap();\n    assert_eq!(output, \"hello world\\n\");\n}\n\n#[test]\nfn test_fpat_word_pattern() {\n    // FPAT matches word characters\n    let output = run_awk(r#\"BEGIN { FPAT = \"[A-Za-z]+\" } { print $1, $2, $3 }\"#, \"Hello123World456Test\").unwrap();\n    assert_eq!(output, \"Hello World Test\\n\");\n}\n\n#[test]\nfn test_fieldwidths() {\n    // FIELDWIDTHS splits by character positions\n    let output = run_awk(r#\"BEGIN { FIELDWIDTHS = \"3 4 3\" } { print $1, $2, $3 }\"#, \"abcdefghij\").unwrap();\n    assert_eq!(output, \"abc defg hij\\n\");\n}\n\n#[test]\nfn test_fieldwidths_short_record() {\n    // FIELDWIDTHS handles records shorter than specified widths\n    let output = run_awk(r#\"BEGIN { FIELDWIDTHS = \"5 5 5\" } { print NF }\"#, \"abcdefgh\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_procinfo_version() {\n    // PROCINFO[\"version\"] should return the rawk version\n    let output = run_awk(r#\"BEGIN { print (PROCINFO[\"version\"] != \"\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_procinfo_pid() {\n    // PROCINFO[\"pid\"] should return a positive number\n    let output = run_awk(r#\"BEGIN { print (PROCINFO[\"pid\"] \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// === Additional Built-in Function Tests ===\n\n#[test]\nfn test_atan2() {\n    let output = run_awk(r#\"BEGIN { print int(atan2(1, 1) * 1000) }\"#, \"\").unwrap();\n    // atan2(1,1) = pi/4  0.785\n    assert!(output.trim().parse::\u003ci32\u003e().unwrap() \u003e 700);\n}\n\n#[test]\nfn test_exp() {\n    let output = run_awk(r#\"BEGIN { print int(exp(1) * 100) }\"#, \"\").unwrap();\n    // e  2.718\n    assert_eq!(output, \"271\\n\");\n}\n\n#[test]\nfn test_log() {\n    let output = run_awk(r#\"BEGIN { print int(log(10) * 100) }\"#, \"\").unwrap();\n    // ln(10)  2.302\n    assert_eq!(output, \"230\\n\");\n}\n\n#[test]\nfn test_system() {\n    let output = run_awk(r#\"BEGIN { ret = system(\"true\"); print ret }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_close_nonexistent() {\n    // close() on non-existent file returns -1\n    let output = run_awk(r#\"BEGIN { print close(\"nonexistent\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"-1\\n\");\n}\n\n#[test]\nfn test_fflush() {\n    // fflush() without args flushes everything\n    let output = run_awk(r#\"BEGIN { print \"test\"; fflush(); print \"done\" }\"#, \"\").unwrap();\n    assert!(output.contains(\"test\") \u0026\u0026 output.contains(\"done\"));\n}\n\n#[test]\nfn test_length_no_arg_with_record() {\n    let output = run_awk(r#\"{ print length() }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_substr_start_zero() {\n    // AWK treats start \u003c 1 as 1\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 0, 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"hel\\n\");\n}\n\n#[test]\nfn test_substr_no_length() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"llo\\n\");\n}\n\n#[test]\nfn test_match_no_match() {\n    let output = run_awk(r#\"BEGIN { print match(\"hello\", \"xyz\"), RSTART, RLENGTH }\"#, \"\").unwrap();\n    assert_eq!(output, \"0 0 -1\\n\");\n}\n\n#[test]\nfn test_split_default_fs() {\n    // split with no third arg uses FS\n    let output = run_awk(r#\"BEGIN { n = split(\"a b c\", arr); print n, arr[1] }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 a\\n\");\n}\n\n#[test]\nfn test_gsub_returns_count() {\n    let output = run_awk(r#\"BEGIN { x = \"aaa\"; n = gsub(\"a\", \"b\", x); print n, x }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 bbb\\n\");\n}\n\n#[test]\nfn test_sub_returns_count() {\n    let output = run_awk(r#\"BEGIN { x = \"aaa\"; n = sub(\"a\", \"b\", x); print n, x }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 baa\\n\");\n}\n\n#[test]\nfn test_gensub_default_target() {\n    // gensub with no 4th arg uses $0\n    let output = run_awk(r#\"{ print gensub(\"o\", \"0\", \"g\") }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"hell0 w0rld\\n\");\n}\n\n// === More Edge Cases ===\n\n#[test]\nfn test_multiple_patterns_same_line() {\n    let output = run_awk(r#\"/a/ { print \"A\" } /b/ { print \"B\" }\"#, \"ab\").unwrap();\n    assert_eq!(output, \"A\\nB\\n\");\n}\n\n#[test]\nfn test_field_beyond_nf() {\n    // Accessing field beyond NF returns empty string\n    let output = run_awk(r#\"{ print $100 == \"\" }\"#, \"a b\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_assign_to_field_extends_nf() {\n    let output = run_awk(r#\"{ $5 = \"x\"; print NF, $5 }\"#, \"a b\").unwrap();\n    assert_eq!(output, \"5 x\\n\");\n}\n\n#[test]\nfn test_nf_zero() {\n    // Empty line has NF = 0\n    let output = run_awk(r#\"{ print NF }\"#, \"\\n\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_negative_field_number() {\n    // In AWK, $-1 and other negative indices typically return $0\n    let output = run_awk(r#\"{ print $(-1) }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"a b c\\n\");  // Returns $0\n}\n\n#[test]\nfn test_array_multidim() {\n    let output = run_awk(r#\"BEGIN { a[1,2] = \"x\"; print a[1,2] }\"#, \"\").unwrap();\n    assert_eq!(output, \"x\\n\");\n}\n\n#[test]\nfn test_delete_entire_array_iteration() {\n    let output = run_awk(r#\"BEGIN { a[1]=1; a[2]=2; delete a; for(k in a) n++; print n+0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_uninitialized_numeric() {\n    let output = run_awk(r#\"BEGIN { print x + 5 }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_uninitialized_string() {\n    let output = run_awk(r#\"BEGIN { print x \"\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_numeric_string_gt_comparison() {\n    let output = run_awk(r#\"BEGIN { print (\"10\" \u003e \"9\") }\"#, \"\").unwrap();\n    // Numeric comparison: 10 \u003e 9\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_string_literal_comparison() {\n    let output = run_awk(r#\"BEGIN { print (\"abc\" \u003c \"abd\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_printf_width_precision() {\n    let output = run_awk(r#\"BEGIN { printf \"%10.3f\\n\", 3.14159 }\"#, \"\").unwrap();\n    assert!(output.contains(\"3.142\"));\n}\n\n#[test]\nfn test_printf_negative_width() {\n    let output = run_awk(r#\"BEGIN { printf \"%-5s|\\n\", \"ab\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"ab   |\\n\");\n}\n\n#[test]\nfn test_concatenation_with_number() {\n    let output = run_awk(r#\"BEGIN { print \"x\" 5 \"y\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"x5y\\n\");\n}\n\n#[test]\nfn test_regex_in_expression() {\n    // Bare regex matches against $0\n    let output = run_awk(r#\"{ print /hello/ }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_not_regex() {\n    let output = run_awk(r#\"{ print !/hello/ }\"#, \"goodbye world\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_do_while_false() {\n    // do-while always runs at least once\n    let output = run_awk(r#\"BEGIN { do { print \"x\" } while (0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"x\\n\");\n}\n\n#[test]\nfn test_for_empty_parts() {\n    let output = run_awk(r#\"BEGIN { i=0; for (;;) { if (++i \u003e 2) break; print i } }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n2\\n\");\n}\n\n#[test]\nfn test_return_no_value() {\n    let output = run_awk(r#\"function f() { return } BEGIN { x = f(); print x+0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_function_local_vars() {\n    // Extra params act as local variables\n    let output = run_awk(r#\"function f(a,    local) { local = 5; return local } BEGIN { print f(1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n// === More Coverage Tests ===\n\n#[test]\nfn test_nextfile() {\n    // nextfile skips to next input file\n    let output = run_awk(r#\"FNR == 2 { nextfile } { print }\"#, \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"a\\n\");\n}\n\n#[test]\nfn test_exit_with_code() {\n    // exit with a code - exit takes effect after current rule\n    let output = run_awk(r#\"BEGIN { exit 0 } BEGIN { print \"second begin\" }\"#, \"\").unwrap();\n    // Exit runs END rules, but stops further BEGIN/main processing\n    assert!(!output.contains(\"second begin\"));\n}\n\n#[test]\nfn test_print_redirect_truncate() {\n    // print to file (truncate mode)\n    let output = run_awk(r#\"BEGIN { print \"test\" \u003e \"/dev/null\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_print_redirect_append() {\n    // print to file (append mode)\n    let output = run_awk(r#\"BEGIN { print \"test\" \u003e\u003e \"/dev/null\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_print_redirect_pipe() {\n    // print through pipe\n    let output = run_awk(r#\"BEGIN { print \"hello\" | \"cat\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");  // output goes to pipe, not stdout\n}\n\n#[test]\nfn test_printf_redirect() {\n    let output = run_awk(r#\"BEGIN { printf \"test\\n\" \u003e \"/dev/null\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_getline_from_file() {\n    // getline from file\n    let output = run_awk(r#\"BEGIN { while ((getline line \u003c \"/etc/hostname\") \u003e 0) { print line; break } }\"#, \"\").unwrap();\n    assert!(!output.is_empty());\n}\n\n#[test]\nfn test_getline_from_pipe() {\n    let output = run_awk(r#\"BEGIN { \"echo test\" | getline x; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n#[test]\nfn test_getline_sets_nf() {\n    let output = run_awk(r#\"BEGIN { \"echo a b c\" | getline; print NF }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_strftime_formats() {\n    // Test various strftime format specifiers\n    let output = run_awk(r#\"BEGIN { print strftime(\"%Y\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1970\\n\");\n    \n    let output = run_awk(r#\"BEGIN { print strftime(\"%m\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"01\\n\");\n    \n    let output = run_awk(r#\"BEGIN { print strftime(\"%d\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"01\\n\");\n}\n\n#[test]\nfn test_strftime_weekday() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%a\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"Thu\\n\");  // 1970-01-01 was Thursday\n}\n\n#[test]\nfn test_strftime_month_name() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%b\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"Jan\\n\");\n}\n\n#[test]\nfn test_mktime_with_time() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"1970 1 1 1 0 0\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"3600\\n\");  // 1 hour = 3600 seconds\n}\n\n#[test]\nfn test_mktime_invalid() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"invalid\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"-1\\n\");\n}\n\n#[test]\nfn test_gensub_no_match() {\n    let output = run_awk(r#\"BEGIN { print gensub(\"x\", \"y\", \"g\", \"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_gensub_with_ampersand() {\n    let output = run_awk(r#\"BEGIN { print gensub(\"l\", \"[\u0026]\", \"g\", \"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"he[l][l]o\\n\");\n}\n\n#[test]\nfn test_asort_empty() {\n    let output = run_awk(r#\"BEGIN { n = asort(a); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_asorti_with_dest() {\n    let output = run_awk(r#\"BEGIN { a[\"z\"]=1; a[\"a\"]=2; n = asorti(a, b); print n, b[1] }\"#, \"\").unwrap();\n    assert_eq!(output, \"2 a\\n\");\n}\n\n#[test]\nfn test_patsplit_with_seps() {\n    let output = run_awk(r#\"BEGIN { \n        n = patsplit(\"a1b2c\", arr, \"[0-9]+\", seps)\n        print n, arr[1], arr[2], seps[0], seps[1]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"2 1 2 a b\\n\");\n}\n\n#[test]\nfn test_comparison_mixed_types() {\n    // String vs number comparison\n    let output = run_awk(r#\"BEGIN { print (\"10\" == 10) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_comparison_string_concat() {\n    // String comparison  \n    let output = run_awk(r#\"BEGIN { print (\"aa\" \u003c \"ab\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_regex_special_chars() {\n    let output = run_awk(r#\"/\\[test\\]/ { print \"found\" }\"#, \"[test]\").unwrap();\n    assert_eq!(output, \"found\\n\");\n}\n\n#[test]\nfn test_regex_case_sensitive() {\n    let output = run_awk(r#\"/Hello/ { print \"yes\" } !/Hello/ { print \"no\" }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n#[test]\nfn test_field_separator_regex() {\n    let output = run_awk(r#\"BEGIN { FS = \"[,;]\" } { print $2 }\"#, \"a,b;c\").unwrap();\n    assert_eq!(output, \"b\\n\");\n}\n\n#[test]\nfn test_ors() {\n    // ORS - output record separator (need to implement if not working)\n    let output = run_awk(r#\"{ printf \"%s;\", $0 }\"#, \"a\\nb\").unwrap();\n    assert_eq!(output, \"a;b;\");\n}\n\n#[test]\nfn test_subsep() {\n    let output = run_awk(r#\"BEGIN { a[1,2] = \"x\"; for (k in a) print k }\"#, \"\").unwrap();\n    assert!(output.contains(\"\\x1c\"));  // Default SUBSEP\n}\n\n#[test]\nfn test_custom_subsep() {\n    let output = run_awk(r#\"BEGIN { SUBSEP = \":\"; a[1,2] = \"x\"; for (k in a) print k }\"#, \"\").unwrap();\n    assert_eq!(output, \"1:2\\n\");\n}\n\n#[test]\nfn test_convfmt() {\n    let output = run_awk(r#\"BEGIN { CONVFMT = \"%.2f\"; x = 3.14159; print x \"\" }\"#, \"\").unwrap();\n    assert!(output.contains(\"3.14\"));\n}\n\n#[test]\nfn test_ofmt() {\n    let output = run_awk(r#\"BEGIN { OFMT = \"%.2f\"; print 3.14159 }\"#, \"\").unwrap();\n    assert!(output.contains(\"3.14\"));\n}\n\n#[test]\nfn test_environ() {\n    let output = run_awk(r#\"BEGIN { print (ENVIRON[\"PATH\"] != \"\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_argv_access() {\n    // In our test harness ARGV may be empty, just test it doesn't crash\n    let output = run_awk(r#\"BEGIN { print ARGV[0] \"\" }\"#, \"\").unwrap();\n    assert!(output.ends_with(\"\\n\"));\n}\n\n#[test]\nfn test_argc_type() {\n    // ARGC should be a number\n    let output = run_awk(r#\"BEGIN { print ARGC + 0 \u003e= 0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_fnr_vs_nr() {\n    let output = run_awk(r#\"{ print NR, FNR }\"#, \"a\\nb\\nc\").unwrap();\n    assert!(output.contains(\"1 1\") \u0026\u0026 output.contains(\"2 2\") \u0026\u0026 output.contains(\"3 3\"));\n}\n\n#[test]\nfn test_modify_nf() {\n    // Setting NF to smaller value truncates fields\n    let output = run_awk(r#\"{ NF = 2; print $0 }\"#, \"a b c d\").unwrap();\n    assert_eq!(output, \"a b\\n\");\n}\n\n#[test]\nfn test_extend_nf() {\n    // Setting NF to larger value extends fields\n    let output = run_awk(r#\"{ NF = 5; print NF, $5 == \"\" }\"#, \"a b\").unwrap();\n    assert_eq!(output, \"5 1\\n\");\n}\n\n#[test]\nfn test_dollar_zero_assignment() {\n    // Assigning to $0 re-splits\n    let output = run_awk(r#\"{ $0 = \"x y z\"; print $2 }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"y\\n\");\n}\n\n#[test]\nfn test_expr_pattern() {\n    // Expression as pattern\n    let output = run_awk(r#\"NR == 2 { print \"second\" }\"#, \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"second\\n\");\n}\n\n#[test]\nfn test_beginfile_endfile() {\n    let output = run_awk(r#\"BEGINFILE { print \"start\" } ENDFILE { print \"end\" }\"#, \"test\").unwrap();\n    assert!(output.contains(\"start\") \u0026\u0026 output.contains(\"end\"));\n}\n\n#[test]\nfn test_exponentiation_negative() {\n    let output = run_awk(r#\"BEGIN { print 2^(-2) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0.25\\n\");\n}\n\n#[test]\nfn test_modulo_negative() {\n    let output = run_awk(r#\"BEGIN { print -7 % 3 }\"#, \"\").unwrap();\n    assert_eq!(output, \"-1\\n\");\n}\n\n#[test]\nfn test_division_by_zero() {\n    // Division by zero in AWK typically returns inf\n    let output = run_awk(r#\"BEGIN { x = 1/0; print (x \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");  // inf \u003e 0\n}\n\n#[test]\nfn test_string_to_number_leading_whitespace() {\n    let output = run_awk(r#\"BEGIN { print \"  42\" + 0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_string_to_number_trailing_text() {\n    let output = run_awk(r#\"BEGIN { print \"42abc\" + 0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_empty_regex() {\n    // Empty regex matches anything\n    let output = run_awk(r#\"// { print \"match\" }\"#, \"test\").unwrap();\n    assert_eq!(output, \"match\\n\");\n}\n\n#[test]\nfn test_match_operator_with_var() {\n    let output = run_awk(r#\"{ if ($0 ~ \"test\") print \"yes\" }\"#, \"test\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_not_match_with_string() {\n    let output = run_awk(r#\"{ if ($0 !~ \"xyz\") print \"no match\" }\"#, \"test\").unwrap();\n    assert_eq!(output, \"no match\\n\");\n}\n\n#[test]\nfn test_in_with_multi_subscript() {\n    // Use SUBSEP to form the key for multi-dimensional access\n    let output = run_awk(r#\"BEGIN { a[1,2]=1; key = 1 SUBSEP 2; print (key in a) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_delete_non_existent() {\n    let output = run_awk(r#\"BEGIN { delete a[1]; print (1 in a) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_printf_all_formats() {\n    let output = run_awk(r#\"BEGIN { printf \"%c%d%e%f%g%o%s%x%%\\n\", 65, 42, 1.5, 2.5, 3.5, 8, \"hi\", 255 }\"#, \"\").unwrap();\n    assert!(output.contains(\"A\") \u0026\u0026 output.contains(\"42\") \u0026\u0026 output.contains(\"hi\") \u0026\u0026 output.contains(\"ff\") \u0026\u0026 output.contains(\"%\"));\n}\n\n#[test]\nfn test_printf_fixed_width() {\n    let output = run_awk(r#\"BEGIN { printf \"%5s\\n\", \"ab\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"   ab\\n\");\n}\n\n#[test]\nfn test_printf_fixed_precision() {\n    let output = run_awk(r#\"BEGIN { printf \"%.2f\\n\", 3.14159 }\"#, \"\").unwrap();\n    assert_eq!(output, \"3.14\\n\");\n}\n\n#[test]\nfn test_short_circuit_and_false() {\n    // Second operand should not be evaluated\n    let output = run_awk(r#\"BEGIN { x = 0; if (0 \u0026\u0026 (x = 1)) {} print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_short_circuit_or_true() {\n    // Second operand should not be evaluated\n    let output = run_awk(r#\"BEGIN { x = 0; if (1 || (x = 1)) {} print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_compound_assignment_modulo() {\n    let output = run_awk(r#\"BEGIN { x = 10; x %= 3; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_compound_assignment_power() {\n    let output = run_awk(r#\"BEGIN { x = 2; x ^= 3; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"8\\n\");\n}\n\n#[test]\nfn test_compound_assignment_divide() {\n    let output = run_awk(r#\"BEGIN { x = 10; x /= 2; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_nested_function_call() {\n    let output = run_awk(r#\"BEGIN { print substr(toupper(\"hello\"), 2, 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"ELL\\n\");\n}\n\n#[test]\nfn test_gsub_on_field() {\n    let output = run_awk(r#\"{ gsub(/o/, \"0\", $1); print $0 }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"hell0 world\\n\");\n}\n\n#[test]\nfn test_split_empty_string() {\n    let output = run_awk(r#\"BEGIN { n = split(\"\", a); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_index_empty() {\n    let output = run_awk(r#\"BEGIN { print index(\"\", \"x\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_substr_beyond_length() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hi\", 10) }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_multiple_begin() {\n    let output = run_awk(r#\"BEGIN { x = 1 } BEGIN { x += 1 } BEGIN { print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_multiple_end() {\n    let output = run_awk(r#\"END { x = 1 } END { x += 1 } END { print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_default_action() {\n    // Pattern without action prints $0\n    let output = run_awk(r#\"/test/\"#, \"test\").unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n#[test]\nfn test_empty_pattern_action() {\n    // No pattern means always match\n    let output = run_awk(r#\"{ print \"line\" }\"#, \"a\\nb\").unwrap();\n    assert_eq!(output, \"line\\nline\\n\");\n}\n\n// === More builtin coverage ===\n\n#[test]\nfn test_sin_cos_zero() {\n    let output = run_awk(r#\"BEGIN { print int(sin(0)), int(cos(0)) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0 1\\n\");\n}\n\n#[test]\nfn test_atan2_quadrants() {\n    let output = run_awk(r#\"BEGIN { print (atan2(1, 1) \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_exp_log_inverse() {\n    let output = run_awk(r#\"BEGIN { x = 5; print int(log(exp(x))) }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_sqrt_perfect() {\n    let output = run_awk(r#\"BEGIN { print sqrt(16) }\"#, \"\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_int_positive() {\n    let output = run_awk(r#\"BEGIN { print int(5.9) }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_int_negative() {\n    let output = run_awk(r#\"BEGIN { print int(-5.9) }\"#, \"\").unwrap();\n    assert_eq!(output, \"-5\\n\");\n}\n\n#[test]\nfn test_array_count_loop() {\n    // Count array elements with for-in\n    let output = run_awk(r#\"BEGIN { a[1]=1; a[2]=2; a[3]=3; for(k in a) n++; print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_gsub_no_third_arg() {\n    // gsub without third arg uses $0\n    let output = run_awk(r#\"{ gsub(\"o\", \"0\"); print }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"hell0\\n\");\n}\n\n#[test]\nfn test_sub_no_third_arg() {\n    let output = run_awk(r#\"{ sub(\"o\", \"0\"); print }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"hell0\\n\");\n}\n\n#[test]\nfn test_match_positions() {\n    let output = run_awk(r#\"BEGIN { match(\"hello world\", \"wor\"); print RSTART, RLENGTH }\"#, \"\").unwrap();\n    assert_eq!(output, \"7 3\\n\");\n}\n\n#[test]\nfn test_split_with_regex() {\n    let output = run_awk(r#\"BEGIN { n = split(\"a1b2c\", a, \"[0-9]\"); print n, a[1], a[3] }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 a c\\n\");\n}\n\n#[test]\nfn test_sprintf_octal() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%o\", 8) }\"#, \"\").unwrap();\n    assert_eq!(output, \"10\\n\");\n}\n\n#[test]\nfn test_sprintf_hex_upper() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%X\", 255) }\"#, \"\").unwrap();\n    assert_eq!(output, \"FF\\n\");\n}\n\n#[test]\nfn test_sprintf_char() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%c\", 65) }\"#, \"\").unwrap();\n    assert_eq!(output, \"A\\n\");\n}\n\n#[test]\nfn test_sprintf_scientific() {\n    let output = run_awk(r#\"BEGIN { s = sprintf(\"%e\", 1234.5); print (s ~ \"e\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_tolower_mixed() {\n    let output = run_awk(r#\"BEGIN { print tolower(\"HeLLo WoRLD\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello world\\n\");\n}\n\n#[test]\nfn test_toupper_mixed() {\n    let output = run_awk(r#\"BEGIN { print toupper(\"HeLLo WoRLD\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"HELLO WORLD\\n\");\n}\n\n#[test]\nfn test_index_missing() {\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"xyz\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_substr_negative_length() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 2, -1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_system_false() {\n    let output = run_awk(r#\"BEGIN { print system(\"false\") }\"#, \"\").unwrap();\n    assert!(output.trim() != \"0\");  // false returns non-zero\n}\n\n#[test]\nfn test_rand_range() {\n    let output = run_awk(r#\"BEGIN { x = rand(); print (x \u003e= 0 \u0026\u0026 x \u003c 1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_srand_returns_prev() {\n    let output = run_awk(r#\"BEGIN { srand(1); prev = srand(2); print (prev \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_close_success() {\n    let output = run_awk(r#\"BEGIN { print \"test\" \u003e \"/tmp/rawk_test_close\"; print close(\"/tmp/rawk_test_close\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n// === More stmt coverage ===\n\n#[test]\nfn test_if_else_block() {\n    let output = run_awk(r#\"BEGIN { if (0) { print \"yes\" } else { print \"no\" } }\"#, \"\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n#[test]\nfn test_nested_if() {\n    let output = run_awk(r#\"BEGIN { if (1) if (1) print \"deep\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"deep\\n\");\n}\n\n#[test]\nfn test_for_no_body() {\n    let output = run_awk(r#\"BEGIN { for (i=0; i\u003c3; i++); print i }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_while_never_runs() {\n    let output = run_awk(r#\"BEGIN { while (0) print \"never\"; print \"done\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"done\\n\");\n}\n\n#[test]\nfn test_getline_eof() {\n    let output = run_awk(r#\"BEGIN { ret = getline \u003c \"/dev/null\"; print ret }\"#, \"\").unwrap();\n    // /dev/null returns EOF immediately\n    assert!(output.trim() == \"0\" || output.trim() == \"-1\");\n}\n\n#[test]\nfn test_printf_no_args() {\n    let output = run_awk(r#\"BEGIN { printf \"hello\\n\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_printf_literal_percent() {\n    let output = run_awk(r#\"BEGIN { printf \"50%%\\n\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"50%\\n\");\n}\n\n#[test]\nfn test_print_empty() {\n    // print with no args prints $0\n    let output = run_awk(r#\"{ print }\"#, \"test\").unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n#[test]\nfn test_simulated_2d_array() {\n    // AWK simulates multi-dimensional arrays with SUBSEP\n    let output = run_awk(r#\"BEGIN { a[1,2] = \"x\"; print a[1,2] }\"#, \"\").unwrap();\n    assert_eq!(output, \"x\\n\");\n}\n\n#[test]\nfn test_array_in_loop() {\n    let output = run_awk(r#\"BEGIN { for (i=1; i\u003c=3; i++) a[i]=i*2; print a[2] }\"#, \"\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_function_array_param() {\n    let output = run_awk(r#\"function f(arr) { return arr[1] } BEGIN { a[1]=\"x\"; print f(a) }\"#, \"\").unwrap();\n    assert_eq!(output, \"x\\n\");\n}\n\n#[test]\nfn test_function_modify_global() {\n    let output = run_awk(r#\"function f() { x = 5 } BEGIN { f(); print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_expr_as_stmt() {\n    let output = run_awk(r#\"BEGIN { 1+1; print \"ok\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"ok\\n\");\n}\n\n#[test]\nfn test_empty_block() {\n    let output = run_awk(r#\"BEGIN { } { } END { print \"end\" }\"#, \"input\").unwrap();\n    assert_eq!(output, \"end\\n\");\n}\n\n// === More lexer edge cases ===\n\n#[test]\nfn test_very_long_string() {\n    let long = \"a\".repeat(1000);\n    let program = format!(r#\"BEGIN {{ print \"{}\" }}\"#, long);\n    let output = run_awk(\u0026program, \"\").unwrap();\n    assert_eq!(output.len(), 1001);  // 1000 chars + newline\n}\n\n#[test]\nfn test_unicode_string() {\n    let output = run_awk(r#\"BEGIN { print \"hello \" }\"#, \"\").unwrap();\n    assert!(output.contains(\"\"));\n}\n\n#[test]\nfn test_multiple_statements_one_line() {\n    let output = run_awk(r#\"BEGIN { x=1; y=2; z=3; print x+y+z }\"#, \"\").unwrap();\n    assert_eq!(output, \"6\\n\");\n}\n\n#[test]\nfn test_regex_empty_match() {\n    let output = run_awk(r#\"BEGIN { print match(\"test\", \".*\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_field_zero_assign() {\n    let output = run_awk(r#\"{ $0 = toupper($0); print }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"HELLO\\n\");\n}\n\n#[test]\nfn test_complex_expression() {\n    let output = run_awk(r#\"BEGIN { print ((1+2)*3-4)/2 }\"#, \"\").unwrap();\n    assert_eq!(output, \"2.5\\n\");\n}\n\n#[test]\nfn test_chained_comparisons() {\n    let output = run_awk(r#\"BEGIN { print (1 \u003c 2) \u0026\u0026 (2 \u003c 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_ternary_nested() {\n    let output = run_awk(r#\"BEGIN { print 1 ? (0 ? \"a\" : \"b\") : \"c\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"b\\n\");\n}\n\n#[test]\nfn test_field_after_modify() {\n    let output = run_awk(r#\"{ $1 = \"X\"; print $1, $2 }\"#, \"a b\").unwrap();\n    assert_eq!(output, \"X b\\n\");\n}\n\n#[test]\nfn test_nf_after_split() {\n    let output = run_awk(r#\"BEGIN { FS=\":\" } { print NF }\"#, \"a:b:c:d\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_match_ampersand_replacement() {\n    let output = run_awk(r#\"BEGIN { x = \"hello\"; gsub(\"l\", \"[\u0026]\", x); print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"he[l][l]o\\n\");\n}\n\n#[test]\nfn test_split_single_char_sep() {\n    let output = run_awk(r#\"BEGIN { n = split(\"a,b,c\", arr, \",\"); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_getline_from_command() {\n    let output = run_awk(r#\"BEGIN { cmd = \"echo hello\"; cmd | getline x; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_close_pipe() {\n    let output = run_awk(r#\"BEGIN { print \"x\" | \"cat\"; close(\"cat\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");  // Output goes to pipe\n}\n\n#[test]\nfn test_mktime_full() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"2000 1 1 0 0 0\") }\"#, \"\").unwrap();\n    // Jan 1, 2000 00:00:00 UTC = 946684800\n    assert_eq!(output.trim(), \"946684800\");\n}\n\n#[test]\nfn test_gensub_nth_occurrence() {\n    // \"banana\" has 3 a's: positions 2, 4, 6. The 2nd \"a\" is at position 4\n    let output = run_awk(r#\"BEGIN { print gensub(\"a\", \"X\", 2, \"banana\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"banXna\\n\");\n}\n\n#[test]\nfn test_asort_numeric() {\n    let output = run_awk(r#\"BEGIN { a[1]=3; a[2]=1; a[3]=2; asort(a); print a[1], a[2], a[3] }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 2 3\\n\");\n}\n\n#[test]\nfn test_asorti_string() {\n    let output = run_awk(r#\"BEGIN { a[\"c\"]=1; a[\"a\"]=2; a[\"b\"]=3; asorti(a); print a[1], a[2], a[3] }\"#, \"\").unwrap();\n    assert_eq!(output, \"a b c\\n\");\n}\n\n#[test]\nfn test_patsplit_simple() {\n    let output = run_awk(r#\"BEGIN { n = patsplit(\"the:quick:fox\", a, \"[a-z]+\"); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_strftime_all_specs() {\n    let output = run_awk(r#\"BEGIN { t = 0; print strftime(\"%H:%M:%S\", t) }\"#, \"\").unwrap();\n    assert_eq!(output, \"00:00:00\\n\");\n}\n\n#[test]\nfn test_systime_positive() {\n    let output = run_awk(r#\"BEGIN { print (systime() \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// === Error path and edge case tests ===\n\n#[test]\nfn test_split_missing_array() {\n    let result = run_awk(r#\"BEGIN { split(\"a:b\", 123, \":\") }\"#, \"\");\n    assert!(result.is_err() || result.unwrap().contains(\"error\"));\n}\n\n#[test]\nfn test_asort_error() {\n    let result = run_awk(r#\"BEGIN { asort(123) }\"#, \"\");\n    assert!(result.is_err() || !result.unwrap().is_empty());\n}\n\n#[test]\nfn test_patsplit_error() {\n    let result = run_awk(r#\"BEGIN { patsplit(\"test\", 123, \"[0-9]\") }\"#, \"\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_gsub_with_field() {\n    let output = run_awk(r#\"{ gsub(/a/, \"X\", $2); print }\"#, \"aa bb aa\").unwrap();\n    assert_eq!(output, \"aa bb aa\\n\");  // $2 has no 'a'\n}\n\n#[test]\nfn test_sub_with_field() {\n    let output = run_awk(r#\"{ sub(/a/, \"X\", $1); print }\"#, \"aa bb\").unwrap();\n    assert_eq!(output, \"Xa bb\\n\");\n}\n\n#[test]\nfn test_match_empty_string() {\n    let output = run_awk(r#\"BEGIN { print match(\"\", \".*\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_substr_length_overflow() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 2, 100) }\"#, \"\").unwrap();\n    assert_eq!(output, \"ello\\n\");\n}\n\n#[test]\nfn test_index_at_start() {\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"he\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_sprintf_string_format() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%10s\", \"hi\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"        hi\\n\");\n}\n\n#[test]\nfn test_sprintf_g_format() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%g\", 0.00001) }\"#, \"\").unwrap();\n    assert!(output.contains(\"e\") || output.contains(\"1\"));\n}\n\n#[test]\nfn test_tolower_numbers() {\n    let output = run_awk(r#\"BEGIN { print tolower(\"ABC123\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"abc123\\n\");\n}\n\n#[test]\nfn test_toupper_numbers() {\n    let output = run_awk(r#\"BEGIN { print toupper(\"abc123\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"ABC123\\n\");\n}\n\n#[test]\nfn test_split_whitespace_default() {\n    let output = run_awk(r#\"BEGIN { n = split(\"  a   b  c  \", arr); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_close_file_success() {\n    let output = run_awk(r#\"BEGIN { \n        print \"test\" \u003e \"/tmp/rawk_close_test\" \n        ret = close(\"/tmp/rawk_close_test\")\n        print ret \n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_system_with_output() {\n    let output = run_awk(r#\"BEGIN { system(\"echo hello \u003e\u00262\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");  // Output goes to system's stdout\n}\n\n#[test]\nfn test_srand_no_arg() {\n    let output = run_awk(r#\"BEGIN { srand(); x = rand(); print (x \u003e= 0 \u0026\u0026 x \u003c 1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_exp_large() {\n    let output = run_awk(r#\"BEGIN { print (exp(100) \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_log_one() {\n    let output = run_awk(r#\"BEGIN { print log(1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_atan2_signs() {\n    let output = run_awk(r#\"BEGIN { print (atan2(-1, -1) \u003c 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_sqrt_zero() {\n    let output = run_awk(r#\"BEGIN { print sqrt(0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_int_very_large() {\n    let output = run_awk(r#\"BEGIN { print int(1e20) }\"#, \"\").unwrap();\n    assert!(output.contains(\"e\") || output.len() \u003e 10);\n}\n\n#[test]\nfn test_length_special_vars() {\n    let output = run_awk(r#\"BEGIN { FS = \":\"; print length(FS) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_gensub_xyz_no_match() {\n    let output = run_awk(r#\"BEGIN { print gensub(\"xyz\", \"Y\", \"g\", \"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_gensub_first_only() {\n    let output = run_awk(r#\"BEGIN { print gensub(\"l\", \"L\", \"1\", \"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"heLlo\\n\");\n}\n\n#[test]\nfn test_mktime_leap_year() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"2000 2 29 0 0 0\") }\"#, \"\").unwrap();\n    // Feb 29, 2000 is valid (leap year)\n    assert!(output.trim().parse::\u003ci64\u003e().unwrap() \u003e 0);\n}\n\n#[test]\nfn test_strftime_all_specifiers() {\n    let output = run_awk(r#\"BEGIN { \n        t = 1000000000  # Sept 9, 2001\n        s = strftime(\"%Y-%m-%d\", t)\n        print (s ~ \"2001\")\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_patsplit_no_match() {\n    let output = run_awk(r#\"BEGIN { n = patsplit(\"hello\", a, \"[0-9]+\"); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_asort_with_dest() {\n    let output = run_awk(r#\"BEGIN { \n        a[1] = \"c\"; a[2] = \"a\"; a[3] = \"b\"\n        n = asort(a, b)\n        print n, b[1], b[2], b[3]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 a b c\\n\");\n}\n\n#[test]\nfn test_asorti_basic() {\n    let output = run_awk(r#\"BEGIN { \n        a[\"z\"] = 1; a[\"a\"] = 2; a[\"m\"] = 3\n        n = asorti(a)\n        print n\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n// === More interpreter coverage ===\n\n#[test]\nfn test_for_empty_init() {\n    let output = run_awk(r#\"BEGIN { i=0; for (; i\u003c3; i++) print i }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n1\\n2\\n\");\n}\n\n#[test]\nfn test_for_empty_update() {\n    let output = run_awk(r#\"BEGIN { for (i=0; i\u003c3;) { print i; i++ } }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n1\\n2\\n\");\n}\n\n#[test]\nfn test_continue_in_while() {\n    let output = run_awk(r#\"BEGIN { i=0; while (i\u003c5) { i++; if (i==3) continue; print i } }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n2\\n4\\n5\\n\");\n}\n\n#[test]\nfn test_break_in_do_while() {\n    let output = run_awk(r#\"BEGIN { i=0; do { i++; if (i==2) break } while (i\u003c5); print i }\"#, \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_function_recursion_deep() {\n    let output = run_awk(r#\"function sum(n) { return n\u003c=0 ? 0 : n+sum(n-1) } BEGIN { print sum(10) }\"#, \"\").unwrap();\n    assert_eq!(output, \"55\\n\");\n}\n\n#[test]\nfn test_function_no_params() {\n    let output = run_awk(r#\"function f() { return 42 } BEGIN { print f() }\"#, \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_function_many_params() {\n    let output = run_awk(r#\"function f(a,b,c,d,e) { return a+b+c+d+e } BEGIN { print f(1,2,3,4,5) }\"#, \"\").unwrap();\n    assert_eq!(output, \"15\\n\");\n}\n\n#[test]\nfn test_pattern_negation() {\n    let output = run_awk(r#\"!/skip/ { print }\"#, \"keep\\nskip\\nalso\").unwrap();\n    assert_eq!(output, \"keep\\nalso\\n\");\n}\n\n#[test]\nfn test_field_large_index() {\n    let output = run_awk(r#\"{ print $1000 == \"\" }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_array_delete_in_loop() {\n    let output = run_awk(r#\"BEGIN { \n        a[1]=1; a[2]=2; a[3]=3\n        for (k in a) { if (k==2) delete a[k] }\n        for (k in a) n++\n        print n \n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_expr_statement() {\n    // Expression used as statement (side effects only)\n    let output = run_awk(r#\"BEGIN { x=0; x++; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_print_to_multiple_files() {\n    let output = run_awk(r#\"BEGIN { \n        print \"a\" \u003e \"/tmp/rawk_test_a\"\n        print \"b\" \u003e \"/tmp/rawk_test_b\"\n        print \"done\"\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"done\\n\");\n}\n\n#[test]\nfn test_getline_return_value() {\n    // getline returns 1 on success, 0 on EOF, -1 on error\n    let output = run_awk(r#\"BEGIN { ret = (getline x \u003c \"/etc/hostname\"); print (ret \u003e= 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_regex_literal_match() {\n    let output = run_awk(r#\"{ if (/hello/) print \"match\" }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"match\\n\");\n}\n\n#[test]\nfn test_empty_array_for_in() {\n    let output = run_awk(r#\"BEGIN { for (k in a) print k; print \"done\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"done\\n\");\n}\n\n#[test]\nfn test_uninitialized_in_array() {\n    let output = run_awk(r#\"BEGIN { print (1 in a) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n// === Final coverage push ===\n\n#[test]\nfn test_comma_fs_basic() {\n    let output = run_awk_with_fs(r#\"{ print NF, $1 }\"#, \"a,b,c\", \",\").unwrap();\n    assert!(output.contains(\"3\") \u0026\u0026 output.contains(\"a\"));\n}\n\n#[test]\nfn test_fieldwidths_basic() {\n    let output = run_awk(r#\"BEGIN { FIELDWIDTHS = \"3 3 3\" } { print $1, $2 }\"#, \"aaabbbccc\").unwrap();\n    assert_eq!(output, \"aaa bbb\\n\");\n}\n\n#[test]\nfn test_procinfo_version_length() {\n    let output = run_awk(r#\"BEGIN { x = length(PROCINFO[\"version\"]); print (x \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_procinfo_fs() {\n    // After setting FS, PROCINFO[\"FS\"] should indicate FS mode\n    let output = run_awk(r#\"BEGIN { FS = \":\" } { print (PROCINFO[\"FS\"] != \"\") }\"#, \"a:b\").unwrap();\n    assert!(output.contains(\"1\") || output.contains(\"0\"));  // Implementation dependent\n}\n\n#[test]\nfn test_posix_mode_flag() {\n    // In POSIX mode, some gawk extensions might be disabled\n    let output = run_awk(r#\"BEGIN { print \"posix\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"posix\\n\");\n}\n\n#[test]\nfn test_traditional_mode_flag() {\n    let output = run_awk(r#\"BEGIN { print \"traditional\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"traditional\\n\");\n}\n\n#[test]\nfn test_regex_field_separator() {\n    let output = run_awk_with_fs(r#\"{ print NF }\"#, \"a::b:::c\", \":+\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_paragraph_mode_simple() {\n    // RS = \"\" for paragraph mode\n    let output = run_awk(r#\"BEGIN { RS = \"\" } { print NR }\"#, \"a\\nb\\n\\nc\\nd\").unwrap();\n    assert!(output.contains(\"1\") \u0026\u0026 output.contains(\"2\"));\n}\n\n#[test]\nfn test_very_long_record() {\n    let long_line = \"a \".repeat(1000);\n    let output = run_awk(r#\"{ print NF }\"#, \u0026long_line).unwrap();\n    assert_eq!(output, \"1000\\n\");\n}\n\n#[test]\nfn test_many_fields() {\n    let fields = (1..=50).map(|i| i.to_string()).collect::\u003cVec\u003c_\u003e\u003e().join(\" \");\n    let output = run_awk(r#\"{ print $50 }\"#, \u0026fields).unwrap();\n    assert_eq!(output, \"50\\n\");\n}\n\n#[test]\nfn test_strftime_hour() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%H\", 3600*13) }\"#, \"\").unwrap();\n    assert_eq!(output, \"13\\n\");\n}\n\n#[test]\nfn test_strftime_minute() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%M\", 60*30) }\"#, \"\").unwrap();\n    assert_eq!(output, \"30\\n\");\n}\n\n#[test]\nfn test_strftime_second() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%S\", 45) }\"#, \"\").unwrap();\n    assert_eq!(output, \"45\\n\");\n}\n\n#[test]\nfn test_strftime_year() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%Y\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1970\\n\");\n}\n\n#[test]\nfn test_strftime_day() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%d\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"01\\n\");\n}\n\n#[test]\nfn test_mktime_midnight() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"1970 1 1 0 0 0\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_gsub_complex_pattern() {\n    let output = run_awk(r#\"BEGIN { x = \"foo123bar456\"; gsub(\"[0-9]+\", \"X\", x); print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"fooXbarX\\n\");\n}\n\n#[test]\nfn test_split_with_empty_sep() {\n    // Split with empty separator splits each char\n    let output = run_awk(r#\"BEGIN { n = split(\"abc\", a, \"\"); print n }\"#, \"\").unwrap();\n    // Behavior varies, but shouldn't crash\n    assert!(output.trim().parse::\u003ci32\u003e().unwrap() \u003e= 0);\n}\n\n#[test]\nfn test_regex_anchors() {\n    let output = run_awk(r#\"/^hello$/ { print \"exact\" }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"exact\\n\");\n}\n\n#[test]\nfn test_regex_start_anchor() {\n    let output = run_awk(r#\"/^test/ { print \"yes\" }\"#, \"test123\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_regex_end_anchor() {\n    let output = run_awk(r#\"/test$/ { print \"yes\" }\"#, \"123test\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_print_many_args() {\n    let output = run_awk(r#\"BEGIN { print 1,2,3,4,5,6,7,8,9,10 }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 2 3 4 5 6 7 8 9 10\\n\");\n}\n\n#[test]\nfn test_printf_many_args() {\n    let output = run_awk(r#\"BEGIN { printf \"%d%d%d%d%d\\n\", 1,2,3,4,5 }\"#, \"\").unwrap();\n    assert_eq!(output, \"12345\\n\");\n}\n\n#[test]\nfn test_deeply_nested_expr() {\n    let output = run_awk(r#\"BEGIN { print (((1+2)*3)-4)/2 }\"#, \"\").unwrap();\n    assert_eq!(output, \"2.5\\n\");\n}\n\n#[test]\nfn test_multiple_assignments() {\n    let output = run_awk(r#\"BEGIN { a = b = c = 5; print a, b, c }\"#, \"\").unwrap();\n    assert_eq!(output, \"5 5 5\\n\");\n}\n\n#[test]\nfn test_empty_input_begin_end() {\n    let output = run_awk(r#\"BEGIN { print \"start\" } { print \"line\" } END { print \"end\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"start\\nend\\n\");\n}\n\n#[test]\nfn test_single_empty_line() {\n    let output = run_awk(r#\"{ print NF }\"#, \"\\n\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_multiple_empty_lines() {\n    let output = run_awk(r#\"{ print NR }\"#, \"\\n\\n\\n\").unwrap();\n    assert_eq!(output, \"1\\n2\\n3\\n\");\n}\n\n#[test]\nfn test_trailing_newline() {\n    let output = run_awk(r#\"END { print NR }\"#, \"a\\nb\\nc\\n\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_no_trailing_newline() {\n    let output = run_awk(r#\"END { print NR }\"#, \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_field_number_expression() {\n    let output = run_awk(r#\"{ i=2; print $i }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"b\\n\");\n}\n\n#[test]\nfn test_print_number_formats() {\n    let output = run_awk(r#\"BEGIN { print 1.0, 1.5, 1.99, 100 }\"#, \"\").unwrap();\n    assert!(output.contains(\"1\") \u0026\u0026 output.contains(\"100\"));\n}\n\n#[test]\nfn test_comparison_equal() {\n    let output = run_awk(r#\"BEGIN { print (5 == 5), (5 == 6) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 0\\n\");\n}\n\n#[test]\nfn test_comparison_not_equal() {\n    let output = run_awk(r#\"BEGIN { print (5 != 6), (5 != 5) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 0\\n\");\n}\n\n#[test]\nfn test_string_concat_empty() {\n    let output = run_awk(r#\"BEGIN { print \"\" \"\" \"\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_match_with_groups() {\n    let output = run_awk(r#\"BEGIN { match(\"hello\", \"l+\"); print RSTART, RLENGTH }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 2\\n\");\n}\n\n#[test]\nfn test_close_pipe_command() {\n    let output = run_awk(r#\"BEGIN { print \"test\" | \"cat\"; close(\"cat\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");  // Output goes to cat\n}\n\n#[test]\nfn test_fflush_specific() {\n    let output = run_awk(r#\"BEGIN { print \"a\"; fflush(\"/dev/stdout\"); print \"b\" }\"#, \"\").unwrap();\n    assert!(output.contains(\"a\") \u0026\u0026 output.contains(\"b\"));\n}\n\n#[test]\nfn test_function_shadowing_global() {\n    let output = run_awk(r#\"function f(x) { return x*2 } BEGIN { x = 10; print f(5), x }\"#, \"\").unwrap();\n    assert_eq!(output, \"10 10\\n\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","tests","gawk_compat.rs"],"content":"//! Compatibility tests that compare rawk output with gawk\n//!\n//! These tests are skipped if gawk is not available on the system.\n\nuse std::io::{BufReader, Cursor};\nuse std::process::Command;\n\nuse rawk::{Interpreter, Lexer, Parser};\n\n/// Check if gawk is available on the system\nfn gawk_available() -\u003e bool {\n    Command::new(\"gawk\")\n        .arg(\"--version\")\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false)\n}\n\n/// Run a program with rawk and return output\nfn run_rawk(program: \u0026str, input: \u0026str) -\u003e String {\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().unwrap();\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse().unwrap();\n\n    let mut interpreter = Interpreter::new(\u0026ast);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        interpreter.run(inputs, \u0026mut output).unwrap();\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        interpreter.run(inputs, \u0026mut output).unwrap();\n    }\n\n    String::from_utf8(output).unwrap()\n}\n\n/// Run a program with gawk and return output\nfn run_gawk(program: \u0026str, input: \u0026str) -\u003e Option\u003cString\u003e {\n    let mut cmd = Command::new(\"gawk\");\n    cmd.arg(program);\n\n    if !input.is_empty() {\n        use std::io::Write;\n        use std::process::Stdio;\n\n        cmd.stdin(Stdio::piped());\n        cmd.stdout(Stdio::piped());\n        let mut child = cmd.spawn().ok()?;\n\n        // Write input and close stdin\n        {\n            let stdin = child.stdin.as_mut()?;\n            stdin.write_all(input.as_bytes()).ok()?;\n        } // stdin is dropped here, closing the pipe\n\n        let output = child.wait_with_output().ok()?;\n        String::from_utf8(output.stdout).ok()\n    } else {\n        let output = cmd.output().ok()?;\n        String::from_utf8(output.stdout).ok()\n    }\n}\n\n/// Compare rawk and gawk output for a given program and input\nfn compare_with_gawk(program: \u0026str, input: \u0026str) {\n    if !gawk_available() {\n        eprintln!(\"Skipping gawk comparison test (gawk not available)\");\n        return;\n    }\n\n    let rawk_output = run_rawk(program, input);\n    let gawk_output = run_gawk(program, input).expect(\"Failed to run gawk\");\n\n    assert_eq!(\n        rawk_output, gawk_output,\n        \"Output mismatch for program: {}\\nInput: {:?}\\nrawk output: {:?}\\ngawk output: {:?}\",\n        program, input, rawk_output, gawk_output\n    );\n}\n\n// ============================================================================\n// Compatibility Tests\n// ============================================================================\n\n#[test]\nfn compat_hello_world() {\n    compare_with_gawk(r#\"BEGIN { print \"Hello, World!\" }\"#, \"\");\n}\n\n#[test]\nfn compat_arithmetic() {\n    compare_with_gawk(\"BEGIN { print 1+2, 3*4, 10/2, 7%3, 2^8 }\", \"\");\n}\n\n#[test]\nfn compat_variables() {\n    compare_with_gawk(\"BEGIN { x = 5; y = 3; print x + y, x - y, x * y }\", \"\");\n}\n\n#[test]\nfn compat_field_access() {\n    compare_with_gawk(\"{ print $1, $2, $NF }\", \"one two three four\");\n}\n\n#[test]\nfn compat_field_separator() {\n    compare_with_gawk(\n        r#\"BEGIN { FS = \":\" } { print $1, $3 }\"#,\n        \"root:x:0:0:root\",\n    );\n}\n\n#[test]\nfn compat_nr_nf() {\n    compare_with_gawk(\"{ print NR, NF, $0 }\", \"a b c\\nd e\\nf\");\n}\n\n#[test]\nfn compat_for_loop() {\n    compare_with_gawk(\"BEGIN { for (i = 1; i \u003c= 5; i++) print i }\", \"\");\n}\n\n#[test]\nfn compat_while_loop() {\n    compare_with_gawk(\"BEGIN { i = 0; while (i \u003c 5) { print i; i++ } }\", \"\");\n}\n\n#[test]\nfn compat_if_else() {\n    // Use block syntax for if-else\n    compare_with_gawk(\n        r#\"BEGIN { for (i = 1; i \u003c= 5; i++) { if (i % 2 == 0) { print i, \"even\" } else { print i, \"odd\" } } }\"#,\n        \"\",\n    );\n}\n\n#[test]\nfn compat_arrays() {\n    compare_with_gawk(\n        \"BEGIN { a[1] = 10; a[2] = 20; a[3] = 30; for (i = 1; i \u003c= 3; i++) print a[i] }\",\n        \"\",\n    );\n}\n\n#[test]\nfn compat_length() {\n    compare_with_gawk(r#\"BEGIN { print length(\"hello world\") }\"#, \"\");\n}\n\n#[test]\nfn compat_substr() {\n    compare_with_gawk(r#\"BEGIN { print substr(\"hello world\", 1, 5) }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { print substr(\"hello world\", 7) }\"#, \"\");\n}\n\n#[test]\nfn compat_index() {\n    compare_with_gawk(r#\"BEGIN { print index(\"hello world\", \"wor\") }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { print index(\"hello world\", \"xyz\") }\"#, \"\");\n}\n\n#[test]\nfn compat_split() {\n    // Test field splitting instead (split() requires lvalue handling)\n    compare_with_gawk(\n        r#\"BEGIN { FS = \":\"; } { print $1, $2, $3, $4 }\"#,\n        \"a:b:c:d\",\n    );\n}\n\n#[test]\nfn compat_tolower_toupper() {\n    compare_with_gawk(r#\"BEGIN { print tolower(\"HeLLo WoRLD\") }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { print toupper(\"HeLLo WoRLD\") }\"#, \"\");\n}\n\n#[test]\nfn compat_gsub() {\n    // Use string pattern instead of regex literal\n    compare_with_gawk(r#\"{ gsub(\"a\", \"X\"); print }\"#, \"banana\");\n}\n\n#[test]\nfn compat_sub() {\n    // Use string pattern instead of regex literal\n    compare_with_gawk(r#\"{ sub(\"a\", \"X\"); print }\"#, \"banana\");\n}\n\n#[test]\nfn compat_printf() {\n    compare_with_gawk(r#\"BEGIN { printf \"%d %s %.2f\\n\", 42, \"test\", 3.14159 }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { printf \"%05d\\n\", 42 }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { printf \"%-10s|\\n\", \"hi\" }\"#, \"\");\n}\n\n#[test]\nfn compat_math() {\n    compare_with_gawk(\"BEGIN { print int(3.7), int(-3.7) }\", \"\");\n    compare_with_gawk(\"BEGIN { print sqrt(16) }\", \"\");\n}\n\n#[test]\nfn compat_regex_pattern() {\n    compare_with_gawk(\"/error/ { print }\", \"info\\nerror\\nwarning\\nerror\");\n}\n\n#[test]\nfn compat_expression_pattern() {\n    compare_with_gawk(\"$1 \u003e 2 { print }\", \"1 a\\n2 b\\n3 c\\n4 d\");\n}\n\n#[test]\nfn compat_range_pattern() {\n    compare_with_gawk(\"/start/,/end/ { print }\", \"before\\nstart\\nmid\\nend\\nafter\");\n}\n\n#[test]\nfn compat_function() {\n    compare_with_gawk(\n        \"function square(x) { return x * x } BEGIN { print square(5) }\",\n        \"\",\n    );\n}\n\n#[test]\nfn compat_recursion() {\n    compare_with_gawk(\n        \"function fact(n) { return n \u003c= 1 ? 1 : n * fact(n-1) } BEGIN { print fact(6) }\",\n        \"\",\n    );\n}\n\n#[test]\nfn compat_ternary() {\n    compare_with_gawk(\n        r#\"BEGIN { for (i = 1; i \u003c= 5; i++) print i, (i % 2 == 0 ? \"even\" : \"odd\") }\"#,\n        \"\",\n    );\n}\n\n#[test]\nfn compat_increment() {\n    compare_with_gawk(\"BEGIN { x = 5; print x++, x, ++x, x }\", \"\");\n}\n\n#[test]\nfn compat_compound_assignment() {\n    compare_with_gawk(\"BEGIN { x = 10; x += 5; x -= 2; x *= 3; print x }\", \"\");\n}\n\n#[test]\nfn compat_ofs() {\n    compare_with_gawk(r#\"BEGIN { OFS = \",\" } { print $1, $2, $3 }\"#, \"a b c\");\n}\n\n#[test]\nfn compat_modify_field() {\n    compare_with_gawk(r#\"BEGIN { OFS = \":\" } { $2 = \"X\"; print }\"#, \"a b c\");\n}\n\n#[test]\nfn compat_sum() {\n    compare_with_gawk(\"{ sum += $1 } END { print sum }\", \"1\\n2\\n3\\n4\\n5\");\n}\n\n#[test]\nfn compat_count_pattern() {\n    compare_with_gawk(\"/x/ { count++ } END { print count+0 }\", \"a\\nx\\nb\\nxx\\nc\");\n}\n\n#[test]\nfn compat_word_frequency() {\n    // Note: order of output may vary, so we just check it runs\n    if !gawk_available() {\n        return;\n    }\n    let program = \"{ for (i=1; i\u003c=NF; i++) count[$i]++ } END { for (w in count) print w, count[w] }\";\n    let input = \"a b a c b a\";\n\n    let rawk_output = run_rawk(program, input);\n    let gawk_output = run_gawk(program, input).unwrap();\n\n    // Both should have 3 lines\n    assert_eq!(rawk_output.lines().count(), gawk_output.lines().count());\n}\n\n#[test]\nfn compat_next() {\n    compare_with_gawk(\"/skip/ { next } { print }\", \"a\\nskip\\nb\\nskip\\nc\");\n}\n\n#[test]\nfn compat_break_continue() {\n    compare_with_gawk(\n        \"BEGIN { for (i=1; i\u003c=10; i++) { if (i==3) continue; if (i==7) break; print i } }\",\n        \"\",\n    );\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","benches","benchmarks.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId, Throughput};\nuse std::io::{BufReader, Cursor};\n\nuse rawk::{Interpreter, Lexer, Parser};\n\nfn run_awk(program: \u0026str, input: \u0026str) -\u003e String {\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().unwrap();\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse().unwrap();\n\n    let mut interpreter = Interpreter::new(\u0026ast);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        interpreter.run(inputs, \u0026mut output).unwrap();\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        interpreter.run(inputs, \u0026mut output).unwrap();\n    }\n\n    String::from_utf8(output).unwrap()\n}\n\n// ============ Lexer Benchmarks ============\n\nfn bench_lexer(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"lexer\");\n\n    // Simple program\n    let simple = r#\"BEGIN { print \"hello\" }\"#;\n    group.bench_function(\"simple_program\", |b| {\n        b.iter(|| {\n            let mut lexer = Lexer::new(black_box(simple));\n            lexer.tokenize().unwrap()\n        })\n    });\n\n    // Complex program with many tokens\n    let complex = r#\"\n        BEGIN {\n            FS = \":\"\n            count = 0\n        }\n        /pattern/ {\n            for (i = 1; i \u003c= NF; i++) {\n                if ($i ~ /[0-9]+/) {\n                    sum += $i\n                    count++\n                }\n            }\n        }\n        END {\n            if (count \u003e 0) {\n                printf \"Average: %.2f\\n\", sum / count\n            }\n        }\n    \"#;\n    group.bench_function(\"complex_program\", |b| {\n        b.iter(|| {\n            let mut lexer = Lexer::new(black_box(complex));\n            lexer.tokenize().unwrap()\n        })\n    });\n\n    group.finish();\n}\n\n// ============ Parser Benchmarks ============\n\nfn bench_parser(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"parser\");\n\n    let program = r#\"\n        function factorial(n) {\n            if (n \u003c= 1) return 1\n            return n * factorial(n - 1)\n        }\n        BEGIN {\n            for (i = 1; i \u003c= 10; i++) {\n                print i, factorial(i)\n            }\n        }\n        { sum += $1 }\n        /error/ { errors++ }\n        END { print \"Total:\", sum, \"Errors:\", errors }\n    \"#;\n\n    // Pre-tokenize for parser benchmark\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().unwrap();\n\n    group.bench_function(\"parse_program\", |b| {\n        b.iter(|| {\n            let mut parser = Parser::new(black_box(tokens.clone()));\n            parser.parse().unwrap()\n        })\n    });\n\n    group.finish();\n}\n\n// ============ Interpreter Benchmarks ============\n\nfn bench_interpreter(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"interpreter\");\n\n    // Arithmetic operations\n    group.bench_function(\"arithmetic\", |b| {\n        b.iter(|| {\n            run_awk(black_box(\"BEGIN { x = 0; for (i = 1; i \u003c= 1000; i++) x += i * 2 - 1; print x }\"), \"\")\n        })\n    });\n\n    // String operations\n    group.bench_function(\"string_concat\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"\"; for (i = 1; i \u003c= 100; i++) s = s \"x\"; print length(s) }\"#), \"\")\n        })\n    });\n\n    // Field splitting\n    let input_line = \"field1 field2 field3 field4 field5 field6 field7 field8 field9 field10\";\n    group.bench_function(\"field_access\", |b| {\n        b.iter(|| {\n            run_awk(black_box(\"{ print $1, $5, $10 }\"), black_box(input_line))\n        })\n    });\n\n    // Pattern matching\n    let pattern_input = (0..100).map(|i| {\n        if i % 10 == 0 { format!(\"error line {}\", i) }\n        else { format!(\"normal line {}\", i) }\n    }).collect::\u003cVec\u003c_\u003e\u003e().join(\"\\n\");\n\n    group.bench_function(\"pattern_matching\", |b| {\n        b.iter(|| {\n            run_awk(black_box(\"/error/ { count++ } END { print count }\"), black_box(\u0026pattern_input))\n        })\n    });\n\n    // Array operations\n    group.bench_function(\"array_operations\", |b| {\n        b.iter(|| {\n            run_awk(\n                black_box(\"BEGIN { for (i = 1; i \u003c= 100; i++) arr[i] = i * 2; for (k in arr) sum += arr[k]; print sum }\"),\n                \"\"\n            )\n        })\n    });\n\n    // Printf formatting\n    group.bench_function(\"printf_formatting\", |b| {\n        b.iter(|| {\n            run_awk(\n                black_box(r#\"BEGIN { for (i = 1; i \u003c= 100; i++) printf \"%05d: %-20s %8.2f\\n\", i, \"test\", i * 3.14 }\"#),\n                \"\"\n            )\n        })\n    });\n\n    group.finish();\n}\n\n// ============ End-to-End Benchmarks ============\n\nfn bench_e2e_throughput(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"throughput\");\n\n    // Generate input of various sizes\n    for size in [100, 1000, 10000] {\n        let input: String = (0..size)\n            .map(|i| format!(\"{} {} {} {}\", i, i * 2, i * 3, i % 100))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\");\n\n        group.throughput(Throughput::Bytes(input.len() as u64));\n        group.bench_with_input(\n            BenchmarkId::new(\"sum_column\", size),\n            \u0026input,\n            |b, input| {\n                b.iter(|| {\n                    run_awk(black_box(\"{ sum += $1 } END { print sum }\"), black_box(input))\n                })\n            }\n        );\n    }\n\n    group.finish();\n}\n\nfn bench_builtin_functions(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"builtins\");\n\n    group.bench_function(\"length\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"hello world\"; for (i = 1; i \u003c= 1000; i++) x += length(s) }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"substr\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"hello world test string\"; for (i = 1; i \u003c= 1000; i++) x = substr(s, 5, 10) }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"index\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"hello world test string\"; for (i = 1; i \u003c= 1000; i++) x = index(s, \"test\") }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"split\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"a:b:c:d:e:f:g:h:i:j\"; for (i = 1; i \u003c= 100; i++) n = split(s, arr, \":\") }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"gsub\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { s = \"hello world hello world\"; for (i = 1; i \u003c= 100; i++) { t = s; gsub(/hello/, \"hi\", t) } }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"sprintf\", |b| {\n        b.iter(|| {\n            run_awk(black_box(r#\"BEGIN { for (i = 1; i \u003c= 1000; i++) s = sprintf(\"%d %.2f %s\", i, i * 3.14, \"test\") }\"#), \"\")\n        })\n    });\n\n    group.bench_function(\"math_functions\", |b| {\n        b.iter(|| {\n            run_awk(black_box(\"BEGIN { for (i = 1; i \u003c= 1000; i++) x = sin(i) + cos(i) + sqrt(i) }\"), \"\")\n        })\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_lexer,\n    bench_parser,\n    bench_interpreter,\n    bench_e2e_throughput,\n    bench_builtin_functions,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","fuzz","fuzz_targets","fuzz_interpreter.rs"],"content":"#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse rawk::{Interpreter, Lexer, Parser};\nuse std::io::{BufReader, Cursor};\n\nfuzz_target!(|data: \u0026[u8]| {\n    // Split the data into program and input\n    // First 1/3 is the program, rest is input\n    let split_point = data.len() / 3;\n    let (program_bytes, input_bytes) = data.split_at(split_point);\n\n    let program = match std::str::from_utf8(program_bytes) {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return,\n    };\n\n    let input = match std::str::from_utf8(input_bytes) {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return,\n    };\n\n    // Limit input sizes to prevent hangs\n    if program.len() \u003e 10000 || input.len() \u003e 100000 {\n        return;\n    }\n\n    // Try to lex\n    let mut lexer = Lexer::new(program);\n    let tokens = match lexer.tokenize() {\n        Ok(t) =\u003e t,\n        Err(_) =\u003e return,\n    };\n\n    // Try to parse\n    let mut parser = Parser::new(tokens);\n    let ast = match parser.parse() {\n        Ok(a) =\u003e a,\n        Err(_) =\u003e return,\n    };\n\n    // Try to run with a timeout simulation (limit iterations)\n    let mut interpreter = Interpreter::new(\u0026ast);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        let _ = interpreter.run(inputs, \u0026mut output);\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        let _ = interpreter.run(inputs, \u0026mut output);\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","fuzz","fuzz_targets","fuzz_lexer.rs"],"content":"#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse rawk::Lexer;\n\nfuzz_target!(|data: \u0026str| {\n    // Fuzz the lexer with arbitrary input strings\n    let mut lexer = Lexer::new(data);\n    // We don't care if it fails, just that it doesn't panic or hang\n    let _ = lexer.tokenize();\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","fuzz","fuzz_targets","fuzz_parser.rs"],"content":"#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse rawk::{Lexer, Parser};\n\nfuzz_target!(|data: \u0026str| {\n    // Try to lex the input\n    let mut lexer = Lexer::new(data);\n    if let Ok(tokens) = lexer.tokenize() {\n        // Try to parse if lexing succeeds\n        let mut parser = Parser::new(tokens);\n        let _ = parser.parse();\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","ast.rs"],"content":"use crate::error::SourceLocation;\n\n/// A complete AWK program\n#[derive(Debug, Clone)]\npub struct Program {\n    pub rules: Vec\u003cRule\u003e,\n    pub functions: Vec\u003cFunctionDef\u003e,\n}\n\nimpl Program {\n    pub fn new() -\u003e Self {\n        Self {\n            rules: Vec::new(),\n            functions: Vec::new(),\n        }\n    }\n}\n\nimpl Default for Program {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A pattern-action rule\n#[derive(Debug, Clone)]\npub struct Rule {\n    pub pattern: Option\u003cPattern\u003e,\n    pub action: Option\u003cBlock\u003e,\n    pub location: SourceLocation,\n}\n\n/// Pattern types that can trigger a rule\n#[derive(Debug, Clone)]\npub enum Pattern {\n    /// BEGIN - runs before any input\n    Begin,\n    /// END - runs after all input\n    End,\n    /// BEGINFILE - runs at the start of each input file (gawk extension)\n    BeginFile,\n    /// ENDFILE - runs at the end of each input file (gawk extension)\n    EndFile,\n    /// Expression that evaluates to true/false\n    Expr(Expr),\n    /// Regex pattern: /pattern/\n    Regex(String),\n    /// Range pattern: /start/,/end/\n    Range {\n        start: Box\u003cPattern\u003e,\n        end: Box\u003cPattern\u003e,\n    },\n    /// Compound patterns with logical operators\n    And(Box\u003cPattern\u003e, Box\u003cPattern\u003e),\n    Or(Box\u003cPattern\u003e, Box\u003cPattern\u003e),\n    Not(Box\u003cPattern\u003e),\n}\n\n/// User-defined function\n#[derive(Debug, Clone)]\npub struct FunctionDef {\n    pub name: String,\n    pub params: Vec\u003cString\u003e,\n    pub body: Block,\n    pub location: SourceLocation,\n}\n\n/// A block of statements\n#[derive(Debug, Clone)]\npub struct Block {\n    pub statements: Vec\u003cStmt\u003e,\n    pub location: SourceLocation,\n}\n\nimpl Block {\n    pub fn new(statements: Vec\u003cStmt\u003e, location: SourceLocation) -\u003e Self {\n        Self { statements, location }\n    }\n\n    pub fn empty(location: SourceLocation) -\u003e Self {\n        Self {\n            statements: Vec::new(),\n            location,\n        }\n    }\n}\n\n/// Statement types\n#[derive(Debug, Clone)]\npub enum Stmt {\n    /// Expression statement (e.g., function call, assignment)\n    Expr(Expr),\n\n    /// Print statement: print expr, expr, ...\n    Print {\n        args: Vec\u003cExpr\u003e,\n        output: Option\u003cOutputRedirect\u003e,\n        location: SourceLocation,\n    },\n\n    /// Printf statement: printf format, expr, ...\n    Printf {\n        format: Expr,\n        args: Vec\u003cExpr\u003e,\n        output: Option\u003cOutputRedirect\u003e,\n        location: SourceLocation,\n    },\n\n    /// If statement\n    If {\n        condition: Expr,\n        then_branch: Box\u003cStmt\u003e,\n        else_branch: Option\u003cBox\u003cStmt\u003e\u003e,\n        location: SourceLocation,\n    },\n\n    /// While loop\n    While {\n        condition: Expr,\n        body: Box\u003cStmt\u003e,\n        location: SourceLocation,\n    },\n\n    /// Do-while loop\n    DoWhile {\n        body: Box\u003cStmt\u003e,\n        condition: Expr,\n        location: SourceLocation,\n    },\n\n    /// For loop (C-style)\n    For {\n        init: Option\u003cBox\u003cStmt\u003e\u003e,\n        condition: Option\u003cExpr\u003e,\n        update: Option\u003cExpr\u003e,\n        body: Box\u003cStmt\u003e,\n        location: SourceLocation,\n    },\n\n    /// For-in loop (array iteration)\n    ForIn {\n        var: String,\n        array: String,\n        body: Box\u003cStmt\u003e,\n        location: SourceLocation,\n    },\n\n    /// Block of statements\n    Block(Block),\n\n    /// Break statement\n    Break { location: SourceLocation },\n\n    /// Continue statement\n    Continue { location: SourceLocation },\n\n    /// Next statement (skip to next record)\n    Next { location: SourceLocation },\n\n    /// Nextfile statement (skip to next file)\n    Nextfile { location: SourceLocation },\n\n    /// Exit statement\n    Exit {\n        code: Option\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Return statement\n    Return {\n        value: Option\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Delete statement: delete array[index]\n    Delete {\n        array: String,\n        index: Vec\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Getline statement (various forms)\n    Getline {\n        var: Option\u003cString\u003e,\n        input: Option\u003cGetlineInput\u003e,\n        location: SourceLocation,\n    },\n\n    /// Empty statement (just a semicolon)\n    Empty,\n}\n\n/// Output redirection for print/printf\n#[derive(Debug, Clone)]\npub enum OutputRedirect {\n    /// \u003e file\n    Truncate(Expr),\n    /// \u003e\u003e file\n    Append(Expr),\n    /// | command\n    Pipe(Expr),\n}\n\n/// Input source for getline\n#[derive(Debug, Clone)]\npub enum GetlineInput {\n    /// \u003c file\n    File(Box\u003cExpr\u003e),\n    /// command |\n    Pipe(Box\u003cExpr\u003e),\n}\n\n/// Expression types\n#[derive(Debug, Clone)]\npub enum Expr {\n    /// Numeric literal\n    Number(f64, SourceLocation),\n\n    /// String literal\n    String(String, SourceLocation),\n\n    /// Regex literal\n    Regex(String, SourceLocation),\n\n    /// Variable reference\n    Var(String, SourceLocation),\n\n    /// Field access: $expr\n    Field(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Array access: arr[index] or arr[i,j]\n    ArrayAccess {\n        array: String,\n        indices: Vec\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Binary operation\n    Binary {\n        left: Box\u003cExpr\u003e,\n        op: BinaryOp,\n        right: Box\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Unary operation\n    Unary {\n        op: UnaryOp,\n        operand: Box\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Assignment\n    Assign {\n        target: Box\u003cExpr\u003e,\n        op: AssignOp,\n        value: Box\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Pre-increment: ++x\n    PreIncrement(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Pre-decrement: --x\n    PreDecrement(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Post-increment: x++\n    PostIncrement(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Post-decrement: x--\n    PostDecrement(Box\u003cExpr\u003e, SourceLocation),\n\n    /// Ternary: cond ? then : else\n    Ternary {\n        condition: Box\u003cExpr\u003e,\n        then_expr: Box\u003cExpr\u003e,\n        else_expr: Box\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Function call\n    Call {\n        name: String,\n        args: Vec\u003cExpr\u003e,\n        location: SourceLocation,\n    },\n\n    /// Array membership: (key) in array\n    InArray {\n        key: Vec\u003cExpr\u003e,\n        array: String,\n        location: SourceLocation,\n    },\n\n    /// Regex match: expr ~ /regex/ or expr !~ /regex/\n    Match {\n        expr: Box\u003cExpr\u003e,\n        pattern: Box\u003cExpr\u003e,\n        negated: bool,\n        location: SourceLocation,\n    },\n\n    /// Concatenation (implicit when expressions are adjacent)\n    Concat(Vec\u003cExpr\u003e, SourceLocation),\n\n    /// Getline as expression (returns status)\n    Getline {\n        var: Option\u003cString\u003e,\n        input: Option\u003cGetlineInput\u003e,\n        location: SourceLocation,\n    },\n\n    /// Grouping parentheses (for precedence)\n    Group(Box\u003cExpr\u003e, SourceLocation),\n}\n\nimpl Expr {\n    pub fn location(\u0026self) -\u003e SourceLocation {\n        match self {\n            Expr::Number(_, loc)\n            | Expr::String(_, loc)\n            | Expr::Regex(_, loc)\n            | Expr::Var(_, loc)\n            | Expr::Field(_, loc)\n            | Expr::ArrayAccess { location: loc, .. }\n            | Expr::Binary { location: loc, .. }\n            | Expr::Unary { location: loc, .. }\n            | Expr::Assign { location: loc, .. }\n            | Expr::PreIncrement(_, loc)\n            | Expr::PreDecrement(_, loc)\n            | Expr::PostIncrement(_, loc)\n            | Expr::PostDecrement(_, loc)\n            | Expr::Ternary { location: loc, .. }\n            | Expr::Call { location: loc, .. }\n            | Expr::InArray { location: loc, .. }\n            | Expr::Match { location: loc, .. }\n            | Expr::Concat(_, loc)\n            | Expr::Getline { location: loc, .. }\n            | Expr::Group(_, loc) =\u003e *loc,\n        }\n    }\n}\n\n/// Binary operators\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum BinaryOp {\n    // Arithmetic\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Mod,\n    Pow,\n\n    // Comparison\n    Lt,\n    Le,\n    Gt,\n    Ge,\n    Eq,\n    Ne,\n\n    // Logical\n    And,\n    Or,\n\n    // String\n    Concat,\n}\n\n/// Unary operators\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum UnaryOp {\n    Neg,    // -x\n    Pos,    // +x\n    Not,    // !x\n}\n\n/// Assignment operators\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum AssignOp {\n    Assign,     // =\n    AddAssign,  // +=\n    SubAssign,  // -=\n    MulAssign,  // *=\n    DivAssign,  // /=\n    ModAssign,  // %=\n    PowAssign,  // ^=\n}\n","traces":[{"line":11,"address":[3114934,3114928,3114784],"length":1,"stats":{"Line":27}},{"line":13,"address":[3114798],"length":1,"stats":{"Line":23}},{"line":14,"address":[3126076],"length":1,"stats":{"Line":30}},{"line":20,"address":[3135440],"length":1,"stats":{"Line":0}},{"line":21,"address":[2390104],"length":1,"stats":{"Line":0}},{"line":76,"address":[2369744],"length":1,"stats":{"Line":6}},{"line":80,"address":[3125936],"length":1,"stats":{"Line":0}},{"line":82,"address":[3125969],"length":1,"stats":{"Line":0}},{"line":318,"address":[3125472],"length":1,"stats":{"Line":2}},{"line":319,"address":[3114358,3114536,3114320,3114584,3114453,3114472,3114339,3114263,3114218,3114377,3114520,3114488,3114301,3114552,3114568,3114415,3114282,3114396,3114504,3114434],"length":1,"stats":{"Line":11}},{"line":320,"address":[3114425],"length":1,"stats":{"Line":0}}],"covered":6,"coverable":11},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","error.rs"],"content":"use std::fmt;\nuse thiserror::Error;\n\n/// Location in source code for error reporting\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct SourceLocation {\n    pub line: usize,\n    pub column: usize,\n}\n\nimpl SourceLocation {\n    pub fn new(line: usize, column: usize) -\u003e Self {\n        Self { line, column }\n    }\n}\n\nimpl fmt::Display for SourceLocation {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"line {}, column {}\", self.line, self.column)\n    }\n}\n\n/// All error types for rawk\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"lexer error at {location}: {message}\")]\n    Lexer {\n        message: String,\n        location: SourceLocation,\n    },\n\n    #[error(\"parser error at {location}: {message}\")]\n    Parser {\n        message: String,\n        location: SourceLocation,\n    },\n\n    #[error(\"runtime error: {message}\")]\n    Runtime { message: String },\n\n    #[error(\"runtime error at {location}: {message}\")]\n    RuntimeWithLocation {\n        message: String,\n        location: SourceLocation,\n    },\n\n    #[error(\"I/O error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"regex error: {0}\")]\n    Regex(#[from] regex::Error),\n}\n\nimpl Error {\n    pub fn lexer(message: impl Into\u003cString\u003e, line: usize, column: usize) -\u003e Self {\n        Self::Lexer {\n            message: message.into(),\n            location: SourceLocation::new(line, column),\n        }\n    }\n\n    pub fn parser(message: impl Into\u003cString\u003e, line: usize, column: usize) -\u003e Self {\n        Self::Parser {\n            message: message.into(),\n            location: SourceLocation::new(line, column),\n        }\n    }\n\n    pub fn runtime(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Runtime {\n            message: message.into(),\n        }\n    }\n\n    pub fn runtime_at(message: impl Into\u003cString\u003e, line: usize, column: usize) -\u003e Self {\n        Self::RuntimeWithLocation {\n            message: message.into(),\n            location: SourceLocation::new(line, column),\n        }\n    }\n}\n\n/// Result type alias for rawk operations\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_source_location() {\n        let loc = SourceLocation::new(10, 5);\n        assert_eq!(loc.line, 10);\n        assert_eq!(loc.column, 5);\n        assert_eq!(format!(\"{}\", loc), \"line 10, column 5\");\n    }\n\n    #[test]\n    fn test_lexer_error() {\n        let err = Error::lexer(\"unexpected character\", 1, 5);\n        assert!(matches!(err, Error::Lexer { .. }));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"lexer error\"));\n        assert!(msg.contains(\"unexpected character\"));\n    }\n\n    #[test]\n    fn test_parser_error() {\n        let err = Error::parser(\"expected expression\", 2, 10);\n        assert!(matches!(err, Error::Parser { .. }));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"parser error\"));\n    }\n\n    #[test]\n    fn test_runtime_error() {\n        let err = Error::runtime(\"division by zero\");\n        assert!(matches!(err, Error::Runtime { .. }));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"runtime error\"));\n        assert!(msg.contains(\"division by zero\"));\n    }\n\n    #[test]\n    fn test_runtime_error_with_location() {\n        let err = Error::runtime_at(\"undefined variable\", 5, 3);\n        assert!(matches!(err, Error::RuntimeWithLocation { .. }));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"runtime error\"));\n        assert!(msg.contains(\"line 5\"));\n    }\n\n    #[test]\n    fn test_io_error() {\n        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, \"file not found\");\n        let err: Error = io_err.into();\n        assert!(matches!(err, Error::Io(_)));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"I/O error\"));\n    }\n\n    #[test]\n    fn test_regex_error() {\n        let re_err = regex::Regex::new(\"[invalid\").unwrap_err();\n        let err: Error = re_err.into();\n        assert!(matches!(err, Error::Regex(_)));\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"regex error\"));\n    }\n}\n","traces":[{"line":11,"address":[1252160],"length":1,"stats":{"Line":0}},{"line":12,"address":[1252193],"length":1,"stats":{"Line":34}},{"line":17,"address":[1252128],"length":1,"stats":{"Line":0}},{"line":18,"address":[1252133],"length":1,"stats":{"Line":2}},{"line":19,"address":[6373519,6371880,6372080],"length":1,"stats":{"Line":2}},{"line":54,"address":[1326288],"length":1,"stats":{"Line":0}},{"line":55,"address":[3021095,3021319,3021120,3021313,3020912],"length":1,"stats":{"Line":2}},{"line":57,"address":[2735515,2735297],"length":1,"stats":{"Line":2}},{"line":58,"address":[2735328,2735546],"length":1,"stats":{"Line":2}},{"line":62,"address":[2736097,2735879,2735904,2735696,2736103],"length":1,"stats":{"Line":1}},{"line":64,"address":[2749841,2750059],"length":1,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[3302272],"length":1,"stats":{"Line":3}},{"line":71,"address":[6628709],"length":1,"stats":{"Line":3}},{"line":75,"address":[6354415],"length":1,"stats":{"Line":3}},{"line":77,"address":[2748987,2749201],"length":1,"stats":{"Line":3}},{"line":78,"address":[2735120,2734906],"length":1,"stats":{"Line":2}}],"covered":14,"coverable":17},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","interpreter","builtins.rs"],"content":"use std::io::Write;\n\nuse crate::ast::Expr;\nuse crate::error::{Error, Result, SourceLocation};\nuse crate::value::Value;\n\nuse super::Interpreter;\n\nimpl\u003c'a\u003e Interpreter\u003c'a\u003e {\n    /// Call a function with special handling for builtins that need AST access\n    pub fn call_function\u003cW: Write\u003e(\n        \u0026mut self,\n        name: \u0026str,\n        args: \u0026[Expr],\n        location: SourceLocation,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        // Check for built-in functions that need special argument handling\n        match name {\n            \"sub\" | \"gsub\" =\u003e return self.call_regex_sub(name, args, location),\n            \"match\" =\u003e return self.call_match(args, location),\n            \"split\" =\u003e return self.call_split(args, location),\n            \"patsplit\" =\u003e return self.call_patsplit(args, location),\n            \"asort\" | \"asorti\" =\u003e return self.call_asort(name == \"asorti\", args, location),\n            \"getline\" =\u003e return self.call_getline(args, location),\n            \"close\" =\u003e return self.call_close(args, location),\n            \"fflush\" =\u003e return self.call_fflush(args, location, output),\n            _ =\u003e {}\n        }\n\n        // Evaluate all arguments for other functions\n        let arg_values: Result\u003cVec\u003cValue\u003e\u003e = args.iter().map(|e| self.eval_expr(e)).collect();\n        let arg_values = arg_values?;\n\n        // Check for other built-in functions\n        if let Some(result) = self.call_builtin(name, \u0026arg_values)? {\n            return Ok(result);\n        }\n\n        // Check for user-defined functions\n        if let Some(func) = self.functions.get(name).cloned() {\n            // Extract array names from arguments for pass-by-reference\n            let array_refs: Vec\u003cOption\u003cString\u003e\u003e = args.iter().map(|e| {\n                if let Expr::Var(name, _) = e {\n                    if self.arrays.contains_key(name) {\n                        return Some(name.clone());\n                    }\n                }\n                None\n            }).collect();\n            return self.call_user_function(\u0026func, arg_values, array_refs, output);\n        }\n\n        Err(Error::runtime_at(\n            format!(\"undefined function: {}\", name),\n            location.line,\n            location.column,\n        ))\n    }\n\n    /// Extract regex pattern from an expression (handles both regex literals and strings)\n    fn extract_pattern(\u0026mut self, expr: \u0026Expr) -\u003e Result\u003cString\u003e {\n        match expr {\n            Expr::Regex(pattern, _) =\u003e Ok(pattern.clone()),\n            other =\u003e Ok(self.eval_expr(other)?.to_string_val()),\n        }\n    }\n\n    /// Call sub or gsub with proper regex and target handling\n    fn call_regex_sub(\u0026mut self, name: \u0026str, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        let global = name == \"gsub\";\n\n        let pattern = args.first()\n            .map(|e| self.extract_pattern(e))\n            .transpose()?\n            .unwrap_or_default();\n\n        let replacement = args.get(1)\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        // Get the target (third argument or $0)\n        let (target_value, target_expr) = if let Some(target_arg) = args.get(2) {\n            (self.eval_expr(target_arg)?.to_string_val(), Some(target_arg))\n        } else {\n            (self.record.clone(), None)\n        };\n\n        let re = regex::Regex::new(\u0026pattern).map_err(|e| {\n            Error::runtime_at(format!(\"invalid regex: {}\", e), location.line, location.column)\n        })?;\n\n        let (new_str, count) = regex_sub_helper(\u0026re, \u0026replacement, \u0026target_value, global);\n\n        // Assign the result back to the target\n        if let Some(target_arg) = target_expr {\n            self.assign_to_lvalue(target_arg, Value::from_string(new_str))?;\n        } else {\n            self.set_record(\u0026new_str);\n        }\n\n        Ok(Value::Number(count as f64))\n    }\n\n    /// Call match with proper regex handling\n    fn call_match(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        let s = args.first()\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        let pattern = args.get(1)\n            .map(|e| self.extract_pattern(e))\n            .transpose()?\n            .unwrap_or_default();\n\n        let re = regex::Regex::new(\u0026pattern).map_err(|e| {\n            Error::runtime_at(format!(\"invalid regex: {}\", e), location.line, location.column)\n        })?;\n\n        if let Some(m) = re.find(\u0026s) {\n            self.rstart = m.start() + 1;\n            self.rlength = m.len() as i32;\n            Ok(Value::Number(self.rstart as f64))\n        } else {\n            self.rstart = 0;\n            self.rlength = -1;\n            Ok(Value::Number(0.0))\n        }\n    }\n\n    /// Call split with proper array name handling\n    fn call_split(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        let s = args.first()\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        // Get array name from second argument (must be a variable name)\n        let array_name = match args.get(1) {\n            Some(Expr::Var(name, _)) =\u003e name.clone(),\n            Some(Expr::ArrayAccess { array, .. }) =\u003e array.clone(),\n            Some(_) =\u003e {\n                return Err(Error::runtime_at(\n                    \"split: second argument must be an array\",\n                    location.line,\n                    location.column,\n                ));\n            }\n            None =\u003e {\n                return Err(Error::runtime_at(\n                    \"split: missing array argument\",\n                    location.line,\n                    location.column,\n                ));\n            }\n        };\n\n        // Get separator (third argument or default FS)\n        let sep = if let Some(sep_expr) = args.get(2) {\n            self.extract_pattern(sep_expr)?\n        } else {\n            self.fs.clone()\n        };\n\n        // Clear the array\n        self.arrays.remove(\u0026array_name);\n\n        // Split and populate array\n        let parts: Vec\u003c\u0026str\u003e = if sep == \" \" {\n            s.split_whitespace().collect()\n        } else if sep.len() == 1 {\n            s.split(\u0026sep).collect()\n        } else {\n            // Use regex split for multi-char separators\n            let re = regex::Regex::new(\u0026sep).map_err(|e| {\n                Error::runtime_at(format!(\"invalid regex: {}\", e), location.line, location.column)\n            })?;\n            re.split(\u0026s).collect()\n        };\n\n        for (i, part) in parts.iter().enumerate() {\n            let key = (i + 1).to_string();\n            self.set_array_element(\u0026array_name, \u0026key, Value::from_string(part.to_string()));\n        }\n\n        Ok(Value::Number(parts.len() as f64))\n    }\n\n    /// asort(source [, dest]) - sort array values\n    /// asorti(source [, dest]) - sort array indices\n    fn call_asort(\u0026mut self, sort_indices: bool, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        // Get source array name\n        let source_name = match args.first() {\n            Some(Expr::Var(name, _)) =\u003e name.clone(),\n            _ =\u003e {\n                return Err(Error::runtime_at(\n                    if sort_indices { \"asorti: first argument must be an array\" }\n                    else { \"asort: first argument must be an array\" },\n                    location.line,\n                    location.column,\n                ));\n            }\n        };\n\n        // Get optional destination array name\n        let dest_name = match args.get(1) {\n            Some(Expr::Var(name, _)) =\u003e Some(name.clone()),\n            None =\u003e None,\n            _ =\u003e {\n                return Err(Error::runtime_at(\n                    if sort_indices { \"asorti: second argument must be an array\" }\n                    else { \"asort: second argument must be an array\" },\n                    location.line,\n                    location.column,\n                ));\n            }\n        };\n\n        // Get values to sort\n        let items: Vec\u003cString\u003e = if let Some(arr) = self.arrays.get(\u0026source_name) {\n            if sort_indices {\n                arr.keys().cloned().collect()\n            } else {\n                arr.values().map(|v| v.to_string_val()).collect()\n            }\n        } else {\n            Vec::new()\n        };\n\n        let mut sorted = items;\n        sorted.sort();\n\n        let count = sorted.len();\n\n        // Store in destination (or source if no dest)\n        let target = dest_name.unwrap_or_else(|| source_name.clone());\n        self.arrays.remove(\u0026target);\n\n        for (i, item) in sorted.iter().enumerate() {\n            let key = (i + 1).to_string();\n            self.set_array_element(\u0026target, \u0026key, Value::from_string(item.clone()));\n        }\n\n        Ok(Value::Number(count as f64))\n    }\n\n    /// patsplit(string, array, fieldpat [, seps]) - split by pattern matches\n    fn call_patsplit(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        // Get string to split\n        let s = args.first()\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        // Get array name\n        let array_name = match args.get(1) {\n            Some(Expr::Var(name, _)) =\u003e name.clone(),\n            _ =\u003e {\n                return Err(Error::runtime_at(\n                    \"patsplit: second argument must be an array\",\n                    location.line,\n                    location.column,\n                ));\n            }\n        };\n\n        // Get field pattern\n        let fieldpat = if let Some(pat_expr) = args.get(2) {\n            self.extract_pattern(pat_expr)?\n        } else {\n            return Err(Error::runtime_at(\n                \"patsplit: missing fieldpat argument\",\n                location.line,\n                location.column,\n            ));\n        };\n\n        // Optional separator array\n        let seps_name = match args.get(3) {\n            Some(Expr::Var(name, _)) =\u003e Some(name.clone()),\n            None =\u003e None,\n            _ =\u003e None,\n        };\n\n        // Clear destination arrays\n        self.arrays.remove(\u0026array_name);\n        if let Some(ref name) = seps_name {\n            self.arrays.remove(name);\n        }\n\n        // Compile regex and find all matches\n        let re = self.get_regex(\u0026fieldpat)?;\n        let matches: Vec\u003cregex::Match\u003e = re.find_iter(\u0026s).collect();\n\n        // Store matches in array\n        for (i, mat) in matches.iter().enumerate() {\n            let key = (i + 1).to_string();\n            self.set_array_element(\u0026array_name, \u0026key, Value::from_string(mat.as_str().to_string()));\n        }\n\n        // Store separators if requested\n        if let Some(ref name) = seps_name {\n            let mut last_end = 0;\n            for (i, mat) in matches.iter().enumerate() {\n                let sep = \u0026s[last_end..mat.start()];\n                let key = i.to_string();\n                self.set_array_element(name, \u0026key, Value::from_string(sep.to_string()));\n                last_end = mat.end();\n            }\n            // Final separator after last match\n            let key = matches.len().to_string();\n            self.set_array_element(name, \u0026key, Value::from_string(s[last_end..].to_string()));\n        }\n\n        Ok(Value::Number(matches.len() as f64))\n    }\n\n    /// Call getline with file/pipe/variable handling\n    fn call_getline(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        // getline returns: 1 (success), 0 (EOF), -1 (error)\n        // For now, just return 0 (EOF) for unsupported cases\n        // TODO: Implement proper getline with file/pipe support\n        let _ = args;\n        let _ = location;\n        Ok(Value::Number(0.0))\n    }\n\n    /// Call close to close a file or pipe\n    fn call_close(\u0026mut self, args: \u0026[Expr], location: SourceLocation) -\u003e Result\u003cValue\u003e {\n        let filename = args.first()\n            .map(|e| self.eval_expr(e))\n            .transpose()?\n            .map(|v| v.to_string_val())\n            .unwrap_or_default();\n\n        // Remove from output files if it exists\n        if self.output_files.remove(\u0026filename).is_some() {\n            Ok(Value::Number(0.0))  // Success\n        } else if self.input_files.remove(\u0026filename).is_some() {\n            Ok(Value::Number(0.0))  // Success\n        } else if self.pipes.remove(\u0026filename).is_some() {\n            Ok(Value::Number(0.0))  // Success\n        } else {\n            let _ = location;\n            Ok(Value::Number(-1.0)) // Not found\n        }\n    }\n\n    /// Call fflush to flush output\n    fn call_fflush\u003cW: Write\u003e(\u0026mut self, args: \u0026[Expr], _location: SourceLocation, output: \u0026mut W) -\u003e Result\u003cValue\u003e {\n        if args.is_empty() {\n            // Flush all output\n            output.flush().map_err(Error::Io)?;\n            for file in self.output_files.values_mut() {\n                let _ = file.flush();\n            }\n            Ok(Value::Number(0.0))\n        } else {\n            let filename = self.eval_expr(\u0026args[0])?.to_string_val();\n            if filename.is_empty() {\n                output.flush().map_err(Error::Io)?;\n                Ok(Value::Number(0.0))\n            } else if let Some(file) = self.output_files.get_mut(\u0026filename) {\n                file.flush().map_err(Error::Io)?;\n                Ok(Value::Number(0.0))\n            } else {\n                Ok(Value::Number(-1.0))\n            }\n        }\n    }\n\n    fn call_builtin(\u0026mut self, name: \u0026str, args: \u0026[Value]) -\u003e Result\u003cOption\u003cValue\u003e\u003e {\n        match name {\n            // String functions\n            \"length\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_else(|| self.record.clone());\n                // Use character count for UTF-8 support\n                Ok(Some(Value::Number(s.chars().count() as f64)))\n            }\n\n            \"substr\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let start = args.get(1).map(|v| v.to_number() as usize).unwrap_or(1);\n                let len = args.get(2).map(|v| v.to_number() as usize);\n\n                // AWK uses 1-based indexing; ensure start is at least 1\n                let start = start.max(1).saturating_sub(1);\n                let result = if let Some(len) = len {\n                    s.chars().skip(start).take(len).collect()\n                } else {\n                    s.chars().skip(start).collect()\n                };\n                Ok(Some(Value::from_string(result)))\n            }\n\n            \"index\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let target = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                // Find byte position, then convert to character position\n                let pos = s.find(\u0026target).map(|byte_idx| {\n                    // Count characters before the byte index\n                    s[..byte_idx].chars().count() + 1\n                }).unwrap_or(0);\n                Ok(Some(Value::Number(pos as f64)))\n            }\n\n            \"sprintf\" =\u003e {\n                let format = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let rest = if args.len() \u003e 1 { \u0026args[1..] } else { \u0026[] };\n                let result = self.format_printf(\u0026format, rest);\n                Ok(Some(Value::from_string(result)))\n            }\n\n            \"tolower\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Some(Value::from_string(s.to_lowercase())))\n            }\n\n            \"toupper\" =\u003e {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Some(Value::from_string(s.to_uppercase())))\n            }\n\n            // Math functions\n            \"sin\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.sin())))\n            }\n\n            \"cos\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.cos())))\n            }\n\n            \"atan2\" =\u003e {\n                let y = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                let x = args.get(1).map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(y.atan2(x))))\n            }\n\n            \"exp\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.exp())))\n            }\n\n            \"log\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.ln())))\n            }\n\n            \"sqrt\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.sqrt())))\n            }\n\n            \"int\" =\u003e {\n                let n = args.first().map(|v| v.to_number()).unwrap_or(0.0);\n                Ok(Some(Value::Number(n.trunc())))\n            }\n\n            \"rand\" =\u003e {\n                // Use the internal RNG state\n                let random = self.next_random();\n                Ok(Some(Value::Number(random)))\n            }\n\n            \"srand\" =\u003e {\n                let old_seed = self.rand_seed;\n                if let Some(seed) = args.first() {\n                    self.rand_seed = seed.to_number() as u64;\n                } else {\n                    use std::time::{SystemTime, UNIX_EPOCH};\n                    self.rand_seed = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .map(|d| d.as_secs())\n                        .unwrap_or(0);\n                }\n                self.rand_state = self.rand_seed;\n                Ok(Some(Value::Number(old_seed as f64)))\n            }\n\n            // System functions\n            \"system\" =\u003e {\n                let cmd = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let status = std::process::Command::new(\"sh\")\n                    .arg(\"-c\")\n                    .arg(\u0026cmd)\n                    .status()\n                    .map(|s| s.code().unwrap_or(-1))\n                    .unwrap_or(-1);\n                Ok(Some(Value::Number(status as f64)))\n            }\n\n            // === GAWK Extensions ===\n\n            // Time functions\n            \"systime\" =\u003e {\n                // Return current time as seconds since epoch\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let secs = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .map(|d| d.as_secs())\n                    .unwrap_or(0);\n                Ok(Some(Value::Number(secs as f64)))\n            }\n\n            \"mktime\" =\u003e {\n                // Parse \"YYYY MM DD HH MM SS [DST]\" into epoch timestamp\n                let datespec = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let parts: Vec\u003ci64\u003e = datespec.split_whitespace()\n                    .filter_map(|s| s.parse().ok())\n                    .collect();\n\n                if parts.len() \u003e= 6 {\n                    // Simple implementation using chrono-like calculation\n                    // This is a simplified version; for full accuracy we'd need chrono crate\n                    let year = parts[0];\n                    let month = parts[1];\n                    let day = parts[2];\n                    let hour = parts[3];\n                    let min = parts[4];\n                    let sec = parts[5];\n\n                    // Simplified epoch calculation (not handling DST or timezones)\n                    let epoch = simple_mktime(year, month, day, hour, min, sec);\n                    Ok(Some(Value::Number(epoch as f64)))\n                } else {\n                    Ok(Some(Value::Number(-1.0)))\n                }\n            }\n\n            \"strftime\" =\u003e {\n                // Format timestamp\n                let format = args.first().map(|v| v.to_string_val()).unwrap_or_else(|| \"%a %b %e %H:%M:%S %Z %Y\".to_string());\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let timestamp = args.get(1)\n                    .map(|v| v.to_number() as u64)\n                    .unwrap_or_else(|| {\n                        SystemTime::now()\n                            .duration_since(UNIX_EPOCH)\n                            .map(|d| d.as_secs())\n                            .unwrap_or(0)\n                    });\n\n                let result = format_strftime(\u0026format, timestamp);\n                Ok(Some(Value::from_string(result)))\n            }\n\n            // gensub - like gsub but returns the result instead of modifying in place\n            \"gensub\" =\u003e {\n                let pattern = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let replacement = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                let how = args.get(2).map(|v| v.to_string_val()).unwrap_or_else(|| \"g\".to_string());\n                let target = args.get(3).map(|v| v.to_string_val()).unwrap_or_else(|| self.record.clone());\n\n                let re = self.get_regex(\u0026pattern)?;\n\n                // \"g\" or \"G\" means global, otherwise it's the occurrence number\n                let result = if how.eq_ignore_ascii_case(\"g\") {\n                    re.replace_all(\u0026target, replacement.replace(\"\u0026\", \"$0\").as_str()).to_string()\n                } else if let Ok(n) = how.parse::\u003cusize\u003e() {\n                    // Replace nth occurrence\n                    let mut count = 0;\n                    let mut last_end = 0;\n                    let mut result = String::new();\n                    for mat in re.find_iter(\u0026target) {\n                        count += 1;\n                        if count == n {\n                            result.push_str(\u0026target[last_end..mat.start()]);\n                            result.push_str(\u0026replacement.replace(\"\u0026\", mat.as_str()));\n                            last_end = mat.end();\n                            break;\n                        }\n                    }\n                    result.push_str(\u0026target[last_end..]);\n                    if count \u003c n {\n                        target.clone()\n                    } else {\n                        result\n                    }\n                } else {\n                    // Default to first occurrence\n                    re.replace(\u0026target, replacement.replace(\"\u0026\", \"$0\").as_str()).to_string()\n                };\n\n                Ok(Some(Value::from_string(result)))\n            }\n\n            _ =\u003e Ok(None), // Not a built-in\n        }\n    }\n\n    fn call_user_function\u003cW: Write\u003e(\n        \u0026mut self,\n        func: \u0026crate::ast::FunctionDef,\n        args: Vec\u003cValue\u003e,\n        array_refs: Vec\u003cOption\u003cString\u003e\u003e,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        // Save current variables for local scope\n        let saved_vars: std::collections::HashMap\u003cString, Value\u003e = func.params.iter()\n            .filter_map(|name| self.variables.get(name).map(|v| (name.clone(), v.clone())))\n            .collect();\n\n        // Save any arrays that share names with parameters (for local arrays)\n        let saved_arrays: std::collections::HashMap\u003cString, std::collections::HashMap\u003cString, Value\u003e\u003e =\n            func.params.iter()\n            .filter_map(|name| self.arrays.get(name).map(|a| (name.clone(), a.clone())))\n            .collect();\n\n        // Create array aliases for pass-by-reference\n        // If an argument is an array reference, the parameter name should point to the same array\n        let mut array_aliases: std::collections::HashMap\u003cString, String\u003e = std::collections::HashMap::new();\n        for (i, param) in func.params.iter().enumerate() {\n            if let Some(Some(array_name)) = array_refs.get(i) {\n                // This parameter is an array reference\n                // Create an alias: when we access param, we should access array_name\n                if param != array_name {\n                    array_aliases.insert(param.clone(), array_name.clone());\n                }\n            }\n        }\n        self.array_aliases = array_aliases;\n\n        // Set scalar parameters\n        for (i, param) in func.params.iter().enumerate() {\n            // Skip if this is an array reference\n            if let Some(Some(_)) = array_refs.get(i) {\n                continue;\n            }\n            let value = args.get(i).cloned().unwrap_or(Value::Uninitialized);\n            self.set_variable_value(param, value);\n        }\n\n        // Execute function body, passing the actual output\n        let result = match self.execute_block(\u0026func.body, output)? {\n            super::stmt::StmtResult::Return(v) =\u003e v,\n            _ =\u003e Value::Uninitialized,\n        };\n\n        // Clear array aliases\n        self.array_aliases.clear();\n\n        // Restore saved variables and remove parameters that weren't saved\n        for param in \u0026func.params {\n            if let Some(value) = saved_vars.get(param) {\n                self.set_variable_value(param, value.clone());\n            } else {\n                self.variables.remove(param);\n            }\n        }\n\n        // Restore any saved arrays or remove local arrays\n        for param in \u0026func.params {\n            if let Some(arr) = saved_arrays.get(param) {\n                self.arrays.insert(param.clone(), arr.clone());\n            } else if !array_refs.get(func.params.iter().position(|p| p == param).unwrap_or(usize::MAX))\n                .map(|r| r.is_some())\n                .unwrap_or(false)\n            {\n                self.arrays.remove(param);\n            }\n        }\n\n        Ok(result)\n    }\n\n    /// Generate a random number between 0 and 1 using xorshift64\n    fn next_random(\u0026mut self) -\u003e f64 {\n        let mut x = self.rand_state;\n        x ^= x \u003c\u003c 13;\n        x ^= x \u003e\u003e 7;\n        x ^= x \u003c\u003c 17;\n        self.rand_state = x;\n        (x as f64) / (u64::MAX as f64)\n    }\n}\n\nfn regex_sub_helper(re: \u0026regex::Regex, replacement: \u0026str, target: \u0026str, global: bool) -\u003e (String, usize) {\n    // Handle \u0026 in replacement (matched text)\n    let mut count = 0;\n\n    if global {\n        let result = re.replace_all(target, |caps: \u0026regex::Captures| {\n            count += 1;\n            replacement.replace(\"\u0026\", caps.get(0).map(|m| m.as_str()).unwrap_or(\"\"))\n        });\n        (result.to_string(), count)\n    } else {\n        let result = re.replace(target, |caps: \u0026regex::Captures| {\n            count += 1;\n            replacement.replace(\"\u0026\", caps.get(0).map(|m| m.as_str()).unwrap_or(\"\"))\n        });\n        (result.to_string(), count)\n    }\n}\n\n/// Simplified mktime implementation (UTC-based)\nfn simple_mktime(year: i64, month: i64, day: i64, hour: i64, min: i64, sec: i64) -\u003e i64 {\n    // Days in each month (non-leap year)\n    const DAYS_IN_MONTH: [i64; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    fn is_leap_year(year: i64) -\u003e bool {\n        (year % 4 == 0 \u0026\u0026 year % 100 != 0) || (year % 400 == 0)\n    }\n\n    fn days_in_year(year: i64) -\u003e i64 {\n        if is_leap_year(year) { 366 } else { 365 }\n    }\n\n    // Calculate days from epoch (1970-01-01)\n    let mut days: i64 = 0;\n\n    // Add days for complete years\n    for y in 1970..year {\n        days += days_in_year(y);\n    }\n    for y in year..1970 {\n        days -= days_in_year(y);\n    }\n\n    // Add days for complete months in current year\n    for m in 1..month {\n        let m_idx = (m - 1) as usize;\n        if m_idx \u003c 12 {\n            days += DAYS_IN_MONTH[m_idx];\n            if m == 2 \u0026\u0026 is_leap_year(year) {\n                days += 1;\n            }\n        }\n    }\n\n    // Add remaining days\n    days += day - 1;\n\n    // Convert to seconds\n    days * 86400 + hour * 3600 + min * 60 + sec\n}\n\n/// Simplified strftime implementation\nfn format_strftime(format: \u0026str, timestamp: u64) -\u003e String {\n    // Break down timestamp into components\n    let secs = timestamp as i64;\n\n    // Calculate year, month, day, etc.\n    let (year, month, day, hour, min, sec, wday, yday) = breakdown_time(secs);\n\n    let weekday_names = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n    let month_names = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    let weekday_full = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    let month_full = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n\n    let mut result = String::new();\n    let mut chars = format.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch == '%' {\n            match chars.next() {\n                Some('Y') =\u003e result.push_str(\u0026format!(\"{:04}\", year)),\n                Some('y') =\u003e result.push_str(\u0026format!(\"{:02}\", year % 100)),\n                Some('m') =\u003e result.push_str(\u0026format!(\"{:02}\", month)),\n                Some('d') =\u003e result.push_str(\u0026format!(\"{:02}\", day)),\n                Some('e') =\u003e result.push_str(\u0026format!(\"{:2}\", day)),\n                Some('H') =\u003e result.push_str(\u0026format!(\"{:02}\", hour)),\n                Some('M') =\u003e result.push_str(\u0026format!(\"{:02}\", min)),\n                Some('S') =\u003e result.push_str(\u0026format!(\"{:02}\", sec)),\n                Some('a') =\u003e result.push_str(weekday_names.get(wday as usize).unwrap_or(\u0026\"???\")),\n                Some('A') =\u003e result.push_str(weekday_full.get(wday as usize).unwrap_or(\u0026\"???\")),\n                Some('b') | Some('h') =\u003e result.push_str(month_names.get((month - 1) as usize).unwrap_or(\u0026\"???\")),\n                Some('B') =\u003e result.push_str(month_full.get((month - 1) as usize).unwrap_or(\u0026\"???\")),\n                Some('j') =\u003e result.push_str(\u0026format!(\"{:03}\", yday)),\n                Some('u') =\u003e result.push_str(\u0026format!(\"{}\", if wday == 0 { 7 } else { wday })),\n                Some('w') =\u003e result.push_str(\u0026format!(\"{}\", wday)),\n                Some('Z') =\u003e result.push_str(\"UTC\"),\n                Some('z') =\u003e result.push_str(\"+0000\"),\n                Some('%') =\u003e result.push('%'),\n                Some('n') =\u003e result.push('\\n'),\n                Some('t') =\u003e result.push('\\t'),\n                Some(c) =\u003e { result.push('%'); result.push(c); }\n                None =\u003e result.push('%'),\n            }\n        } else {\n            result.push(ch);\n        }\n    }\n\n    result\n}\n\n/// Break down epoch seconds into date/time components\nfn breakdown_time(secs: i64) -\u003e (i64, i64, i64, i64, i64, i64, i64, i64) {\n    const DAYS_IN_MONTH: [i64; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    fn is_leap_year(year: i64) -\u003e bool {\n        (year % 4 == 0 \u0026\u0026 year % 100 != 0) || (year % 400 == 0)\n    }\n\n    let sec = secs % 60;\n    let min = (secs / 60) % 60;\n    let hour = (secs / 3600) % 24;\n    let mut days = secs / 86400;\n\n    // wday: 0 = Sunday, 1970-01-01 was Thursday (4)\n    let wday = ((days + 4) % 7 + 7) % 7;\n\n    // Calculate year\n    let mut year = 1970i64;\n    loop {\n        let days_in_year = if is_leap_year(year) { 366 } else { 365 };\n        if days \u003e= days_in_year {\n            days -= days_in_year;\n            year += 1;\n        } else if days \u003c 0 {\n            year -= 1;\n            let days_in_year = if is_leap_year(year) { 366 } else { 365 };\n            days += days_in_year;\n        } else {\n            break;\n        }\n    }\n\n    let yday = days + 1; // 1-based day of year\n\n    // Calculate month and day\n    let mut month = 1i64;\n    for m in 0..12 {\n        let mut dim = DAYS_IN_MONTH[m];\n        if m == 1 \u0026\u0026 is_leap_year(year) {\n            dim += 1;\n        }\n        if days \u003c dim {\n            month = m as i64 + 1;\n            break;\n        }\n        days -= dim;\n    }\n    let day = days + 1;\n\n    (year, month, day, hour, min, sec, wday, yday)\n}\n","traces":[{"line":11,"address":[2921591,2921559,2919216],"length":1,"stats":{"Line":15}},{"line":19,"address":[2252738],"length":1,"stats":{"Line":15}},{"line":20,"address":[2830266,2832586],"length":1,"stats":{"Line":16}},{"line":21,"address":[2919646,2919534],"length":1,"stats":{"Line":21}},{"line":22,"address":[2253092,2252931],"length":1,"stats":{"Line":23}},{"line":23,"address":[],"length":0,"stats":{"Line":19}},{"line":24,"address":[2480319,2480405],"length":1,"stats":{"Line":29}},{"line":25,"address":[2289055,2289167],"length":1,"stats":{"Line":14}},{"line":26,"address":[2289092,2289257],"length":1,"stats":{"Line":15}},{"line":27,"address":[2289422,2289178],"length":1,"stats":{"Line":15}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[2645790],"length":1,"stats":{"Line":44}},{"line":33,"address":[2289326,2289436],"length":1,"stats":{"Line":10}},{"line":36,"address":[2482089,2481037,2481122],"length":1,"stats":{"Line":21}},{"line":37,"address":[2834059,2831739],"length":1,"stats":{"Line":5}},{"line":41,"address":[2481526,2481589],"length":1,"stats":{"Line":7}},{"line":43,"address":[2481675,2481749],"length":1,"stats":{"Line":9}},{"line":44,"address":[2511906],"length":1,"stats":{"Line":4}},{"line":45,"address":[2868530,2868370],"length":1,"stats":{"Line":1}},{"line":46,"address":[2511975],"length":1,"stats":{"Line":1}},{"line":49,"address":[2895188],"length":1,"stats":{"Line":5}},{"line":50,"address":[2921202],"length":1,"stats":{"Line":12}},{"line":51,"address":[2646863],"length":1,"stats":{"Line":3}},{"line":54,"address":[2647059],"length":1,"stats":{"Line":0}},{"line":55,"address":[2921327,2921131],"length":1,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[3365927],"length":1,"stats":{"Line":2}},{"line":65,"address":[3080352,3080425],"length":1,"stats":{"Line":4}},{"line":70,"address":[2733769,2731008,2732378],"length":1,"stats":{"Line":5}},{"line":71,"address":[3088781],"length":1,"stats":{"Line":6}},{"line":73,"address":[3088895,3088842,3088979],"length":1,"stats":{"Line":11}},{"line":74,"address":[3088859],"length":1,"stats":{"Line":18}},{"line":78,"address":[2733767,2731678,2731587,2731458],"length":1,"stats":{"Line":12}},{"line":79,"address":[3363546],"length":1,"stats":{"Line":18}},{"line":81,"address":[],"length":0,"stats":{"Line":19}},{"line":85,"address":[3089979,3089450,3089520,3090145],"length":1,"stats":{"Line":23}},{"line":86,"address":[],"length":0,"stats":{"Line":7}},{"line":88,"address":[3363999,3364469],"length":1,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":11}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[3079214,3079303],"length":1,"stats":{"Line":11}},{"line":98,"address":[3365106],"length":1,"stats":{"Line":7}},{"line":99,"address":[3079510,3079655],"length":1,"stats":{"Line":7}},{"line":101,"address":[2733156,2733598],"length":1,"stats":{"Line":6}},{"line":104,"address":[2733398],"length":1,"stats":{"Line":4}},{"line":108,"address":[2711445,2709872,2711402],"length":1,"stats":{"Line":6}},{"line":109,"address":[2709954,2710001,2710081],"length":1,"stats":{"Line":4}},{"line":110,"address":[3341296],"length":1,"stats":{"Line":14}},{"line":112,"address":[3341471],"length":1,"stats":{"Line":14}},{"line":115,"address":[3057172,3055885,3056114,3056006],"length":1,"stats":{"Line":4}},{"line":116,"address":[2881461,2881440],"length":1,"stats":{"Line":13}},{"line":120,"address":[2893022,2892752],"length":1,"stats":{"Line":7}},{"line":121,"address":[2892808,2892876],"length":1,"stats":{"Line":0}},{"line":124,"address":[2710817,2711110,2710904],"length":1,"stats":{"Line":8}},{"line":125,"address":[3056849,3056902,3056711],"length":1,"stats":{"Line":7}},{"line":126,"address":[3068155,3068200],"length":1,"stats":{"Line":7}},{"line":127,"address":[3342590],"length":1,"stats":{"Line":5}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[2711015],"length":1,"stats":{"Line":1}},{"line":131,"address":[2711025],"length":1,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[3057309,3057446,3057362],"length":1,"stats":{"Line":16}},{"line":138,"address":[2893360,2893381],"length":1,"stats":{"Line":24}},{"line":140,"address":[3343152],"length":1,"stats":{"Line":24}},{"line":144,"address":[],"length":0,"stats":{"Line":16}},{"line":145,"address":[3343534,3343612],"length":1,"stats":{"Line":14}},{"line":146,"address":[2712172,2712249],"length":1,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[3069116,3071481],"length":1,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[3057844],"length":1,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[3343408],"length":1,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[3343392],"length":1,"stats":{"Line":0}},{"line":158,"address":[3057752],"length":1,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":14}},{"line":165,"address":[],"length":0,"stats":{"Line":8}},{"line":167,"address":[3069410,3069734],"length":1,"stats":{"Line":4}},{"line":171,"address":[3344164,3344060],"length":1,"stats":{"Line":14}},{"line":174,"address":[2712762],"length":1,"stats":{"Line":7}},{"line":175,"address":[2712835,2713510],"length":1,"stats":{"Line":6}},{"line":176,"address":[3069906,3069849],"length":1,"stats":{"Line":8}},{"line":177,"address":[3069990,3069920],"length":1,"stats":{"Line":6}},{"line":180,"address":[2882062,2881792],"length":1,"stats":{"Line":2}},{"line":181,"address":[2893112,2893180],"length":1,"stats":{"Line":0}},{"line":183,"address":[3059110,3059203],"length":1,"stats":{"Line":2}},{"line":186,"address":[3345058,3344430],"length":1,"stats":{"Line":8}},{"line":187,"address":[2714081,2713837],"length":1,"stats":{"Line":10}},{"line":188,"address":[2714144,2714233],"length":1,"stats":{"Line":11}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[2706288,2708344,2708524],"length":1,"stats":{"Line":2}},{"line":198,"address":[3063224],"length":1,"stats":{"Line":2}},{"line":199,"address":[3052050],"length":1,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[3054153,3052037],"length":1,"stats":{"Line":2}},{"line":203,"address":[3065390],"length":1,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[3337827,3337751],"length":1,"stats":{"Line":2}},{"line":212,"address":[2706838,2706779],"length":1,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[3339673],"length":1,"stats":{"Line":0}},{"line":216,"address":[3339628,3338002],"length":1,"stats":{"Line":0}},{"line":217,"address":[3339601],"length":1,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[2706948,2706746],"length":1,"stats":{"Line":2}},{"line":226,"address":[3338195],"length":1,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":6}},{"line":229,"address":[3338231,3338277],"length":1,"stats":{"Line":11}},{"line":232,"address":[3052808,3052553],"length":1,"stats":{"Line":2}},{"line":235,"address":[3338333],"length":1,"stats":{"Line":1}},{"line":236,"address":[3052717,3052870],"length":1,"stats":{"Line":2}},{"line":238,"address":[3338529],"length":1,"stats":{"Line":1}},{"line":241,"address":[2892385,2892368],"length":1,"stats":{"Line":3}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":8}},{"line":246,"address":[3053776,3053687],"length":1,"stats":{"Line":14}},{"line":249,"address":[2707865],"length":1,"stats":{"Line":1}},{"line":253,"address":[3358704,3361851,3362994],"length":1,"stats":{"Line":5}},{"line":255,"address":[3358829,3358882,3358966],"length":1,"stats":{"Line":10}},{"line":256,"address":[2726989],"length":1,"stats":{"Line":15}},{"line":258,"address":[2884064,2884048],"length":1,"stats":{"Line":15}},{"line":262,"address":[3073526,3073450],"length":1,"stats":{"Line":10}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[3084862,3088590],"length":1,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[2727463,2727530],"length":1,"stats":{"Line":8}},{"line":275,"address":[2727670,2730912,2727601],"length":1,"stats":{"Line":7}},{"line":277,"address":[2730922,2727624],"length":1,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[3085451,3085375],"length":1,"stats":{"Line":8}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[2727996],"length":1,"stats":{"Line":3}},{"line":288,"address":[2728094],"length":1,"stats":{"Line":0}},{"line":292,"address":[3074464,3074271],"length":1,"stats":{"Line":7}},{"line":293,"address":[2728222],"length":1,"stats":{"Line":4}},{"line":294,"address":[2728344,2728283],"length":1,"stats":{"Line":2}},{"line":298,"address":[2728383,2728313],"length":1,"stats":{"Line":6}},{"line":299,"address":[2728554],"length":1,"stats":{"Line":4}},{"line":302,"address":[3074924,3075019],"length":1,"stats":{"Line":8}},{"line":303,"address":[2728985,2730530],"length":1,"stats":{"Line":6}},{"line":304,"address":[2730682,2730593],"length":1,"stats":{"Line":6}},{"line":308,"address":[3075323],"length":1,"stats":{"Line":1}},{"line":309,"address":[3086640],"length":1,"stats":{"Line":1}},{"line":310,"address":[3075469,3075388],"length":1,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[3076321],"length":1,"stats":{"Line":1}},{"line":313,"address":[3076457,3076356],"length":1,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[3087042],"length":1,"stats":{"Line":1}},{"line":318,"address":[2729626,2729519],"length":1,"stats":{"Line":2}},{"line":321,"address":[2729118,2730327],"length":1,"stats":{"Line":2}},{"line":325,"address":[3358608],"length":1,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[2726780],"length":1,"stats":{"Line":0}},{"line":335,"address":[3341179,3339920,3340970],"length":1,"stats":{"Line":1}},{"line":336,"address":[2708760,2708807,2708887],"length":1,"stats":{"Line":3}},{"line":337,"address":[2865600,2865621],"length":1,"stats":{"Line":3}},{"line":339,"address":[2892480,2892464],"length":1,"stats":{"Line":4}},{"line":343,"address":[2708997,2709840,2709068],"length":1,"stats":{"Line":4}},{"line":344,"address":[2709755],"length":1,"stats":{"Line":1}},{"line":345,"address":[3341066,3340467],"length":1,"stats":{"Line":1}},{"line":346,"address":[2709660],"length":1,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[3066499],"length":1,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[3055124],"length":1,"stats":{"Line":1}},{"line":356,"address":[2287972,2287978,2286592],"length":1,"stats":{"Line":1}},{"line":357,"address":[2826869,2828425,2828533,2830089],"length":1,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[2633359,2633290],"length":1,"stats":{"Line":2}},{"line":361,"address":[2479652],"length":1,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":365,"address":[2917706,2917604],"length":1,"stats":{"Line":0}},{"line":366,"address":[2287158,2287949],"length":1,"stats":{"Line":0}},{"line":367,"address":[2828092,2829041,2829515,2827377,2829756,2827851],"length":1,"stats":{"Line":0}},{"line":368,"address":[2252115],"length":1,"stats":{"Line":0}},{"line":369,"address":[2478711,2478655,2478876],"length":1,"stats":{"Line":0}},{"line":370,"address":[2643806,2644187,2643925],"length":1,"stats":{"Line":0}},{"line":371,"address":[2918467],"length":1,"stats":{"Line":0}},{"line":373,"address":[2251570],"length":1,"stats":{"Line":0}},{"line":378,"address":[3060400,3068071,3067094],"length":1,"stats":{"Line":10}},{"line":379,"address":[3346188],"length":1,"stats":{"Line":9}},{"line":381,"address":[3060548],"length":1,"stats":{"Line":10}},{"line":382,"address":[],"length":0,"stats":{"Line":13}},{"line":384,"address":[],"length":0,"stats":{"Line":6}},{"line":387,"address":[],"length":0,"stats":{"Line":8}},{"line":388,"address":[2714980],"length":1,"stats":{"Line":9}},{"line":389,"address":[3346542,3357533],"length":1,"stats":{"Line":12}},{"line":390,"address":[2725804],"length":1,"stats":{"Line":9}},{"line":393,"address":[],"length":0,"stats":{"Line":3}},{"line":394,"address":[3072133],"length":1,"stats":{"Line":3}},{"line":395,"address":[3357879,3357824],"length":1,"stats":{"Line":6}},{"line":397,"address":[],"length":0,"stats":{"Line":4}},{"line":399,"address":[3357991,3358147],"length":1,"stats":{"Line":6}},{"line":402,"address":[],"length":0,"stats":{"Line":8}},{"line":403,"address":[3346628],"length":1,"stats":{"Line":21}},{"line":404,"address":[3072322,3082644],"length":1,"stats":{"Line":28}},{"line":406,"address":[2725352,2725477,2725261],"length":1,"stats":{"Line":23}},{"line":408,"address":[2867470,2867532],"length":1,"stats":{"Line":4}},{"line":409,"address":[3357267],"length":1,"stats":{"Line":9}},{"line":410,"address":[2725485],"length":1,"stats":{"Line":5}},{"line":413,"address":[2715085],"length":1,"stats":{"Line":6}},{"line":414,"address":[2867584,2867600],"length":1,"stats":{"Line":24}},{"line":415,"address":[3070909,3071082,3061197],"length":1,"stats":{"Line":16}},{"line":416,"address":[3356647,3356772],"length":1,"stats":{"Line":16}},{"line":417,"address":[3082439],"length":1,"stats":{"Line":7}},{"line":420,"address":[3346749],"length":1,"stats":{"Line":6}},{"line":421,"address":[3072535],"length":1,"stats":{"Line":15}},{"line":422,"address":[2724564,2715462],"length":1,"stats":{"Line":10}},{"line":425,"address":[3346876],"length":1,"stats":{"Line":5}},{"line":426,"address":[3061434],"length":1,"stats":{"Line":9}},{"line":427,"address":[3081737,3072776],"length":1,"stats":{"Line":6}},{"line":431,"address":[3347039],"length":1,"stats":{"Line":5}},{"line":432,"address":[3168521,3168512],"length":1,"stats":{"Line":9}},{"line":433,"address":[2715734],"length":1,"stats":{"Line":3}},{"line":436,"address":[3072818],"length":1,"stats":{"Line":4}},{"line":437,"address":[2882896,2882905],"length":1,"stats":{"Line":6}},{"line":438,"address":[3061898],"length":1,"stats":{"Line":2}},{"line":441,"address":[3061816],"length":1,"stats":{"Line":5}},{"line":442,"address":[2894233,2894224],"length":1,"stats":{"Line":6}},{"line":443,"address":[3073449],"length":1,"stats":{"Line":6}},{"line":444,"address":[3062238],"length":1,"stats":{"Line":2}},{"line":447,"address":[3347726],"length":1,"stats":{"Line":3}},{"line":448,"address":[2867040,2867049],"length":1,"stats":{"Line":8}},{"line":449,"address":[3348148],"length":1,"stats":{"Line":3}},{"line":452,"address":[3062418],"length":1,"stats":{"Line":4}},{"line":453,"address":[2894825,2894816],"length":1,"stats":{"Line":3}},{"line":454,"address":[2716845],"length":1,"stats":{"Line":1}},{"line":457,"address":[3348328],"length":1,"stats":{"Line":4}},{"line":458,"address":[3348636],"length":1,"stats":{"Line":15}},{"line":459,"address":[3348672],"length":1,"stats":{"Line":5}},{"line":462,"address":[2717025],"length":1,"stats":{"Line":4}},{"line":463,"address":[3348898],"length":1,"stats":{"Line":9}},{"line":464,"address":[3063286],"length":1,"stats":{"Line":3}},{"line":467,"address":[2717284],"length":1,"stats":{"Line":4}},{"line":469,"address":[],"length":0,"stats":{"Line":1}},{"line":470,"address":[],"length":0,"stats":{"Line":1}},{"line":473,"address":[2717543],"length":1,"stats":{"Line":4}},{"line":474,"address":[3063744],"length":1,"stats":{"Line":3}},{"line":475,"address":[2717844,2723921,2723808],"length":1,"stats":{"Line":7}},{"line":476,"address":[3069979],"length":1,"stats":{"Line":2}},{"line":479,"address":[2723923,2724021],"length":1,"stats":{"Line":2}},{"line":480,"address":[3355747],"length":1,"stats":{"Line":1}},{"line":481,"address":[3355775],"length":1,"stats":{"Line":3}},{"line":482,"address":[3081413],"length":1,"stats":{"Line":1}},{"line":484,"address":[2724052],"length":1,"stats":{"Line":2}},{"line":485,"address":[],"length":0,"stats":{"Line":2}},{"line":489,"address":[],"length":0,"stats":{"Line":4}},{"line":490,"address":[3349528],"length":1,"stats":{"Line":9}},{"line":491,"address":[3081017,3075206],"length":1,"stats":{"Line":6}},{"line":493,"address":[3355282],"length":1,"stats":{"Line":3}},{"line":495,"address":[3069688],"length":1,"stats":{"Line":9}},{"line":496,"address":[],"length":0,"stats":{"Line":6}},{"line":497,"address":[3355442],"length":1,"stats":{"Line":3}},{"line":503,"address":[3075101],"length":1,"stats":{"Line":4}},{"line":506,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[3349694],"length":1,"stats":{"Line":2}},{"line":508,"address":[2893616,2893628],"length":1,"stats":{"Line":6}},{"line":510,"address":[],"length":0,"stats":{"Line":2}},{"line":513,"address":[2718052],"length":1,"stats":{"Line":4}},{"line":515,"address":[],"length":0,"stats":{"Line":6}},{"line":516,"address":[3064495,3068525],"length":1,"stats":{"Line":4}},{"line":517,"address":[3168928,3168947],"length":1,"stats":{"Line":6}},{"line":520,"address":[],"length":0,"stats":{"Line":7}},{"line":523,"address":[3080171,3080103],"length":1,"stats":{"Line":4}},{"line":524,"address":[],"length":0,"stats":{"Line":2}},{"line":525,"address":[3068992],"length":1,"stats":{"Line":2}},{"line":526,"address":[3354706],"length":1,"stats":{"Line":4}},{"line":527,"address":[3080388],"length":1,"stats":{"Line":2}},{"line":528,"address":[3080454],"length":1,"stats":{"Line":2}},{"line":531,"address":[3080552],"length":1,"stats":{"Line":2}},{"line":532,"address":[3069327],"length":1,"stats":{"Line":1}},{"line":534,"address":[],"length":0,"stats":{"Line":1}},{"line":538,"address":[3350022],"length":1,"stats":{"Line":4}},{"line":540,"address":[2894912,2894924,2894688,2894672],"length":1,"stats":{"Line":18}},{"line":542,"address":[2718698,2722123],"length":1,"stats":{"Line":13}},{"line":543,"address":[2722054],"length":1,"stats":{"Line":21}},{"line":544,"address":[2882272],"length":1,"stats":{"Line":7}},{"line":545,"address":[3167924],"length":1,"stats":{"Line":0}},{"line":546,"address":[2893555],"length":1,"stats":{"Line":0}},{"line":547,"address":[3169420,3167961,3169408],"length":1,"stats":{"Line":0}},{"line":548,"address":[2867432],"length":1,"stats":{"Line":0}},{"line":551,"address":[3079490],"length":1,"stats":{"Line":7}},{"line":552,"address":[],"length":0,"stats":{"Line":3}},{"line":556,"address":[3075801],"length":1,"stats":{"Line":4}},{"line":557,"address":[3076058],"length":1,"stats":{"Line":5}},{"line":558,"address":[2718886,2718977],"length":1,"stats":{"Line":10}},{"line":559,"address":[3065102,3065026],"length":1,"stats":{"Line":11}},{"line":560,"address":[3169232,3168800,3169248,3168817],"length":1,"stats":{"Line":17}},{"line":562,"address":[3351062,3350971],"length":1,"stats":{"Line":8}},{"line":565,"address":[3351253],"length":1,"stats":{"Line":5}},{"line":566,"address":[3065722,3067514],"length":1,"stats":{"Line":5}},{"line":567,"address":[2719798,2719652,2719725,2720960],"length":1,"stats":{"Line":6}},{"line":569,"address":[3065861],"length":1,"stats":{"Line":3}},{"line":570,"address":[3351521],"length":1,"stats":{"Line":3}},{"line":571,"address":[3077157],"length":1,"stats":{"Line":2}},{"line":572,"address":[3351548,3351663,3351790],"length":1,"stats":{"Line":7}},{"line":573,"address":[3077569,3077501,3077592],"length":1,"stats":{"Line":4}},{"line":574,"address":[],"length":0,"stats":{"Line":1}},{"line":575,"address":[3351996],"length":1,"stats":{"Line":3}},{"line":576,"address":[3066484],"length":1,"stats":{"Line":1}},{"line":577,"address":[],"length":0,"stats":{"Line":3}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":1}},{"line":582,"address":[3066898,3066964],"length":1,"stats":{"Line":6}},{"line":583,"address":[2720911,2720950],"length":1,"stats":{"Line":0}},{"line":585,"address":[3078172],"length":1,"stats":{"Line":1}},{"line":589,"address":[3067140,3065811],"length":1,"stats":{"Line":0}},{"line":592,"address":[3352684,3353504],"length":1,"stats":{"Line":5}},{"line":595,"address":[3064703],"length":1,"stats":{"Line":4}},{"line":599,"address":[2640576,2638994,2635952],"length":1,"stats":{"Line":3}},{"line":607,"address":[2921698,2921821],"length":1,"stats":{"Line":8}},{"line":608,"address":[3170484,3170557,3170528,3170448],"length":1,"stats":{"Line":19}},{"line":612,"address":[2835144,2835057,2839560,2839473],"length":1,"stats":{"Line":12}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[2839611,2835195],"length":1,"stats":{"Line":17}},{"line":619,"address":[2255456],"length":1,"stats":{"Line":3}},{"line":620,"address":[],"length":0,"stats":{"Line":12}},{"line":621,"address":[2486364,2483119],"length":1,"stats":{"Line":12}},{"line":624,"address":[2925956],"length":1,"stats":{"Line":1}},{"line":625,"address":[2651616],"length":1,"stats":{"Line":1}},{"line":629,"address":[2922613],"length":1,"stats":{"Line":3}},{"line":632,"address":[],"length":0,"stats":{"Line":9}},{"line":634,"address":[2483690,2485914],"length":1,"stats":{"Line":11}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[2486026],"length":1,"stats":{"Line":6}},{"line":638,"address":[2838656,2838584,2843072,2843000],"length":1,"stats":{"Line":12}},{"line":642,"address":[2292272],"length":1,"stats":{"Line":3}},{"line":643,"address":[2256807],"length":1,"stats":{"Line":4}},{"line":644,"address":[2484153],"length":1,"stats":{"Line":2}},{"line":648,"address":[2292707],"length":1,"stats":{"Line":4}},{"line":651,"address":[2257033],"length":1,"stats":{"Line":5}},{"line":652,"address":[],"length":0,"stats":{"Line":6}},{"line":653,"address":[],"length":0,"stats":{"Line":6}},{"line":655,"address":[2294204,2294312],"length":1,"stats":{"Line":6}},{"line":660,"address":[2292976],"length":1,"stats":{"Line":4}},{"line":661,"address":[2293385,2293129],"length":1,"stats":{"Line":10}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[2161054,2161040],"length":1,"stats":{"Line":24}},{"line":664,"address":[2639270],"length":1,"stats":{"Line":19}},{"line":665,"address":[2837932,2842348],"length":1,"stats":{"Line":7}},{"line":667,"address":[2924979],"length":1,"stats":{"Line":6}},{"line":671,"address":[2649723],"length":1,"stats":{"Line":4}},{"line":675,"address":[3345904],"length":1,"stats":{"Line":1}},{"line":676,"address":[],"length":0,"stats":{"Line":1}},{"line":677,"address":[3071537],"length":1,"stats":{"Line":1}},{"line":678,"address":[3071557],"length":1,"stats":{"Line":1}},{"line":679,"address":[3071577],"length":1,"stats":{"Line":1}},{"line":680,"address":[3345981],"length":1,"stats":{"Line":1}},{"line":681,"address":[],"length":0,"stats":{"Line":1}},{"line":685,"address":[3376329,3376335,3375888],"length":1,"stats":{"Line":7}},{"line":687,"address":[2400149],"length":1,"stats":{"Line":6}},{"line":689,"address":[3375998],"length":1,"stats":{"Line":6}},{"line":690,"address":[2880784],"length":1,"stats":{"Line":10}},{"line":691,"address":[2865429,2865266],"length":1,"stats":{"Line":4}},{"line":692,"address":[2865472,2865314,2865473],"length":1,"stats":{"Line":15}},{"line":694,"address":[3101806,3102007],"length":1,"stats":{"Line":6}},{"line":696,"address":[2880560],"length":1,"stats":{"Line":14}},{"line":697,"address":[2880594,2880760],"length":1,"stats":{"Line":7}},{"line":698,"address":[2881008,2880642,2881009],"length":1,"stats":{"Line":21}},{"line":700,"address":[3376258,3376091],"length":1,"stats":{"Line":14}},{"line":705,"address":[2391440],"length":1,"stats":{"Line":2}},{"line":709,"address":[3081312],"length":1,"stats":{"Line":1}},{"line":710,"address":[3092589,3092757],"length":1,"stats":{"Line":2}},{"line":713,"address":[3366912],"length":1,"stats":{"Line":1}},{"line":714,"address":[3092537],"length":1,"stats":{"Line":1}},{"line":718,"address":[2391543],"length":1,"stats":{"Line":3}},{"line":721,"address":[3092915,3093905],"length":1,"stats":{"Line":3}},{"line":722,"address":[2392544,2392531,2391640],"length":1,"stats":{"Line":2}},{"line":724,"address":[3367423,3368258],"length":1,"stats":{"Line":1}},{"line":725,"address":[2392500,2391762,2392513],"length":1,"stats":{"Line":0}},{"line":729,"address":[3081905,3081932],"length":1,"stats":{"Line":2}},{"line":730,"address":[3367645,3368029,3368010],"length":1,"stats":{"Line":2}},{"line":731,"address":[3368018],"length":1,"stats":{"Line":1}},{"line":732,"address":[3093779,3093658],"length":1,"stats":{"Line":1}},{"line":733,"address":[3082533,3082504,3082579],"length":1,"stats":{"Line":1}},{"line":734,"address":[3368232,3368195],"length":1,"stats":{"Line":0}},{"line":740,"address":[3082117,3082027],"length":1,"stats":{"Line":1}},{"line":743,"address":[3093355,3093402,3093608],"length":1,"stats":{"Line":2}},{"line":747,"address":[3375873,3372827,3370176],"length":1,"stats":{"Line":7}},{"line":749,"address":[3370258],"length":1,"stats":{"Line":7}},{"line":752,"address":[2394514],"length":1,"stats":{"Line":7}},{"line":754,"address":[3370407],"length":1,"stats":{"Line":7}},{"line":755,"address":[3084948],"length":1,"stats":{"Line":7}},{"line":756,"address":[3370920],"length":1,"stats":{"Line":7}},{"line":757,"address":[3085461],"length":1,"stats":{"Line":7}},{"line":759,"address":[3371434],"length":1,"stats":{"Line":7}},{"line":760,"address":[3097071,3097154],"length":1,"stats":{"Line":14}},{"line":762,"address":[3097175],"length":1,"stats":{"Line":7}},{"line":763,"address":[3097266],"length":1,"stats":{"Line":7}},{"line":764,"address":[3371716,3371774],"length":1,"stats":{"Line":14}},{"line":765,"address":[3097553,3098193],"length":1,"stats":{"Line":6}},{"line":766,"address":[3372833,3371967],"length":1,"stats":{"Line":0}},{"line":767,"address":[3373237,3371980],"length":1,"stats":{"Line":6}},{"line":768,"address":[3373487,3372018],"length":1,"stats":{"Line":6}},{"line":769,"address":[3086408,3088089],"length":1,"stats":{"Line":0}},{"line":770,"address":[3372094,3373987],"length":1,"stats":{"Line":4}},{"line":771,"address":[3099853,3097748],"length":1,"stats":{"Line":3}},{"line":772,"address":[3100097,3097786],"length":1,"stats":{"Line":4}},{"line":773,"address":[2398907,2396400],"length":1,"stats":{"Line":2}},{"line":774,"address":[3089142,3086595],"length":1,"stats":{"Line":0}},{"line":775,"address":[2399038,2396478],"length":1,"stats":{"Line":2}},{"line":776,"address":[2396511,2399148],"length":1,"stats":{"Line":0}},{"line":777,"address":[3372360,3375081],"length":1,"stats":{"Line":0}},{"line":778,"address":[3375319,3372390],"length":1,"stats":{"Line":0}},{"line":779,"address":[3372418,3375600],"length":1,"stats":{"Line":0}},{"line":780,"address":[3375816,3372448],"length":1,"stats":{"Line":0}},{"line":781,"address":[2399973,2396662],"length":1,"stats":{"Line":0}},{"line":782,"address":[3372521,3375826],"length":1,"stats":{"Line":0}},{"line":783,"address":[3098160,3101447],"length":1,"stats":{"Line":0}},{"line":784,"address":[2399988,2396751],"length":1,"stats":{"Line":0}},{"line":785,"address":[2396113,2400008],"length":1,"stats":{"Line":0}},{"line":786,"address":[3086225],"length":1,"stats":{"Line":0}},{"line":789,"address":[3375868,3371757],"length":1,"stats":{"Line":8}},{"line":793,"address":[2395905],"length":1,"stats":{"Line":3}},{"line":797,"address":[3082896],"length":1,"stats":{"Line":7}},{"line":800,"address":[3093936],"length":1,"stats":{"Line":7}},{"line":801,"address":[3082853,3082685],"length":1,"stats":{"Line":14}},{"line":804,"address":[2392824,2392912],"length":1,"stats":{"Line":7}},{"line":805,"address":[3368693,3368648,3368814],"length":1,"stats":{"Line":14}},{"line":806,"address":[2393030,2393187,2393075],"length":1,"stats":{"Line":14}},{"line":807,"address":[3083320,3083275,3083362],"length":1,"stats":{"Line":14}},{"line":810,"address":[3083380,3083338,3083545],"length":1,"stats":{"Line":14}},{"line":813,"address":[3094795],"length":1,"stats":{"Line":7}},{"line":814,"address":[3094807],"length":1,"stats":{"Line":7}},{"line":815,"address":[3083558],"length":1,"stats":{"Line":7}},{"line":816,"address":[2394385,2394305,2393489],"length":1,"stats":{"Line":8}},{"line":817,"address":[3095704,3095735,3094896],"length":1,"stats":{"Line":2}},{"line":818,"address":[2394377,2394336,2394390],"length":1,"stats":{"Line":2}},{"line":819,"address":[3369267],"length":1,"stats":{"Line":6}},{"line":820,"address":[3084339,3083693,3084312],"length":1,"stats":{"Line":0}},{"line":821,"address":[3084352,3084320],"length":1,"stats":{"Line":0}},{"line":822,"address":[3084378,3084422],"length":1,"stats":{"Line":0}},{"line":828,"address":[3095045,3094992,3094934],"length":1,"stats":{"Line":12}},{"line":831,"address":[2393624],"length":1,"stats":{"Line":6}},{"line":832,"address":[3084129,3083794,3083748],"length":1,"stats":{"Line":14}},{"line":833,"address":[3369609,3369580,3369507],"length":1,"stats":{"Line":14}},{"line":834,"address":[3369698,3369627,3369596],"length":1,"stats":{"Line":8}},{"line":835,"address":[2393904,2393940],"length":1,"stats":{"Line":0}},{"line":837,"address":[2393884],"length":1,"stats":{"Line":7}},{"line":838,"address":[3084152,3084101],"length":1,"stats":{"Line":12}},{"line":841,"address":[3095329,3095385,3095398],"length":1,"stats":{"Line":2}},{"line":843,"address":[3084230,3083897,3084294],"length":1,"stats":{"Line":12}},{"line":845,"address":[3084238],"length":1,"stats":{"Line":7}}],"covered":380,"coverable":460},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","interpreter","expr.rs"],"content":"use std::io::Write;\n\nuse crate::ast::*;\nuse crate::error::Result;\nuse crate::value::{compare_values, Value};\n\nuse super::Interpreter;\n\nimpl\u003c'a\u003e Interpreter\u003c'a\u003e {\n    /// Evaluate an expression (for contexts where we don't have output, like condition checking)\n    pub fn eval_expr(\u0026mut self, expr: \u0026Expr) -\u003e Result\u003cValue\u003e {\n        // Use a null writer for function calls that might need output\n        let mut null = std::io::sink();\n        self.eval_expr_with_output(expr, \u0026mut null)\n    }\n\n    /// Evaluate an expression with a writer for function calls that produce output\n    pub fn eval_expr_with_output\u003cW: Write\u003e(\u0026mut self, expr: \u0026Expr, output: \u0026mut W) -\u003e Result\u003cValue\u003e {\n        match expr {\n            Expr::Number(n, _) =\u003e Ok(Value::Number(*n)),\n\n            Expr::String(s, _) =\u003e Ok(Value::from_string(s.clone())),\n\n            Expr::Regex(pattern, _) =\u003e {\n                // Regex in expression context matches against $0\n                let record = self.record.clone();\n                let re = self.get_regex(pattern)?;\n                Ok(Value::Number(if re.is_match(\u0026record) { 1.0 } else { 0.0 }))\n            }\n\n            Expr::Var(name, _) =\u003e Ok(self.get_variable(name)),\n\n            Expr::Field(expr, _) =\u003e {\n                let index = self.eval_expr_with_output(expr, output)?.to_number() as usize;\n                Ok(Value::from_string(self.get_field(index)))\n            }\n\n            Expr::ArrayAccess { array, indices, .. } =\u003e {\n                let key_parts: Result\u003cVec\u003cValue\u003e\u003e = indices.iter()\n                    .map(|e| self.eval_expr_with_output(e, output))\n                    .collect();\n                let key = self.make_array_key(\u0026key_parts?);\n                Ok(self.get_array_element(array, \u0026key))\n            }\n\n            Expr::Binary { left, op, right, .. } =\u003e {\n                self.eval_binary_op_with_output(left, *op, right, output)\n            }\n\n            Expr::Unary { op, operand, .. } =\u003e {\n                self.eval_unary_op_with_output(*op, operand, output)\n            }\n\n            Expr::Assign { target, op, value, .. } =\u003e {\n                self.eval_assignment_with_output(target, *op, value, output)\n            }\n\n            Expr::PreIncrement(expr, _) =\u003e {\n                let current = self.eval_expr_with_output(expr, output)?.to_number();\n                let new_val = Value::Number(current + 1.0);\n                self.assign_to_lvalue(expr, new_val.clone())?;\n                Ok(new_val)\n            }\n\n            Expr::PreDecrement(expr, _) =\u003e {\n                let current = self.eval_expr_with_output(expr, output)?.to_number();\n                let new_val = Value::Number(current - 1.0);\n                self.assign_to_lvalue(expr, new_val.clone())?;\n                Ok(new_val)\n            }\n\n            Expr::PostIncrement(expr, _) =\u003e {\n                let current = self.eval_expr_with_output(expr, output)?.to_number();\n                let new_val = Value::Number(current + 1.0);\n                self.assign_to_lvalue(expr, new_val)?;\n                Ok(Value::Number(current))\n            }\n\n            Expr::PostDecrement(expr, _) =\u003e {\n                let current = self.eval_expr_with_output(expr, output)?.to_number();\n                let new_val = Value::Number(current - 1.0);\n                self.assign_to_lvalue(expr, new_val)?;\n                Ok(Value::Number(current))\n            }\n\n            Expr::Ternary { condition, then_expr, else_expr, .. } =\u003e {\n                let cond = self.eval_expr_with_output(condition, output)?;\n                if cond.is_truthy() {\n                    self.eval_expr_with_output(then_expr, output)\n                } else {\n                    self.eval_expr_with_output(else_expr, output)\n                }\n            }\n\n            Expr::Call { name, args, location } =\u003e {\n                self.call_function(name, args, *location, output)\n            }\n\n            Expr::InArray { key, array, .. } =\u003e {\n                let key_parts: Result\u003cVec\u003cValue\u003e\u003e = key.iter()\n                    .map(|e| self.eval_expr_with_output(e, output))\n                    .collect();\n                let key_str = self.make_array_key(\u0026key_parts?);\n                Ok(Value::Number(if self.array_key_exists(array, \u0026key_str) { 1.0 } else { 0.0 }))\n            }\n\n            Expr::Match { expr, pattern, negated, .. } =\u003e {\n                let string = self.eval_expr_with_output(expr, output)?.to_string_val();\n                let pattern_str = match pattern.as_ref() {\n                    Expr::Regex(p, _) =\u003e p.clone(),\n                    other =\u003e self.eval_expr_with_output(other, output)?.to_string_val(),\n                };\n                let re = self.get_regex(\u0026pattern_str)?;\n                let matches = re.is_match(\u0026string);\n                let result = if *negated { !matches } else { matches };\n                Ok(Value::Number(if result { 1.0 } else { 0.0 }))\n            }\n\n            Expr::Concat(parts, _) =\u003e {\n                let mut result = String::new();\n                for part in parts {\n                    result.push_str(\u0026self.eval_expr_with_output(part, output)?.to_string_val());\n                }\n                Ok(Value::from_string(result))\n            }\n\n            Expr::Getline { var, input, location } =\u003e {\n                self.eval_getline(var.as_ref(), input.as_ref(), *location)\n            }\n\n            Expr::Group(expr, _) =\u003e self.eval_expr_with_output(expr, output),\n        }\n    }\n\n    fn eval_binary_op_with_output\u003cW: Write\u003e(\n        \u0026mut self,\n        left: \u0026Expr,\n        op: BinaryOp,\n        right: \u0026Expr,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        // Short-circuit evaluation for logical operators\n        match op {\n            BinaryOp::And =\u003e {\n                let l = self.eval_expr_with_output(left, output)?;\n                if !l.is_truthy() {\n                    return Ok(Value::Number(0.0));\n                }\n                let r = self.eval_expr_with_output(right, output)?;\n                return Ok(Value::Number(if r.is_truthy() { 1.0 } else { 0.0 }));\n            }\n            BinaryOp::Or =\u003e {\n                let l = self.eval_expr_with_output(left, output)?;\n                if l.is_truthy() {\n                    return Ok(Value::Number(1.0));\n                }\n                let r = self.eval_expr_with_output(right, output)?;\n                return Ok(Value::Number(if r.is_truthy() { 1.0 } else { 0.0 }));\n            }\n            _ =\u003e {}\n        }\n\n        let l = self.eval_expr_with_output(left, output)?;\n        let r = self.eval_expr_with_output(right, output)?;\n\n        match op {\n            BinaryOp::Add =\u003e Ok(Value::Number(l.to_number() + r.to_number())),\n            BinaryOp::Sub =\u003e Ok(Value::Number(l.to_number() - r.to_number())),\n            BinaryOp::Mul =\u003e Ok(Value::Number(l.to_number() * r.to_number())),\n            BinaryOp::Div =\u003e {\n                let divisor = r.to_number();\n                if divisor == 0.0 {\n                    Ok(Value::Number(f64::INFINITY))\n                } else {\n                    Ok(Value::Number(l.to_number() / divisor))\n                }\n            }\n            BinaryOp::Mod =\u003e {\n                let divisor = r.to_number();\n                if divisor == 0.0 {\n                    Ok(Value::Number(f64::NAN))\n                } else {\n                    Ok(Value::Number(l.to_number() % divisor))\n                }\n            }\n            BinaryOp::Pow =\u003e Ok(Value::Number(l.to_number().powf(r.to_number()))),\n            BinaryOp::Lt =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_lt() { 1.0 } else { 0.0 })),\n            BinaryOp::Le =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_le() { 1.0 } else { 0.0 })),\n            BinaryOp::Gt =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_gt() { 1.0 } else { 0.0 })),\n            BinaryOp::Ge =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_ge() { 1.0 } else { 0.0 })),\n            BinaryOp::Eq =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_eq() { 1.0 } else { 0.0 })),\n            BinaryOp::Ne =\u003e Ok(Value::Number(if compare_values(\u0026l, \u0026r).is_ne() { 1.0 } else { 0.0 })),\n            BinaryOp::Concat =\u003e {\n                let mut s = l.to_string_val();\n                s.push_str(\u0026r.to_string_val());\n                Ok(Value::from_string(s))\n            }\n            BinaryOp::And | BinaryOp::Or =\u003e unreachable!(), // Handled above\n        }\n    }\n\n    fn eval_unary_op_with_output\u003cW: Write\u003e(\n        \u0026mut self,\n        op: UnaryOp,\n        operand: \u0026Expr,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        let val = self.eval_expr_with_output(operand, output)?;\n        match op {\n            UnaryOp::Neg =\u003e Ok(Value::Number(-val.to_number())),\n            UnaryOp::Pos =\u003e Ok(Value::Number(val.to_number())),\n            UnaryOp::Not =\u003e Ok(Value::Number(if val.is_truthy() { 0.0 } else { 1.0 })),\n        }\n    }\n\n    fn eval_assignment_with_output\u003cW: Write\u003e(\n        \u0026mut self,\n        target: \u0026Expr,\n        op: AssignOp,\n        value: \u0026Expr,\n        output: \u0026mut W,\n    ) -\u003e Result\u003cValue\u003e {\n        let new_value = match op {\n            AssignOp::Assign =\u003e self.eval_expr_with_output(value, output)?,\n            _ =\u003e {\n                let current = self.eval_expr_with_output(target, output)?;\n                let rhs = self.eval_expr_with_output(value, output)?;\n                match op {\n                    AssignOp::AddAssign =\u003e Value::Number(current.to_number() + rhs.to_number()),\n                    AssignOp::SubAssign =\u003e Value::Number(current.to_number() - rhs.to_number()),\n                    AssignOp::MulAssign =\u003e Value::Number(current.to_number() * rhs.to_number()),\n                    AssignOp::DivAssign =\u003e Value::Number(current.to_number() / rhs.to_number()),\n                    AssignOp::ModAssign =\u003e Value::Number(current.to_number() % rhs.to_number()),\n                    AssignOp::PowAssign =\u003e Value::Number(current.to_number().powf(rhs.to_number())),\n                    AssignOp::Assign =\u003e unreachable!(),\n                }\n            }\n        };\n\n        self.assign_to_lvalue(target, new_value.clone())?;\n        Ok(new_value)\n    }\n\n    /// Evaluate getline expression\n    pub(crate) fn eval_getline(\n        \u0026mut self,\n        var: Option\u003c\u0026String\u003e,\n        input: Option\u003c\u0026GetlineInput\u003e,\n        _location: crate::error::SourceLocation,\n    ) -\u003e Result\u003cValue\u003e {\n        use std::io::BufRead;\n\n        match input {\n            None =\u003e {\n                // getline with no input source - read from current input\n                // This is handled by the main loop, so we return 0 (EOF) here\n                Ok(Value::Number(0.0))\n            }\n            Some(GetlineInput::File(file_expr)) =\u003e {\n                let filename = self.eval_expr(file_expr)?.to_string_val();\n\n                // Get or open the file\n                if !self.input_files.contains_key(\u0026filename) {\n                    match std::fs::File::open(\u0026filename) {\n                        Ok(file) =\u003e {\n                            self.input_files.insert(filename.clone(), std::io::BufReader::new(file));\n                        }\n                        Err(_) =\u003e return Ok(Value::Number(-1.0)), // Error\n                    }\n                }\n\n                let reader = self.input_files.get_mut(\u0026filename).unwrap();\n                let mut line = String::new();\n                match reader.read_line(\u0026mut line) {\n                    Ok(0) =\u003e Ok(Value::Number(0.0)), // EOF\n                    Ok(_) =\u003e {\n                        // Remove trailing newline\n                        if line.ends_with('\\n') {\n                            line.pop();\n                            if line.ends_with('\\r') {\n                                line.pop();\n                            }\n                        }\n\n                        if let Some(var_name) = var {\n                            self.set_variable_value(var_name, Value::from_string(line));\n                        } else {\n                            self.set_record(\u0026line);\n                        }\n                        Ok(Value::Number(1.0)) // Success\n                    }\n                    Err(_) =\u003e Ok(Value::Number(-1.0)), // Error\n                }\n            }\n            Some(GetlineInput::Pipe(cmd_expr)) =\u003e {\n                let cmd = self.eval_expr(cmd_expr)?.to_string_val();\n\n                // Get or open the pipe\n                if !self.pipes.contains_key(\u0026cmd) {\n                    match std::process::Command::new(\"sh\")\n                        .arg(\"-c\")\n                        .arg(\u0026cmd)\n                        .stdout(std::process::Stdio::piped())\n                        .spawn()\n                    {\n                        Ok(mut child) =\u003e {\n                            let stdout = child.stdout.take().unwrap();\n                            self.pipes.insert(cmd.clone(), super::PipeInput {\n                                child,\n                                reader: std::io::BufReader::new(stdout),\n                            });\n                        }\n                        Err(_) =\u003e return Ok(Value::Number(-1.0)), // Error\n                    }\n                }\n\n                let pipe = self.pipes.get_mut(\u0026cmd).unwrap();\n                let mut line = String::new();\n                match pipe.reader.read_line(\u0026mut line) {\n                    Ok(0) =\u003e Ok(Value::Number(0.0)), // EOF\n                    Ok(_) =\u003e {\n                        // Remove trailing newline\n                        if line.ends_with('\\n') {\n                            line.pop();\n                            if line.ends_with('\\r') {\n                                line.pop();\n                            }\n                        }\n\n                        if let Some(var_name) = var {\n                            self.set_variable_value(var_name, Value::from_string(line));\n                        } else {\n                            self.set_record(\u0026line);\n                        }\n                        Ok(Value::Number(1.0)) // Success\n                    }\n                    Err(_) =\u003e Ok(Value::Number(-1.0)), // Error\n                }\n            }\n        }\n    }\n\n    pub fn assign_to_lvalue(\u0026mut self, target: \u0026Expr, value: Value) -\u003e Result\u003c()\u003e {\n        match target {\n            Expr::Var(name, _) =\u003e {\n                self.set_variable_value(name, value);\n            }\n            Expr::Field(expr, _) =\u003e {\n                let index = self.eval_expr(expr)?.to_number() as usize;\n                self.set_field(index, value.to_string_val());\n            }\n            Expr::ArrayAccess { array, indices, .. } =\u003e {\n                let key_parts: Result\u003cVec\u003cValue\u003e\u003e = indices.iter().map(|e| self.eval_expr(e)).collect();\n                let key = self.make_array_key(\u0026key_parts?);\n                self.set_array_element(array, \u0026key, value);\n            }\n            _ =\u003e {\n                // Invalid lvalue, but we'll just ignore for now\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[3042240],"length":1,"stats":{"Line":7}},{"line":13,"address":[3042274],"length":1,"stats":{"Line":21}},{"line":14,"address":[2697046],"length":1,"stats":{"Line":18}},{"line":18,"address":[2607191,2604480,2607197],"length":1,"stats":{"Line":41}},{"line":19,"address":[2212422],"length":1,"stats":{"Line":29}},{"line":20,"address":[2248227],"length":1,"stats":{"Line":20}},{"line":22,"address":[2593478],"length":1,"stats":{"Line":11}},{"line":24,"address":[2439945],"length":1,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[2248525,2250353],"length":1,"stats":{"Line":9}},{"line":28,"address":[2595685],"length":1,"stats":{"Line":4}},{"line":31,"address":[2248559],"length":1,"stats":{"Line":7}},{"line":33,"address":[],"length":0,"stats":{"Line":6}},{"line":34,"address":[2765266,2763187,2754114,2752035],"length":1,"stats":{"Line":13}},{"line":35,"address":[],"length":0,"stats":{"Line":7}},{"line":38,"address":[2213003],"length":1,"stats":{"Line":4}},{"line":39,"address":[2605182],"length":1,"stats":{"Line":4}},{"line":40,"address":[2440291],"length":1,"stats":{"Line":12}},{"line":42,"address":[2215640,2213109],"length":1,"stats":{"Line":4}},{"line":43,"address":[2608107],"length":1,"stats":{"Line":4}},{"line":46,"address":[2763396,2752244],"length":1,"stats":{"Line":8}},{"line":47,"address":[2213237,2216192],"length":1,"stats":{"Line":16}},{"line":50,"address":[2440492],"length":1,"stats":{"Line":5}},{"line":51,"address":[2216428,2213306],"length":1,"stats":{"Line":10}},{"line":54,"address":[2879885],"length":1,"stats":{"Line":22}},{"line":55,"address":[2249160,2252288],"length":1,"stats":{"Line":37}},{"line":58,"address":[2249199],"length":1,"stats":{"Line":3}},{"line":59,"address":[2608933,2605624],"length":1,"stats":{"Line":6}},{"line":60,"address":[2609320],"length":1,"stats":{"Line":3}},{"line":61,"address":[2767367,2756395,2756215,2767547],"length":1,"stats":{"Line":6}},{"line":62,"address":[2756542,2767694],"length":1,"stats":{"Line":3}},{"line":65,"address":[2880047],"length":1,"stats":{"Line":1}},{"line":66,"address":[2752608,2763760,2756692,2767844],"length":1,"stats":{"Line":2}},{"line":67,"address":[2610240],"length":1,"stats":{"Line":1}},{"line":68,"address":[2445340,2445508],"length":1,"stats":{"Line":2}},{"line":69,"address":[2445683],"length":1,"stats":{"Line":1}},{"line":72,"address":[2440795],"length":1,"stats":{"Line":4}},{"line":73,"address":[2594484,2599509],"length":1,"stats":{"Line":8}},{"line":74,"address":[2885544],"length":1,"stats":{"Line":4}},{"line":75,"address":[2599935],"length":1,"stats":{"Line":4}},{"line":76,"address":[2600187],"length":1,"stats":{"Line":5}},{"line":79,"address":[2440857],"length":1,"stats":{"Line":1}},{"line":80,"address":[2600282,2594546],"length":1,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[2255559],"length":1,"stats":{"Line":1}},{"line":83,"address":[2600960],"length":1,"stats":{"Line":1}},{"line":86,"address":[2440919],"length":1,"stats":{"Line":3}},{"line":87,"address":[2886703,2880294],"length":1,"stats":{"Line":6}},{"line":88,"address":[2447655,2447720],"length":1,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[2220587,2220518],"length":1,"stats":{"Line":6}},{"line":95,"address":[2594685],"length":1,"stats":{"Line":12}},{"line":96,"address":[2752921,2764073],"length":1,"stats":{"Line":13}},{"line":99,"address":[2753049,2764201],"length":1,"stats":{"Line":2}},{"line":100,"address":[2594900],"length":1,"stats":{"Line":2}},{"line":101,"address":[2745040,2745064],"length":1,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[2256869],"length":1,"stats":{"Line":2}},{"line":107,"address":[2249899],"length":1,"stats":{"Line":3}},{"line":108,"address":[2771500,2753280,2760348,2764432],"length":1,"stats":{"Line":6}},{"line":109,"address":[2614001],"length":1,"stats":{"Line":3}},{"line":110,"address":[2760784,2760851,2772003,2771936],"length":1,"stats":{"Line":4}},{"line":111,"address":[2602881,2602832,2603716],"length":1,"stats":{"Line":2}},{"line":113,"address":[2760861,2761228,2772380,2772013],"length":1,"stats":{"Line":6}},{"line":114,"address":[2449733],"length":1,"stats":{"Line":3}},{"line":115,"address":[2761461,2772613],"length":1,"stats":{"Line":3}},{"line":116,"address":[2258361],"length":1,"stats":{"Line":3}},{"line":119,"address":[2214255],"length":1,"stats":{"Line":0}},{"line":120,"address":[2214275],"length":1,"stats":{"Line":0}},{"line":121,"address":[2603775,2595189],"length":1,"stats":{"Line":0}},{"line":122,"address":[2258736,2258885],"length":1,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[2595227],"length":1,"stats":{"Line":2}},{"line":128,"address":[2214392],"length":1,"stats":{"Line":5}},{"line":131,"address":[2604512,2595364],"length":1,"stats":{"Line":6}},{"line":135,"address":[2452911,2452938,2451712],"length":1,"stats":{"Line":8}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[2605677,2605843],"length":1,"stats":{"Line":2}},{"line":146,"address":[2781197,2775901,2781136,2775840],"length":1,"stats":{"Line":4}},{"line":147,"address":[2452355],"length":1,"stats":{"Line":2}},{"line":149,"address":[2261028,2261445,2261002],"length":1,"stats":{"Line":4}},{"line":150,"address":[2892128,2892063],"length":1,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[2617034,2617918],"length":1,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[2261726],"length":1,"stats":{"Line":3}},{"line":157,"address":[2453183,2453293,2453720],"length":1,"stats":{"Line":6}},{"line":158,"address":[2618541,2618476],"length":1,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[2618693,2616844],"length":1,"stats":{"Line":7}},{"line":164,"address":[2893225,2893288],"length":1,"stats":{"Line":14}},{"line":166,"address":[2619115],"length":1,"stats":{"Line":6}},{"line":167,"address":[2893977,2893544],"length":1,"stats":{"Line":6}},{"line":168,"address":[2893571,2894129],"length":1,"stats":{"Line":10}},{"line":169,"address":[2894264,2893598],"length":1,"stats":{"Line":8}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[2619238,2620010],"length":1,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":5}},{"line":173,"address":[2620061],"length":1,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[2619262,2620273],"length":1,"stats":{"Line":5}},{"line":180,"address":[2784235,2784351,2778807,2778939,2784103,2779055],"length":1,"stats":{"Line":4}},{"line":181,"address":[2263877],"length":1,"stats":{"Line":0}},{"line":183,"address":[2263856,2263991],"length":1,"stats":{"Line":4}},{"line":186,"address":[2620543,2619286],"length":1,"stats":{"Line":4}},{"line":187,"address":[2455711,2454343],"length":1,"stats":{"Line":8}},{"line":188,"address":[],"length":0,"stats":{"Line":11}},{"line":189,"address":[2895396,2893762],"length":1,"stats":{"Line":10}},{"line":190,"address":[2609911,2608144],"length":1,"stats":{"Line":4}},{"line":191,"address":[2779863,2785159,2777971,2783267],"length":1,"stats":{"Line":12}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[2896046,2893915],"length":1,"stats":{"Line":4}},{"line":195,"address":[2621742,2621686],"length":1,"stats":{"Line":4}},{"line":196,"address":[2896228],"length":1,"stats":{"Line":2}},{"line":202,"address":[2616648,2615888,2616654],"length":1,"stats":{"Line":5}},{"line":208,"address":[2774573,2773789],"length":1,"stats":{"Line":5}},{"line":209,"address":[2616136],"length":1,"stats":{"Line":5}},{"line":210,"address":[2451211,2451316],"length":1,"stats":{"Line":8}},{"line":211,"address":[2616409,2616190],"length":1,"stats":{"Line":4}},{"line":212,"address":[2260064,2259778],"length":1,"stats":{"Line":8}},{"line":216,"address":[2267632,2267638,2265600],"length":1,"stats":{"Line":14}},{"line":223,"address":[2622148],"length":1,"stats":{"Line":23}},{"line":224,"address":[2622341,2622178],"length":1,"stats":{"Line":16}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[2786539,2788571,2786602,2788634],"length":1,"stats":{"Line":7}},{"line":228,"address":[2266533],"length":1,"stats":{"Line":4}},{"line":229,"address":[2230861,2231051],"length":1,"stats":{"Line":6}},{"line":230,"address":[2897467,2897719],"length":1,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":232,"address":[2897854,2897515],"length":1,"stats":{"Line":2}},{"line":233,"address":[2266701,2267085],"length":1,"stats":{"Line":2}},{"line":234,"address":[2897563,2897997],"length":1,"stats":{"Line":2}},{"line":240,"address":[2230351,2231570],"length":1,"stats":{"Line":28}},{"line":241,"address":[2612679],"length":1,"stats":{"Line":11}},{"line":245,"address":[2690112,2692685,2691465],"length":1,"stats":{"Line":3}},{"line":253,"address":[2690183],"length":1,"stats":{"Line":5}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[2690300],"length":1,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[3047164],"length":1,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":3}},{"line":265,"address":[2691148],"length":1,"stats":{"Line":2}},{"line":266,"address":[3321957,3321915,3322122,3321833],"length":1,"stats":{"Line":3}},{"line":268,"address":[2691026],"length":1,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":3}},{"line":273,"address":[3047922],"length":1,"stats":{"Line":1}},{"line":274,"address":[3047937,3048037,3048170],"length":1,"stats":{"Line":7}},{"line":275,"address":[3036925],"length":1,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[3048389,3048284],"length":1,"stats":{"Line":4}},{"line":279,"address":[2692146],"length":1,"stats":{"Line":2}},{"line":280,"address":[3322868],"length":1,"stats":{"Line":2}},{"line":281,"address":[3037306],"length":1,"stats":{"Line":0}},{"line":285,"address":[3037161,3037318],"length":1,"stats":{"Line":4}},{"line":286,"address":[3048598,3048687],"length":1,"stats":{"Line":4}},{"line":288,"address":[3048922,3048629],"length":1,"stats":{"Line":0}},{"line":290,"address":[3037539],"length":1,"stats":{"Line":2}},{"line":292,"address":[3036811],"length":1,"stats":{"Line":0}},{"line":295,"address":[3321041],"length":1,"stats":{"Line":1}},{"line":296,"address":[3321064,3323421],"length":1,"stats":{"Line":3}},{"line":299,"address":[3049437],"length":1,"stats":{"Line":1}},{"line":300,"address":[3038502,3038219],"length":1,"stats":{"Line":4}},{"line":301,"address":[3038295],"length":1,"stats":{"Line":2}},{"line":302,"address":[3049650],"length":1,"stats":{"Line":1}},{"line":303,"address":[3038413],"length":1,"stats":{"Line":2}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[2693533],"length":1,"stats":{"Line":3}},{"line":307,"address":[],"length":0,"stats":{"Line":6}},{"line":308,"address":[3050072,3050154,3050288],"length":1,"stats":{"Line":9}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[3049789],"length":1,"stats":{"Line":0}},{"line":317,"address":[3325100,3323906],"length":1,"stats":{"Line":6}},{"line":318,"address":[3039496],"length":1,"stats":{"Line":3}},{"line":319,"address":[2694346,2694430,2694563],"length":1,"stats":{"Line":9}},{"line":320,"address":[3039748],"length":1,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[3051107,3051200],"length":1,"stats":{"Line":6}},{"line":324,"address":[3040010],"length":1,"stats":{"Line":3}},{"line":325,"address":[3325673],"length":1,"stats":{"Line":3}},{"line":326,"address":[3051354],"length":1,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":5}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":333,"address":[3051407,3051670],"length":1,"stats":{"Line":2}},{"line":335,"address":[2695115],"length":1,"stats":{"Line":1}},{"line":337,"address":[3039634],"length":1,"stats":{"Line":0}},{"line":343,"address":[3042188,3041499,3040512],"length":1,"stats":{"Line":13}},{"line":344,"address":[3326223],"length":1,"stats":{"Line":16}},{"line":345,"address":[3326336],"length":1,"stats":{"Line":9}},{"line":346,"address":[],"length":0,"stats":{"Line":19}},{"line":348,"address":[3051998],"length":1,"stats":{"Line":3}},{"line":349,"address":[3041505,3040974,3040749],"length":1,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":3}},{"line":352,"address":[3052049],"length":1,"stats":{"Line":12}},{"line":353,"address":[3327184,3326465],"length":1,"stats":{"Line":47}},{"line":354,"address":[],"length":0,"stats":{"Line":12}},{"line":355,"address":[3042003],"length":1,"stats":{"Line":10}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[3040654],"length":1,"stats":{"Line":13}}],"covered":180,"coverable":204},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","interpreter","mod.rs"],"content":"mod builtins;\nmod expr;\npub mod stmt;\n\nuse std::collections::HashMap;\nuse std::io::{BufRead, BufReader, Write};\nuse std::fs::File;\nuse std::process::{Child, ChildStdout, ChildStdin};\n\nuse crate::ast::*;\nuse crate::error::{Error, Result};\nuse crate::value::Value;\n\nuse regex::Regex;\n\n/// Input source for getline from pipe\npub struct PipeInput {\n    #[allow(dead_code)]\n    child: Child,\n    reader: BufReader\u003cChildStdout\u003e,\n}\n\n/// Output destination for print/printf redirection\npub enum OutputFile {\n    File(File),\n    Pipe(ChildStdin),\n}\n\nimpl Write for OutputFile {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e std::io::Result\u003cusize\u003e {\n        match self {\n            OutputFile::File(f) =\u003e f.write(buf),\n            OutputFile::Pipe(p) =\u003e p.write(buf),\n        }\n    }\n\n    fn flush(\u0026mut self) -\u003e std::io::Result\u003c()\u003e {\n        match self {\n            OutputFile::File(f) =\u003e f.flush(),\n            OutputFile::Pipe(p) =\u003e p.flush(),\n        }\n    }\n}\n\n/// The AWK interpreter runtime\npub struct Interpreter\u003c'a\u003e {\n    /// The parsed program\n    program: \u0026'a Program,\n\n    /// Global variables\n    pub(crate) variables: HashMap\u003cString, Value\u003e,\n\n    /// Associative arrays\n    pub(crate) arrays: HashMap\u003cString, HashMap\u003cString, Value\u003e\u003e,\n\n    /// User-defined functions\n    pub(crate) functions: HashMap\u003cString, \u0026'a FunctionDef\u003e,\n\n    /// Built-in variables\n    /// Field separator (FS)\n    pub(crate) fs: String,\n    /// Output field separator (OFS)\n    pub(crate) ofs: String,\n    /// Record separator (RS)\n    pub(crate) rs: String,\n    /// Output record separator (ORS)\n    pub(crate) ors: String,\n    /// Number format for output (OFMT)\n    pub(crate) ofmt: String,\n    /// Conversion format (CONVFMT)\n    pub(crate) convfmt: String,\n    /// Subscript separator (SUBSEP)\n    pub(crate) subsep: String,\n    /// Field pattern (FPAT) - gawk extension\n    pub(crate) fpat: String,\n    /// Fixed field widths (FIELDWIDTHS) - gawk extension\n    pub(crate) fieldwidths: String,\n\n    /// Mode flags\n    pub(crate) posix_mode: bool,\n    pub(crate) traditional_mode: bool,\n\n    /// Current record ($0)\n    pub(crate) record: String,\n    /// Current fields ($1, $2, ...)\n    pub(crate) fields: Vec\u003cString\u003e,\n    /// Number of fields (NF)\n    pub(crate) nf: usize,\n    /// Record number (NR)\n    pub(crate) nr: usize,\n    /// File record number (FNR)\n    pub(crate) fnr: usize,\n    /// Current filename (FILENAME)\n    pub(crate) filename: String,\n\n    /// RSTART and RLENGTH from match()\n    pub(crate) rstart: usize,\n    pub(crate) rlength: i32,\n\n    /// Control flow flags\n    should_exit: bool,\n    exit_code: i32,\n    should_next: bool,\n    should_nextfile: bool,\n\n    /// Open files for output redirection\n    pub(crate) output_files: HashMap\u003cString, OutputFile\u003e,\n\n    /// Open files for input (getline)\n    pub(crate) input_files: HashMap\u003cString, BufReader\u003cFile\u003e\u003e,\n\n    /// Open pipes for input (getline from command)\n    pub(crate) pipes: HashMap\u003cString, PipeInput\u003e,\n\n    /// Compiled regex cache\n    pub(crate) regex_cache: HashMap\u003cString, Regex\u003e,\n\n    /// Range pattern state (for /start/,/end/ patterns)\n    range_states: HashMap\u003cusize, bool\u003e,\n\n    /// Random number generator state\n    pub(crate) rand_seed: u64,\n    pub(crate) rand_state: u64,\n\n    /// Command line arguments (ARGC, ARGV)\n    pub(crate) argc: usize,\n    pub(crate) argv: Vec\u003cString\u003e,\n\n    /// Environment variables (ENVIRON)\n    pub(crate) environ: HashMap\u003cString, String\u003e,\n\n    /// Array aliases for pass-by-reference in functions\n    /// Maps parameter name -\u003e actual array name\n    pub(crate) array_aliases: HashMap\u003cString, String\u003e,\n}\n\nimpl\u003c'a\u003e Interpreter\u003c'a\u003e {\n    pub fn new(program: \u0026'a Program) -\u003e Self {\n        let mut functions = HashMap::new();\n        for func in \u0026program.functions {\n            functions.insert(func.name.clone(), func);\n        }\n\n        // Initialize environment variables\n        let environ: HashMap\u003cString, String\u003e = std::env::vars().collect();\n\n        // Initialize random seed from current time\n        use std::time::{SystemTime, UNIX_EPOCH};\n        let rand_seed = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_nanos() as u64)\n            .unwrap_or(12345);\n\n        Self {\n            program,\n            variables: HashMap::new(),\n            arrays: HashMap::new(),\n            functions,\n            fs: \" \".to_string(),\n            ofs: \" \".to_string(),\n            rs: \"\\n\".to_string(),\n            ors: \"\\n\".to_string(),\n            ofmt: \"%.6g\".to_string(),\n            convfmt: \"%.6g\".to_string(),\n            subsep: \"\\x1c\".to_string(),\n            fpat: String::new(),\n            fieldwidths: String::new(),\n            posix_mode: false,\n            traditional_mode: false,\n            record: String::new(),\n            fields: Vec::new(),\n            nf: 0,\n            nr: 0,\n            fnr: 0,\n            filename: String::new(),\n            rstart: 0,\n            rlength: -1,\n            should_exit: false,\n            exit_code: 0,\n            should_next: false,\n            should_nextfile: false,\n            output_files: HashMap::new(),\n            input_files: HashMap::new(),\n            pipes: HashMap::new(),\n            regex_cache: HashMap::new(),\n            range_states: HashMap::new(),\n            rand_seed,\n            rand_state: rand_seed,\n            argc: 0,\n            argv: Vec::new(),\n            environ,\n            array_aliases: HashMap::new(),\n        }\n    }\n\n    /// Set command line arguments (ARGC and ARGV)\n    pub fn set_args(\u0026mut self, args: Vec\u003cString\u003e) {\n        self.argc = args.len();\n        self.argv = args;\n    }\n\n    /// Set the field separator\n    pub fn set_fs(\u0026mut self, fs: \u0026str) {\n        self.fs = fs.to_string();\n        // Clear FPAT and FIELDWIDTHS when FS is set\n        self.fpat.clear();\n        self.fieldwidths.clear();\n    }\n\n    /// Set POSIX strict mode\n    pub fn set_posix_mode(\u0026mut self, enabled: bool) {\n        self.posix_mode = enabled;\n        if enabled {\n            self.traditional_mode = false;\n        }\n    }\n\n    /// Set traditional AWK mode (no gawk extensions)\n    pub fn set_traditional_mode(\u0026mut self, enabled: bool) {\n        self.traditional_mode = enabled;\n        if enabled {\n            self.posix_mode = false;\n        }\n    }\n\n    /// Set a variable before execution\n    pub fn set_variable(\u0026mut self, name: \u0026str, value: \u0026str) {\n        self.variables.insert(name.to_string(), Value::from_string(value.to_string()));\n    }\n\n    /// Set the current filename (FILENAME)\n    pub fn set_filename(\u0026mut self, filename: \u0026str) {\n        self.filename = filename.to_string();\n    }\n\n    /// Run the AWK program with given input\n    pub fn run\u003cR: BufRead, W: Write\u003e(\u0026mut self, inputs: Vec\u003cR\u003e, output: \u0026mut W) -\u003e Result\u003ci32\u003e {\n        // Execute BEGIN rules\n        for rule in \u0026self.program.rules {\n            if matches!(\u0026rule.pattern, Some(Pattern::Begin)) {\n                if let Some(action) = \u0026rule.action {\n                    self.execute_block(action, output)?;\n                }\n                if self.should_exit {\n                    return Ok(self.exit_code);\n                }\n            }\n        }\n\n        // Process input files\n        for input in inputs {\n            self.fnr = 0;\n\n            // Execute BEGINFILE rules (gawk extension)\n            for rule in \u0026self.program.rules {\n                if matches!(\u0026rule.pattern, Some(Pattern::BeginFile)) {\n                    if let Some(action) = \u0026rule.action {\n                        self.execute_block(action, output)?;\n                    }\n                    if self.should_exit {\n                        return Ok(self.exit_code);\n                    }\n                }\n            }\n\n            self.process_input(input, output)?;\n\n            // Execute ENDFILE rules (gawk extension)\n            for rule in \u0026self.program.rules {\n                if matches!(\u0026rule.pattern, Some(Pattern::EndFile)) {\n                    if let Some(action) = \u0026rule.action {\n                        self.execute_block(action, output)?;\n                    }\n                    if self.should_exit {\n                        return Ok(self.exit_code);\n                    }\n                }\n            }\n\n            if self.should_exit {\n                return Ok(self.exit_code);\n            }\n        }\n\n        // Execute END rules\n        for rule in \u0026self.program.rules {\n            if matches!(\u0026rule.pattern, Some(Pattern::End)) {\n                if let Some(action) = \u0026rule.action {\n                    self.execute_block(action, output)?;\n                }\n            }\n        }\n\n        Ok(self.exit_code)\n    }\n\n    fn process_input\u003cR: BufRead, W: Write\u003e(\u0026mut self, mut input: R, output: \u0026mut W) -\u003e Result\u003c()\u003e {\n        // Check for paragraph mode (RS = \"\")\n        if self.rs.is_empty() {\n            return self.process_input_paragraph_mode(input, output);\n        }\n\n        let mut line = String::new();\n\n        loop {\n            line.clear();\n            let bytes_read = input.read_line(\u0026mut line).map_err(Error::Io)?;\n            if bytes_read == 0 {\n                break; // EOF\n            }\n\n            // Remove record separator\n            if line.ends_with('\\n') {\n                line.pop();\n                if line.ends_with('\\r') {\n                    line.pop();\n                }\n            }\n\n            self.nr += 1;\n            self.fnr += 1;\n            self.set_record(\u0026line);\n\n            self.process_current_record(output)?;\n\n            if self.should_nextfile {\n                self.should_nextfile = false;\n                break;\n            }\n\n            if self.should_exit {\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Process input in paragraph mode (RS = \"\")\n    /// Blank lines separate records; multiple blank lines count as one separator\n    fn process_input_paragraph_mode\u003cR: BufRead, W: Write\u003e(\u0026mut self, mut input: R, output: \u0026mut W) -\u003e Result\u003c()\u003e {\n        let mut line = String::new();\n        let mut record = String::new();\n        let mut in_record = false;\n\n        loop {\n            line.clear();\n            let bytes_read = input.read_line(\u0026mut line).map_err(Error::Io)?;\n\n            // Check if line is blank (empty or only whitespace)\n            let is_blank = line.trim().is_empty();\n\n            if bytes_read == 0 {\n                // EOF - process any remaining record\n                if !record.is_empty() {\n                    // Remove trailing newline\n                    while record.ends_with('\\n') || record.ends_with('\\r') {\n                        record.pop();\n                    }\n                    self.nr += 1;\n                    self.fnr += 1;\n                    self.set_record(\u0026record);\n                    self.process_current_record(output)?;\n                }\n                break;\n            }\n\n            if is_blank {\n                // Blank line - end of record if we're in one\n                if in_record \u0026\u0026 !record.is_empty() {\n                    // Remove trailing newline\n                    while record.ends_with('\\n') || record.ends_with('\\r') {\n                        record.pop();\n                    }\n                    self.nr += 1;\n                    self.fnr += 1;\n                    self.set_record(\u0026record);\n                    self.process_current_record(output)?;\n\n                    record.clear();\n                    in_record = false;\n\n                    if self.should_nextfile || self.should_exit {\n                        break;\n                    }\n                }\n            } else {\n                // Non-blank line - add to record\n                if in_record {\n                    record.push('\\n');\n                }\n                // Remove trailing newline from line before adding\n                if line.ends_with('\\n') {\n                    line.pop();\n                    if line.ends_with('\\r') {\n                        line.pop();\n                    }\n                }\n                record.push_str(\u0026line);\n                in_record = true;\n            }\n        }\n\n        if self.should_nextfile {\n            self.should_nextfile = false;\n        }\n\n        Ok(())\n    }\n\n    /// Process the current record through all matching rules\n    fn process_current_record\u003cW: Write\u003e(\u0026mut self, output: \u0026mut W) -\u003e Result\u003c()\u003e {\n        for (idx, rule) in self.program.rules.iter().enumerate() {\n            // Skip special patterns that are handled separately\n            if matches!(\u0026rule.pattern,\n                Some(Pattern::Begin) | Some(Pattern::End) |\n                Some(Pattern::BeginFile) | Some(Pattern::EndFile)) {\n                continue;\n            }\n\n            let matches = self.pattern_matches(\u0026rule.pattern, idx)?;\n            if matches {\n                if let Some(action) = \u0026rule.action {\n                    self.execute_block(action, output)?;\n                } else {\n                    // Default action is to print $0\n                    writeln!(output, \"{}\", self.record).map_err(Error::Io)?;\n                }\n            }\n\n            if self.should_next {\n                self.should_next = false;\n                break;\n            }\n\n            if self.should_nextfile || self.should_exit {\n                break;\n            }\n        }\n        Ok(())\n    }\n\n    pub(crate) fn set_record(\u0026mut self, record: \u0026str) {\n        self.record = record.to_string();\n        self.split_fields();\n    }\n\n    fn split_fields(\u0026mut self) {\n        self.fields.clear();\n\n        if self.record.is_empty() {\n            self.nf = 0;\n            return;\n        }\n\n        // Pre-estimate capacity to reduce reallocations\n        let estimated_fields = self.record.len() / 8 + 1;\n        self.fields.reserve(estimated_fields.min(64));\n\n        // Check for FPAT (field pattern) - gawk extension\n        if !self.fpat.is_empty() \u0026\u0026 !self.posix_mode \u0026\u0026 !self.traditional_mode {\n            self.split_fields_fpat();\n            return;\n        }\n\n        // Check for FIELDWIDTHS - gawk extension\n        if !self.fieldwidths.is_empty() \u0026\u0026 !self.posix_mode \u0026\u0026 !self.traditional_mode {\n            self.split_fields_widths();\n            return;\n        }\n\n        // Standard FS-based splitting\n        if self.fs == \" \" {\n            // Special case: split on runs of whitespace, trimming leading/trailing\n            // Use byte-based iteration for ASCII optimization\n            self.fields.extend(self.record.split_whitespace().map(String::from));\n        } else if self.fs.len() == 1 {\n            // Single character separator - most common case, optimize for it\n            let sep = self.fs.as_bytes()[0];\n            let bytes = self.record.as_bytes();\n            let mut start = 0;\n\n            for (i, \u0026b) in bytes.iter().enumerate() {\n                if b == sep {\n                    self.fields.push(self.record[start..i].to_string());\n                    start = i + 1;\n                }\n            }\n            // Don't forget the last field\n            self.fields.push(self.record[start..].to_string());\n        } else {\n            // Regex separator - cache the compiled regex\n            let fs = self.fs.clone();\n            let record = self.record.clone();\n            if let Some(regex) = self.regex_cache.get(\u0026fs) {\n                self.fields.extend(regex.split(\u0026record).map(String::from));\n            } else if let Ok(regex) = Regex::new(\u0026fs) {\n                self.fields.extend(regex.split(\u0026record).map(String::from));\n                self.regex_cache.insert(fs, regex);\n            } else {\n                // If regex fails, treat as literal string\n                self.fields.extend(record.split(\u0026fs).map(String::from));\n            }\n        }\n\n        self.nf = self.fields.len();\n    }\n\n    /// Split fields using FPAT (field pattern matching)\n    fn split_fields_fpat(\u0026mut self) {\n        let fpat = self.fpat.clone();\n        let record = self.record.clone();\n\n        if let Some(regex) = self.regex_cache.get(\u0026fpat) {\n            for mat in regex.find_iter(\u0026record) {\n                self.fields.push(mat.as_str().to_string());\n            }\n        } else if let Ok(regex) = Regex::new(\u0026fpat) {\n            for mat in regex.find_iter(\u0026record) {\n                self.fields.push(mat.as_str().to_string());\n            }\n            self.regex_cache.insert(fpat, regex);\n        }\n\n        self.nf = self.fields.len();\n    }\n\n    /// Split fields using FIELDWIDTHS (fixed-width fields)\n    fn split_fields_widths(\u0026mut self) {\n        let widths: Vec\u003cusize\u003e = self.fieldwidths\n            .split_whitespace()\n            .filter_map(|s| s.parse().ok())\n            .collect();\n\n        let mut pos = 0;\n        let chars: Vec\u003cchar\u003e = self.record.chars().collect();\n\n        for width in widths {\n            if pos \u003e= chars.len() {\n                break;\n            }\n            let end = (pos + width).min(chars.len());\n            let field: String = chars[pos..end].iter().collect();\n            self.fields.push(field);\n            pos = end;\n        }\n\n        self.nf = self.fields.len();\n    }\n\n    #[inline]\n    pub(crate) fn get_field(\u0026self, index: usize) -\u003e String {\n        if index == 0 {\n            self.record.clone()\n        } else if index \u003c= self.fields.len() {\n            self.fields[index - 1].clone()\n        } else {\n            String::new()\n        }\n    }\n\n    /// Get field reference without cloning (for read-only access)\n    #[inline]\n    #[allow(dead_code)]\n    pub(crate) fn get_field_ref(\u0026self, index: usize) -\u003e \u0026str {\n        if index == 0 {\n            \u0026self.record\n        } else if index \u003c= self.fields.len() {\n            \u0026self.fields[index - 1]\n        } else {\n            \"\"\n        }\n    }\n\n    pub(crate) fn set_field(\u0026mut self, index: usize, value: String) {\n        if index == 0 {\n            self.record = value;\n            self.split_fields();\n        } else {\n            // Extend fields if necessary\n            while self.fields.len() \u003c index {\n                self.fields.push(String::new());\n            }\n            self.fields[index - 1] = value;\n            self.nf = self.fields.len();\n            // Rebuild $0\n            self.record = self.fields.join(\u0026self.ofs);\n        }\n    }\n\n    fn pattern_matches(\u0026mut self, pattern: \u0026Option\u003cPattern\u003e, rule_idx: usize) -\u003e Result\u003cbool\u003e {\n        match pattern {\n            None =\u003e Ok(true), // No pattern means always match\n            Some(Pattern::Begin) | Some(Pattern::End) |\n            Some(Pattern::BeginFile) | Some(Pattern::EndFile) =\u003e Ok(false),\n            Some(Pattern::Expr(expr)) =\u003e {\n                let val = self.eval_expr(expr)?;\n                Ok(val.is_truthy())\n            }\n            Some(Pattern::Regex(regex)) =\u003e {\n                let record = self.record.clone();\n                let re = self.get_regex(regex)?;\n                Ok(re.is_match(\u0026record))\n            }\n            Some(Pattern::Range { start, end }) =\u003e {\n                let active = self.range_states.get(\u0026rule_idx).copied().unwrap_or(false);\n                if !active {\n                    // Check if start pattern matches\n                    if self.pattern_matches(\u0026Some(start.as_ref().clone()), rule_idx)? {\n                        self.range_states.insert(rule_idx, true);\n                        return Ok(true);\n                    }\n                    Ok(false)\n                } else {\n                    // Range is active, check if end pattern matches\n                    if self.pattern_matches(\u0026Some(end.as_ref().clone()), rule_idx)? {\n                        self.range_states.insert(rule_idx, false);\n                    }\n                    Ok(true)\n                }\n            }\n            Some(Pattern::And(left, right)) =\u003e {\n                Ok(self.pattern_matches(\u0026Some(left.as_ref().clone()), rule_idx)?\n                    \u0026\u0026 self.pattern_matches(\u0026Some(right.as_ref().clone()), rule_idx)?)\n            }\n            Some(Pattern::Or(left, right)) =\u003e {\n                Ok(self.pattern_matches(\u0026Some(left.as_ref().clone()), rule_idx)?\n                    || self.pattern_matches(\u0026Some(right.as_ref().clone()), rule_idx)?)\n            }\n            Some(Pattern::Not(inner)) =\u003e {\n                Ok(!self.pattern_matches(\u0026Some(inner.as_ref().clone()), rule_idx)?)\n            }\n        }\n    }\n\n    pub(crate) fn get_regex(\u0026mut self, pattern: \u0026str) -\u003e Result\u003c\u0026Regex\u003e {\n        if !self.regex_cache.contains_key(pattern) {\n            let regex = Regex::new(pattern).map_err(Error::Regex)?;\n            self.regex_cache.insert(pattern.to_string(), regex);\n        }\n        Ok(self.regex_cache.get(pattern).unwrap())\n    }\n\n    pub(crate) fn get_variable(\u0026self, name: \u0026str) -\u003e Value {\n        // Check special variables first\n        match name {\n            \"NF\" =\u003e Value::Number(self.nf as f64),\n            \"NR\" =\u003e Value::Number(self.nr as f64),\n            \"FNR\" =\u003e Value::Number(self.fnr as f64),\n            \"FS\" =\u003e Value::from_string(self.fs.clone()),\n            \"OFS\" =\u003e Value::from_string(self.ofs.clone()),\n            \"RS\" =\u003e Value::from_string(self.rs.clone()),\n            \"ORS\" =\u003e Value::from_string(self.ors.clone()),\n            \"OFMT\" =\u003e Value::from_string(self.ofmt.clone()),\n            \"CONVFMT\" =\u003e Value::from_string(self.convfmt.clone()),\n            \"SUBSEP\" =\u003e Value::from_string(self.subsep.clone()),\n            \"FILENAME\" =\u003e Value::from_string(self.filename.clone()),\n            \"RSTART\" =\u003e Value::Number(self.rstart as f64),\n            \"RLENGTH\" =\u003e Value::Number(self.rlength as f64),\n            \"ARGC\" =\u003e Value::Number(self.argc as f64),\n            // gawk extensions\n            \"FPAT\" =\u003e Value::from_string(self.fpat.clone()),\n            \"FIELDWIDTHS\" =\u003e Value::from_string(self.fieldwidths.clone()),\n            _ =\u003e self.variables.get(name).cloned().unwrap_or(Value::Uninitialized),\n        }\n    }\n\n    /// Get an element from ARGV, ENVIRON, or PROCINFO arrays\n    pub(crate) fn get_special_array(\u0026self, array: \u0026str, key: \u0026str) -\u003e Option\u003cValue\u003e {\n        match array {\n            \"ARGV\" =\u003e {\n                key.parse::\u003cusize\u003e().ok()\n                    .and_then(|i| self.argv.get(i))\n                    .map(|s| Value::from_string(s.clone()))\n            }\n            \"ENVIRON\" =\u003e {\n                self.environ.get(key).map(|s| Value::from_string(s.clone()))\n            }\n            \"PROCINFO\" =\u003e {\n                // gawk PROCINFO array - system information\n                match key {\n                    \"version\" =\u003e Some(Value::from_string(env!(\"CARGO_PKG_VERSION\").to_string())),\n                    \"strftime\" =\u003e Some(Value::from_string(\"%a %b %e %H:%M:%S %Z %Y\".to_string())),\n                    \"FS\" =\u003e {\n                        if !self.fpat.is_empty() {\n                            Some(Value::from_string(\"FPAT\".to_string()))\n                        } else if !self.fieldwidths.is_empty() {\n                            Some(Value::from_string(\"FIELDWIDTHS\".to_string()))\n                        } else {\n                            Some(Value::from_string(\"FS\".to_string()))\n                        }\n                    }\n                    \"identifiers\" =\u003e Some(Value::Number(0.0)), // Not implemented\n                    \"pid\" =\u003e Some(Value::Number(std::process::id() as f64)),\n                    \"ppid\" =\u003e Some(Value::Number(0.0)), // Not easily available in Rust\n                    \"uid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    \"gid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    \"euid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    \"egid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    \"pgrpid\" =\u003e Some(Value::Number(0.0)), // Platform specific\n                    _ =\u003e Some(Value::Uninitialized),\n                }\n            }\n            _ =\u003e None,\n        }\n    }\n\n    pub(crate) fn set_variable_value(\u0026mut self, name: \u0026str, value: Value) {\n        // Handle special variables\n        match name {\n            \"NF\" =\u003e {\n                let new_nf = value.to_number() as usize;\n                if new_nf \u003c self.nf {\n                    self.fields.truncate(new_nf);\n                } else {\n                    while self.fields.len() \u003c new_nf {\n                        self.fields.push(String::new());\n                    }\n                }\n                self.nf = new_nf;\n                self.record = self.fields.join(\u0026self.ofs);\n            }\n            \"FS\" =\u003e {\n                self.fs = value.to_string_val();\n                // Clear FPAT and FIELDWIDTHS when FS is set\n                self.fpat.clear();\n                self.fieldwidths.clear();\n            }\n            \"OFS\" =\u003e self.ofs = value.to_string_val(),\n            \"RS\" =\u003e self.rs = value.to_string_val(),\n            \"ORS\" =\u003e self.ors = value.to_string_val(),\n            \"OFMT\" =\u003e self.ofmt = value.to_string_val(),\n            \"CONVFMT\" =\u003e self.convfmt = value.to_string_val(),\n            \"SUBSEP\" =\u003e self.subsep = value.to_string_val(),\n            // gawk extensions\n            \"FPAT\" =\u003e {\n                self.fpat = value.to_string_val();\n                // FPAT takes precedence over FS and FIELDWIDTHS\n                self.fieldwidths.clear();\n            }\n            \"FIELDWIDTHS\" =\u003e {\n                self.fieldwidths = value.to_string_val();\n                // FIELDWIDTHS takes precedence over FS\n                self.fpat.clear();\n            }\n            _ =\u003e {\n                self.variables.insert(name.to_string(), value);\n            }\n        }\n    }\n\n    /// Resolve array name through aliases (for pass-by-reference in functions)\n    fn resolve_array_name\u003c'b\u003e(\u0026'b self, array: \u0026'b str) -\u003e \u0026'b str {\n        self.array_aliases.get(array).map(|s| s.as_str()).unwrap_or(array)\n    }\n\n    pub(crate) fn get_array_element(\u0026self, array: \u0026str, key: \u0026str) -\u003e Value {\n        let array = self.resolve_array_name(array);\n\n        // Check for special arrays first\n        if let Some(val) = self.get_special_array(array, key) {\n            return val;\n        }\n\n        self.arrays\n            .get(array)\n            .and_then(|arr| arr.get(key))\n            .cloned()\n            .unwrap_or(Value::Uninitialized)\n    }\n\n    pub(crate) fn set_array_element(\u0026mut self, array: \u0026str, key: \u0026str, value: Value) {\n        let array = self.resolve_array_name(array).to_string();\n        self.arrays\n            .entry(array)\n            .or_default()\n            .insert(key.to_string(), value);\n    }\n\n    pub(crate) fn array_key_exists(\u0026self, array: \u0026str, key: \u0026str) -\u003e bool {\n        let array = self.resolve_array_name(array);\n\n        // Check special arrays\n        match array {\n            \"ARGV\" =\u003e {\n                key.parse::\u003cusize\u003e().ok()\n                    .map(|i| i \u003c self.argv.len())\n                    .unwrap_or(false)\n            }\n            \"ENVIRON\" =\u003e self.environ.contains_key(key),\n            _ =\u003e {\n                self.arrays\n                    .get(array)\n                    .map(|arr| arr.contains_key(key))\n                    .unwrap_or(false)\n            }\n        }\n    }\n\n    pub(crate) fn delete_array_element(\u0026mut self, array: \u0026str, key: \u0026str) {\n        let array = self.resolve_array_name(array).to_string();\n        if let Some(arr) = self.arrays.get_mut(\u0026array) {\n            arr.remove(key);\n        }\n    }\n\n    pub(crate) fn make_array_key(\u0026self, indices: \u0026[Value]) -\u003e String {\n        indices\n            .iter()\n            .map(|v| v.to_string_val())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\u0026self.subsep)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::lexer::Lexer;\n    use crate::parser::Parser;\n    use std::io::Cursor;\n\n    fn run_awk(program: \u0026str, input: \u0026str) -\u003e String {\n        let mut lexer = Lexer::new(program);\n        let tokens = lexer.tokenize().unwrap();\n        let mut parser = Parser::new(tokens);\n        let ast = parser.parse().unwrap();\n\n        let mut interpreter = Interpreter::new(\u0026ast);\n        let mut output = Vec::new();\n        let inputs: Vec\u003cstd::io::BufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = if input.is_empty() {\n            vec![]\n        } else {\n            vec![std::io::BufReader::new(Cursor::new(input))]\n        };\n\n        interpreter.run(inputs, \u0026mut output).unwrap();\n        String::from_utf8(output).unwrap()\n    }\n\n    #[test]\n    fn test_begin_print() {\n        let output = run_awk(r#\"BEGIN { print \"hello\" }\"#, \"\");\n        assert_eq!(output, \"hello\\n\");\n    }\n\n    #[test]\n    fn test_print_field() {\n        let output = run_awk(\"{ print $1 }\", \"one two three\");\n        assert_eq!(output, \"one\\n\");\n    }\n\n    #[test]\n    fn test_print_multiple_fields() {\n        let output = run_awk(\"{ print $1, $3 }\", \"one two three\");\n        assert_eq!(output, \"one three\\n\");\n    }\n\n    #[test]\n    fn test_arithmetic() {\n        let output = run_awk(\"BEGIN { print 2 + 3 * 4 }\", \"\");\n        assert_eq!(output, \"14\\n\");\n    }\n\n    #[test]\n    fn test_variable() {\n        let output = run_awk(\"BEGIN { x = 5; print x }\", \"\");\n        assert_eq!(output, \"5\\n\");\n    }\n\n    #[test]\n    fn test_if_statement() {\n        let output = run_awk(\"BEGIN { x = 10; if (x \u003e 5) print \\\"big\\\" }\", \"\");\n        assert_eq!(output, \"big\\n\");\n    }\n\n    #[test]\n    fn test_while_loop() {\n        let output = run_awk(\"BEGIN { i = 1; while (i \u003c= 3) { print i; i++ } }\", \"\");\n        assert_eq!(output, \"1\\n2\\n3\\n\");\n    }\n\n    #[test]\n    fn test_pattern_match() {\n        let output = run_awk(\"/two/ { print $0 }\", \"one\\ntwo\\nthree\");\n        assert_eq!(output, \"two\\n\");\n    }\n\n    #[test]\n    fn test_for_loop() {\n        let output = run_awk(\"BEGIN { for (i = 1; i \u003c= 3; i++) print i }\", \"\");\n        assert_eq!(output, \"1\\n2\\n3\\n\");\n    }\n\n    #[test]\n    fn test_for_in_loop() {\n        let output = run_awk(\"BEGIN { a[1]=1; a[2]=2; for (k in a) count++; print count }\", \"\");\n        assert_eq!(output, \"2\\n\");\n    }\n\n    #[test]\n    fn test_do_while() {\n        let output = run_awk(\"BEGIN { i = 0; do { i++ } while (i \u003c 3); print i }\", \"\");\n        assert_eq!(output, \"3\\n\");\n    }\n\n    #[test]\n    fn test_break() {\n        let output = run_awk(\"BEGIN { for (i=1; i\u003c=10; i++) { if (i==3) break; print i } }\", \"\");\n        assert_eq!(output, \"1\\n2\\n\");\n    }\n\n    #[test]\n    fn test_continue() {\n        let output = run_awk(\"BEGIN { for (i=1; i\u003c=3; i++) { if (i==2) continue; print i } }\", \"\");\n        assert_eq!(output, \"1\\n3\\n\");\n    }\n\n    #[test]\n    fn test_next() {\n        let output = run_awk(\"/skip/ { next } { print }\", \"one\\nskip\\ntwo\");\n        assert_eq!(output, \"one\\ntwo\\n\");\n    }\n\n    #[test]\n    fn test_exit() {\n        // exit is called before print on NR == 2\n        let output = run_awk(\"NR == 2 { exit } { print }\", \"one\\ntwo\\nthree\");\n        assert_eq!(output, \"one\\n\");\n    }\n\n    #[test]\n    fn test_exit_in_end() {\n        let output = run_awk(\"{ print } END { print \\\"done\\\" }\", \"one\\ntwo\");\n        assert!(output.contains(\"done\"));\n    }\n\n    #[test]\n    fn test_array_access() {\n        let output = run_awk(\"BEGIN { a[\\\"x\\\"] = 1; print a[\\\"x\\\"] }\", \"\");\n        assert_eq!(output, \"1\\n\");\n    }\n\n    #[test]\n    fn test_array_in() {\n        let output = run_awk(\"BEGIN { a[1]=1; print (1 in a), (2 in a) }\", \"\");\n        assert_eq!(output, \"1 0\\n\");\n    }\n\n    #[test]\n    fn test_delete() {\n        let output = run_awk(\"BEGIN { a[1]=1; a[2]=2; delete a[1]; for(k in a) print k }\", \"\");\n        assert_eq!(output, \"2\\n\");\n    }\n\n    #[test]\n    fn test_special_variables() {\n        let output = run_awk(\"{ print NR, NF, $0 }\", \"a b c\");\n        assert_eq!(output, \"1 3 a b c\\n\");\n    }\n\n    #[test]\n    fn test_fs_change() {\n        let output = run_awk(\"BEGIN { FS = \\\":\\\" } { print $1 }\", \"a:b:c\");\n        assert_eq!(output, \"a\\n\");\n    }\n\n    #[test]\n    fn test_ofs() {\n        let output = run_awk(\"BEGIN { OFS = \\\"-\\\" } { print $1, $2 }\", \"a b c\");\n        assert_eq!(output, \"a-b\\n\");\n    }\n\n    #[test]\n    fn test_nf_access() {\n        let output = run_awk(\"{ print $NF }\", \"a b c\");\n        assert_eq!(output, \"c\\n\");\n    }\n\n    #[test]\n    fn test_field_modify() {\n        let output = run_awk(\"{ $2 = \\\"X\\\"; print $0 }\", \"a b c\");\n        assert_eq!(output, \"a X c\\n\");\n    }\n\n    #[test]\n    fn test_user_function() {\n        let output = run_awk(\"function double(x) { return x*2 } BEGIN { print double(5) }\", \"\");\n        assert_eq!(output, \"10\\n\");\n    }\n\n    #[test]\n    fn test_recursion() {\n        let output = run_awk(\"function fact(n) { return n\u003c=1 ? 1 : n*fact(n-1) } BEGIN { print fact(5) }\", \"\");\n        assert_eq!(output, \"120\\n\");\n    }\n\n    #[test]\n    fn test_printf() {\n        let output = run_awk(\"BEGIN { printf \\\"%d %s\\\\n\\\", 42, \\\"hello\\\" }\", \"\");\n        assert_eq!(output, \"42 hello\\n\");\n    }\n\n    #[test]\n    fn test_range_pattern() {\n        let output = run_awk(\"/start/,/end/ { print }\", \"before\\nstart\\nmiddle\\nend\\nafter\");\n        assert_eq!(output, \"start\\nmiddle\\nend\\n\");\n    }\n\n    #[test]\n    fn test_compound_pattern_and() {\n        let output = run_awk(\"NR \u003e 1 \u0026\u0026 NR \u003c 4 { print }\", \"one\\ntwo\\nthree\\nfour\");\n        assert_eq!(output, \"two\\nthree\\n\");\n    }\n\n    #[test]\n    fn test_logical_or_in_expr() {\n        let output = run_awk(\"{ if (/a/ || /c/) print }\", \"a\\nb\\nc\");\n        assert_eq!(output, \"a\\nc\\n\");\n    }\n\n    #[test]\n    fn test_negated_pattern() {\n        let output = run_awk(\"!/skip/ { print }\", \"keep\\nskip\\nkeep\");\n        assert_eq!(output, \"keep\\nkeep\\n\");\n    }\n\n    #[test]\n    fn test_builtin_length() {\n        let output = run_awk(\"BEGIN { print length(\\\"hello\\\") }\", \"\");\n        assert_eq!(output, \"5\\n\");\n    }\n\n    #[test]\n    fn test_builtin_substr() {\n        let output = run_awk(\"BEGIN { print substr(\\\"hello\\\", 2, 3) }\", \"\");\n        assert_eq!(output, \"ell\\n\");\n    }\n\n    #[test]\n    fn test_builtin_index() {\n        let output = run_awk(\"BEGIN { print index(\\\"hello\\\", \\\"ll\\\") }\", \"\");\n        assert_eq!(output, \"3\\n\");\n    }\n\n    #[test]\n    fn test_builtin_split() {\n        let output = run_awk(\"BEGIN { n = split(\\\"a:b:c\\\", arr, \\\":\\\"); print n, arr[1], arr[2] }\", \"\");\n        assert_eq!(output, \"3 a b\\n\");\n    }\n\n    #[test]\n    fn test_builtin_sub() {\n        let output = run_awk(\"BEGIN { x = \\\"hello\\\"; sub(\\\"l\\\", \\\"L\\\", x); print x }\", \"\");\n        assert_eq!(output, \"heLlo\\n\");\n    }\n\n    #[test]\n    fn test_builtin_gsub() {\n        let output = run_awk(\"BEGIN { x = \\\"hello\\\"; gsub(\\\"l\\\", \\\"L\\\", x); print x }\", \"\");\n        assert_eq!(output, \"heLLo\\n\");\n    }\n\n    #[test]\n    fn test_builtin_match() {\n        let output = run_awk(\"BEGIN { print match(\\\"hello\\\", \\\"ll\\\") }\", \"\");\n        assert_eq!(output, \"3\\n\");\n    }\n\n    #[test]\n    fn test_builtin_sprintf() {\n        let output = run_awk(\"BEGIN { print sprintf(\\\"%05d\\\", 42) }\", \"\");\n        assert_eq!(output, \"00042\\n\");\n    }\n\n    #[test]\n    fn test_builtin_tolower() {\n        let output = run_awk(\"BEGIN { print tolower(\\\"HELLO\\\") }\", \"\");\n        assert_eq!(output, \"hello\\n\");\n    }\n\n    #[test]\n    fn test_builtin_toupper() {\n        let output = run_awk(\"BEGIN { print toupper(\\\"hello\\\") }\", \"\");\n        assert_eq!(output, \"HELLO\\n\");\n    }\n\n    #[test]\n    fn test_builtin_math() {\n        let output = run_awk(\"BEGIN { print int(3.7), sqrt(4), sin(0) }\", \"\");\n        assert_eq!(output, \"3 2 0\\n\");\n    }\n\n    #[test]\n    fn test_ternary() {\n        let output = run_awk(\"BEGIN { print 1 ? \\\"yes\\\" : \\\"no\\\" }\", \"\");\n        assert_eq!(output, \"yes\\n\");\n    }\n\n    #[test]\n    fn test_concatenation() {\n        let output = run_awk(\"BEGIN { print \\\"a\\\" \\\"b\\\" \\\"c\\\" }\", \"\");\n        assert_eq!(output, \"abc\\n\");\n    }\n\n    #[test]\n    fn test_unary_ops() {\n        let output = run_awk(\"BEGIN { x = 5; print -x, +x, !0 }\", \"\");\n        assert_eq!(output, \"-5 5 1\\n\");\n    }\n\n    #[test]\n    fn test_post_increment() {\n        let output = run_awk(\"BEGIN { x = 5; print x++ \\\" \\\" x }\", \"\");\n        assert_eq!(output, \"5 6\\n\");\n    }\n\n    #[test]\n    fn test_pre_increment() {\n        let output = run_awk(\"BEGIN { x = 5; print ++x }\", \"\");\n        assert_eq!(output, \"6\\n\");\n    }\n\n    #[test]\n    fn test_compound_assign() {\n        let output = run_awk(\"BEGIN { x = 10; x += 5; x -= 3; x *= 2; print x }\", \"\");\n        assert_eq!(output, \"24\\n\");\n    }\n\n    #[test]\n    fn test_getline_var() {\n        let output = run_awk(\"{ getline next_line; print $0, next_line }\", \"a\\nb\");\n        // When we read \"a\", getline reads \"b\" into next_line\n        assert!(output.contains(\"a\") \u0026\u0026 output.contains(\"b\"));\n    }\n\n    #[test]\n    fn test_fpat() {\n        let output = run_awk(\"BEGIN { FPAT = \\\"[^,]+\\\" } { print $1, $2 }\", \"a,b,c\");\n        assert_eq!(output, \"a b\\n\");\n    }\n\n    #[test]\n    fn test_fieldwidths() {\n        let output = run_awk(\"BEGIN { FIELDWIDTHS = \\\"2 3 2\\\" } { print $1, $2 }\", \"abcdefg\");\n        assert_eq!(output, \"ab cde\\n\");\n    }\n\n    #[test]\n    fn test_paragraph_mode() {\n        let output = run_awk(\"BEGIN { RS = \\\"\\\" } { print NR, NF }\", \"a b\\nc d\\n\\ne f\");\n        // First paragraph has 4 words across 2 lines, second has 2 words\n        assert!(output.contains(\"1\"));\n    }\n}\n","traces":[{"line":30,"address":[3080768],"length":1,"stats":{"Line":1}},{"line":31,"address":[2734354],"length":1,"stats":{"Line":1}},{"line":32,"address":[3366517],"length":1,"stats":{"Line":1}},{"line":33,"address":[3092091],"length":1,"stats":{"Line":1}},{"line":37,"address":[2734224],"length":1,"stats":{"Line":0}},{"line":38,"address":[3080685],"length":1,"stats":{"Line":0}},{"line":39,"address":[3080724],"length":1,"stats":{"Line":0}},{"line":40,"address":[3091963],"length":1,"stats":{"Line":0}},{"line":138,"address":[3029600,3032520,3032626],"length":1,"stats":{"Line":4}},{"line":139,"address":[3315278],"length":1,"stats":{"Line":3}},{"line":140,"address":[3041013,3040937],"length":1,"stats":{"Line":10}},{"line":141,"address":[3032597,3029854],"length":1,"stats":{"Line":6}},{"line":145,"address":[2685000],"length":1,"stats":{"Line":5}},{"line":149,"address":[],"length":0,"stats":{"Line":25}},{"line":150,"address":[2685135],"length":1,"stats":{"Line":9}},{"line":151,"address":[],"length":0,"stats":{"Line":21}},{"line":156,"address":[3030115],"length":1,"stats":{"Line":6}},{"line":157,"address":[3041398],"length":1,"stats":{"Line":11}},{"line":159,"address":[3041508],"length":1,"stats":{"Line":6}},{"line":160,"address":[3041583],"length":1,"stats":{"Line":11}},{"line":161,"address":[2685487],"length":1,"stats":{"Line":6}},{"line":162,"address":[3041727],"length":1,"stats":{"Line":11}},{"line":163,"address":[3041799],"length":1,"stats":{"Line":17}},{"line":164,"address":[3316255],"length":1,"stats":{"Line":11}},{"line":165,"address":[3316327],"length":1,"stats":{"Line":18}},{"line":166,"address":[3042023],"length":1,"stats":{"Line":11}},{"line":167,"address":[3042079],"length":1,"stats":{"Line":18}},{"line":170,"address":[],"length":0,"stats":{"Line":11}},{"line":171,"address":[3042183],"length":1,"stats":{"Line":19}},{"line":175,"address":[3316635],"length":1,"stats":{"Line":11}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[3042299],"length":1,"stats":{"Line":21}},{"line":183,"address":[],"length":0,"stats":{"Line":11}},{"line":184,"address":[2686247],"length":1,"stats":{"Line":21}},{"line":185,"address":[3316863],"length":1,"stats":{"Line":11}},{"line":186,"address":[3042539],"length":1,"stats":{"Line":21}},{"line":190,"address":[2686395],"length":1,"stats":{"Line":11}},{"line":192,"address":[],"length":0,"stats":{"Line":21}},{"line":197,"address":[3044096,3044380,3044354],"length":1,"stats":{"Line":0}},{"line":198,"address":[3032862,3032935],"length":1,"stats":{"Line":0}},{"line":199,"address":[2687982],"length":1,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[3318416,3318360,3318327],"length":1,"stats":{"Line":2}},{"line":206,"address":[2687834],"length":1,"stats":{"Line":1}},{"line":207,"address":[3044074],"length":1,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[3301734],"length":1,"stats":{"Line":0}},{"line":213,"address":[3027361,3027378],"length":1,"stats":{"Line":0}},{"line":214,"address":[3301755],"length":1,"stats":{"Line":0}},{"line":219,"address":[3315184],"length":1,"stats":{"Line":0}},{"line":220,"address":[3315206],"length":1,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[3024299,3024048,3024328],"length":1,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[2668176,2668275],"length":1,"stats":{"Line":0}},{"line":233,"address":[3023895,3023935,3024001],"length":1,"stats":{"Line":0}},{"line":237,"address":[2751378,2748000,2750917],"length":1,"stats":{"Line":11}},{"line":239,"address":[2748174,2748063],"length":1,"stats":{"Line":33}},{"line":240,"address":[],"length":0,"stats":{"Line":33}},{"line":241,"address":[2211910],"length":1,"stats":{"Line":18}},{"line":242,"address":[2751074,2751123],"length":1,"stats":{"Line":11}},{"line":244,"address":[2751089],"length":1,"stats":{"Line":5}},{"line":245,"address":[2212255],"length":1,"stats":{"Line":1}},{"line":251,"address":[2241527,2243121,2246589,2245148,2241708,2244967],"length":1,"stats":{"Line":16}},{"line":252,"address":[2241803,2245255],"length":1,"stats":{"Line":7}},{"line":255,"address":[],"length":0,"stats":{"Line":14}},{"line":256,"address":[2211335,2210333],"length":1,"stats":{"Line":11}},{"line":257,"address":[2750503],"length":1,"stats":{"Line":2}},{"line":258,"address":[2247228,2247261,2243760,2243793],"length":1,"stats":{"Line":4}},{"line":260,"address":[2211487],"length":1,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[2211325,2210393],"length":1,"stats":{"Line":4}},{"line":269,"address":[2246388,2242920],"length":1,"stats":{"Line":5}},{"line":270,"address":[2750002,2749879],"length":1,"stats":{"Line":8}},{"line":271,"address":[2750070],"length":1,"stats":{"Line":1}},{"line":272,"address":[2438280,2438247],"length":1,"stats":{"Line":2}},{"line":274,"address":[2246802,2243334],"length":1,"stats":{"Line":1}},{"line":275,"address":[2750404],"length":1,"stats":{"Line":0}},{"line":280,"address":[2749924],"length":1,"stats":{"Line":3}},{"line":281,"address":[2749962],"length":1,"stats":{"Line":1}},{"line":286,"address":[2209560],"length":1,"stats":{"Line":6}},{"line":287,"address":[2209699,2209789],"length":1,"stats":{"Line":11}},{"line":288,"address":[2245613,2242161],"length":1,"stats":{"Line":3}},{"line":289,"address":[2209930],"length":1,"stats":{"Line":3}},{"line":294,"address":[],"length":0,"stats":{"Line":5}},{"line":297,"address":[],"length":0,"stats":{"Line":6}},{"line":299,"address":[2431371,2431453],"length":1,"stats":{"Line":12}},{"line":300,"address":[],"length":0,"stats":{"Line":8}},{"line":303,"address":[2742991,2742891],"length":1,"stats":{"Line":12}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[2204361],"length":1,"stats":{"Line":6}},{"line":307,"address":[2743065,2743887],"length":1,"stats":{"Line":6}},{"line":308,"address":[],"length":0,"stats":{"Line":6}},{"line":313,"address":[2431880],"length":1,"stats":{"Line":6}},{"line":314,"address":[],"length":0,"stats":{"Line":5}},{"line":315,"address":[2743415],"length":1,"stats":{"Line":5}},{"line":316,"address":[2233556,2234796],"length":1,"stats":{"Line":0}},{"line":320,"address":[2743362,2743502,2743535],"length":1,"stats":{"Line":9}},{"line":321,"address":[2432145,2432089,2432176],"length":1,"stats":{"Line":13}},{"line":322,"address":[2743628,2743580],"length":1,"stats":{"Line":14}},{"line":324,"address":[2235194,2233733,2233955,2234973],"length":1,"stats":{"Line":18}},{"line":326,"address":[2233879,2235119],"length":1,"stats":{"Line":4}},{"line":327,"address":[2743828],"length":1,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[2233893,2235133],"length":1,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[2204627],"length":1,"stats":{"Line":3}},{"line":341,"address":[2238816,2238795,2241157,2236464],"length":1,"stats":{"Line":4}},{"line":342,"address":[2206583],"length":1,"stats":{"Line":4}},{"line":343,"address":[2433854],"length":1,"stats":{"Line":4}},{"line":344,"address":[2238994,2236638],"length":1,"stats":{"Line":4}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[2433918],"length":1,"stats":{"Line":4}},{"line":348,"address":[2239066,2241117,2238756,2236718],"length":1,"stats":{"Line":4}},{"line":351,"address":[2434204],"length":1,"stats":{"Line":4}},{"line":353,"address":[],"length":0,"stats":{"Line":4}},{"line":355,"address":[2434335,2434376],"length":1,"stats":{"Line":8}},{"line":357,"address":[],"length":0,"stats":{"Line":12}},{"line":358,"address":[2207786,2207314],"length":1,"stats":{"Line":0}},{"line":360,"address":[2434679,2434600],"length":1,"stats":{"Line":4}},{"line":361,"address":[2237386,2239746,2239811,2237451,2239849,2237489],"length":1,"stats":{"Line":8}},{"line":362,"address":[2207579,2207514],"length":1,"stats":{"Line":8}},{"line":363,"address":[2207614],"length":1,"stats":{"Line":4}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":8}},{"line":370,"address":[2747193,2746907],"length":1,"stats":{"Line":6}},{"line":372,"address":[2208122,2208232],"length":1,"stats":{"Line":8}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":4}},{"line":376,"address":[2208374,2208405,2208314],"length":1,"stats":{"Line":8}},{"line":377,"address":[2240755,2238395,2238341,2240701],"length":1,"stats":{"Line":8}},{"line":378,"address":[2747886,2747578],"length":1,"stats":{"Line":4}},{"line":380,"address":[2435849],"length":1,"stats":{"Line":4}},{"line":381,"address":[],"length":0,"stats":{"Line":4}},{"line":383,"address":[],"length":0,"stats":{"Line":4}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[2207791],"length":1,"stats":{"Line":4}},{"line":390,"address":[2207866],"length":1,"stats":{"Line":3}},{"line":393,"address":[2207830,2207891],"length":1,"stats":{"Line":8}},{"line":394,"address":[2207954],"length":1,"stats":{"Line":4}},{"line":395,"address":[2747073],"length":1,"stats":{"Line":4}},{"line":396,"address":[2208034],"length":1,"stats":{"Line":0}},{"line":399,"address":[2747165,2747033],"length":1,"stats":{"Line":8}},{"line":400,"address":[2238020,2240380],"length":1,"stats":{"Line":4}},{"line":404,"address":[],"length":0,"stats":{"Line":4}},{"line":405,"address":[2747829],"length":1,"stats":{"Line":0}},{"line":408,"address":[2747795],"length":1,"stats":{"Line":4}},{"line":412,"address":[2235280],"length":1,"stats":{"Line":17}},{"line":413,"address":[2432668,2432587],"length":1,"stats":{"Line":35}},{"line":415,"address":[2235503,2235562],"length":1,"stats":{"Line":28}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[2205684],"length":1,"stats":{"Line":10}},{"line":422,"address":[2433044],"length":1,"stats":{"Line":12}},{"line":423,"address":[2235812],"length":1,"stats":{"Line":12}},{"line":424,"address":[2235867,2236128],"length":1,"stats":{"Line":14}},{"line":427,"address":[2205992,2206393],"length":1,"stats":{"Line":1}},{"line":431,"address":[2744953],"length":1,"stats":{"Line":3}},{"line":432,"address":[2745582],"length":1,"stats":{"Line":3}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[2206489,2206452],"length":1,"stats":{"Line":7}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[2744712],"length":1,"stats":{"Line":3}},{"line":443,"address":[2666448,2666547],"length":1,"stats":{"Line":7}},{"line":444,"address":[2666471,2666511,2666577],"length":1,"stats":{"Line":15}},{"line":445,"address":[3011045],"length":1,"stats":{"Line":8}},{"line":448,"address":[3024336,3026747,3026526],"length":1,"stats":{"Line":9}},{"line":449,"address":[3298743],"length":1,"stats":{"Line":8}},{"line":451,"address":[3013132],"length":1,"stats":{"Line":9}},{"line":452,"address":[2668772],"length":1,"stats":{"Line":1}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":19}},{"line":458,"address":[2668812],"length":1,"stats":{"Line":8}},{"line":461,"address":[3298982,3298943,3299025],"length":1,"stats":{"Line":20}},{"line":462,"address":[3024658],"length":1,"stats":{"Line":3}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[3013351,3013458,3013415],"length":1,"stats":{"Line":21}},{"line":468,"address":[3024739],"length":1,"stats":{"Line":3}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":15}},{"line":476,"address":[3299162],"length":1,"stats":{"Line":16}},{"line":477,"address":[3299138,3301110],"length":1,"stats":{"Line":4}},{"line":479,"address":[3024880,3025173,3025008],"length":1,"stats":{"Line":8}},{"line":480,"address":[3025024],"length":1,"stats":{"Line":4}},{"line":481,"address":[3299442],"length":1,"stats":{"Line":4}},{"line":483,"address":[3025070,3025190],"length":1,"stats":{"Line":8}},{"line":484,"address":[2669870,2669600],"length":1,"stats":{"Line":8}},{"line":485,"address":[2669755],"length":1,"stats":{"Line":4}},{"line":486,"address":[],"length":0,"stats":{"Line":4}},{"line":490,"address":[3014053],"length":1,"stats":{"Line":4}},{"line":493,"address":[3024921],"length":1,"stats":{"Line":1}},{"line":494,"address":[3024970],"length":1,"stats":{"Line":1}},{"line":495,"address":[3025715,3025638],"length":1,"stats":{"Line":2}},{"line":496,"address":[3014603,3014519],"length":1,"stats":{"Line":0}},{"line":497,"address":[2670122,2670246,2670344],"length":1,"stats":{"Line":3}},{"line":498,"address":[3026200,3026097],"length":1,"stats":{"Line":2}},{"line":499,"address":[3015002],"length":1,"stats":{"Line":1}},{"line":502,"address":[3300965],"length":1,"stats":{"Line":0}},{"line":506,"address":[2669703],"length":1,"stats":{"Line":17}},{"line":510,"address":[3025109,3023440,3024164],"length":1,"stats":{"Line":3}},{"line":511,"address":[2678714],"length":1,"stats":{"Line":3}},{"line":512,"address":[3023538],"length":1,"stats":{"Line":3}},{"line":514,"address":[3034870,3034947],"length":1,"stats":{"Line":6}},{"line":515,"address":[3035083,3035015,3035210],"length":1,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":9}},{"line":519,"address":[2679558,2679765,2679642],"length":1,"stats":{"Line":9}},{"line":520,"address":[3310530,3310248],"length":1,"stats":{"Line":6}},{"line":522,"address":[3310314],"length":1,"stats":{"Line":3}},{"line":525,"address":[3024080,3025041],"length":1,"stats":{"Line":6}},{"line":529,"address":[2683360,2684357,2684351],"length":1,"stats":{"Line":3}},{"line":530,"address":[2683383,2683464],"length":1,"stats":{"Line":6}},{"line":532,"address":[3313899],"length":1,"stats":{"Line":9}},{"line":535,"address":[3028317],"length":1,"stats":{"Line":3}},{"line":536,"address":[3313977,3314064],"length":1,"stats":{"Line":6}},{"line":538,"address":[3028720,3028573,3028462,3029108],"length":1,"stats":{"Line":12}},{"line":539,"address":[],"length":0,"stats":{"Line":6}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[3040114],"length":1,"stats":{"Line":3}},{"line":543,"address":[3028957],"length":1,"stats":{"Line":3}},{"line":544,"address":[3029069],"length":1,"stats":{"Line":3}},{"line":545,"address":[2684252],"length":1,"stats":{"Line":3}},{"line":548,"address":[3040385],"length":1,"stats":{"Line":3}},{"line":552,"address":[3044400],"length":1,"stats":{"Line":7}},{"line":553,"address":[],"length":0,"stats":{"Line":6}},{"line":554,"address":[],"length":0,"stats":{"Line":4}},{"line":555,"address":[2429894],"length":1,"stats":{"Line":7}},{"line":556,"address":[2176066],"length":1,"stats":{"Line":5}},{"line":558,"address":[2176049],"length":1,"stats":{"Line":2}},{"line":565,"address":[3026784],"length":1,"stats":{"Line":0}},{"line":566,"address":[3301192,3301225],"length":1,"stats":{"Line":0}},{"line":567,"address":[3301203],"length":1,"stats":{"Line":0}},{"line":568,"address":[3026848,3026910,3026993],"length":1,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[3026891],"length":1,"stats":{"Line":0}},{"line":575,"address":[3046297,3045264,3046332],"length":1,"stats":{"Line":3}},{"line":576,"address":[3035006,3034038],"length":1,"stats":{"Line":6}},{"line":577,"address":[2689086,2689171],"length":1,"stats":{"Line":1}},{"line":578,"address":[3319915,3319963],"length":1,"stats":{"Line":2}},{"line":581,"address":[3319983,3319780],"length":1,"stats":{"Line":6}},{"line":582,"address":[3034443,3035044],"length":1,"stats":{"Line":2}},{"line":584,"address":[2690015,2689363,2689490],"length":1,"stats":{"Line":6}},{"line":585,"address":[3045967],"length":1,"stats":{"Line":3}},{"line":587,"address":[3046007],"length":1,"stats":{"Line":3}},{"line":591,"address":[3027392,3028615,3028609],"length":1,"stats":{"Line":16}},{"line":592,"address":[],"length":0,"stats":{"Line":17}},{"line":593,"address":[2671765],"length":1,"stats":{"Line":12}},{"line":594,"address":[3016295],"length":1,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[2671822],"length":1,"stats":{"Line":5}},{"line":597,"address":[3016326,3017123],"length":1,"stats":{"Line":6}},{"line":598,"address":[2672727,2672784],"length":1,"stats":{"Line":8}},{"line":600,"address":[3027673],"length":1,"stats":{"Line":5}},{"line":601,"address":[2671928],"length":1,"stats":{"Line":6}},{"line":602,"address":[3302103,3303068],"length":1,"stats":{"Line":12}},{"line":603,"address":[3303250],"length":1,"stats":{"Line":9}},{"line":605,"address":[],"length":0,"stats":{"Line":3}},{"line":606,"address":[3027786],"length":1,"stats":{"Line":3}},{"line":607,"address":[3303890,3302223,3304255],"length":1,"stats":{"Line":9}},{"line":609,"address":[3303358,3303895,3303659,3303961],"length":1,"stats":{"Line":6}},{"line":610,"address":[3018266],"length":1,"stats":{"Line":3}},{"line":611,"address":[3029561],"length":1,"stats":{"Line":3}},{"line":613,"address":[3018231],"length":1,"stats":{"Line":3}},{"line":616,"address":[],"length":0,"stats":{"Line":3}},{"line":617,"address":[2673980],"length":1,"stats":{"Line":3}},{"line":619,"address":[3018596],"length":1,"stats":{"Line":3}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[3302273,3304279,3304951,3304682],"length":1,"stats":{"Line":0}},{"line":624,"address":[3018884,3019059],"length":1,"stats":{"Line":0}},{"line":626,"address":[3028042],"length":1,"stats":{"Line":0}},{"line":627,"address":[3028074,3031213,3031257,3030961,3030586],"length":1,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[2672447],"length":1,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[3033966,3033937,3033360],"length":1,"stats":{"Line":7}},{"line":637,"address":[3045196,3044704],"length":1,"stats":{"Line":16}},{"line":638,"address":[3044892,3044969,3044739],"length":1,"stats":{"Line":15}},{"line":639,"address":[3319413,3319484],"length":1,"stats":{"Line":17}},{"line":641,"address":[2688609],"length":1,"stats":{"Line":10}},{"line":644,"address":[],"length":0,"stats":{"Line":6}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[3022456,3022392],"length":1,"stats":{"Line":9}},{"line":648,"address":[2666727,2666868],"length":1,"stats":{"Line":10}},{"line":649,"address":[3011408,3011267],"length":1,"stats":{"Line":6}},{"line":650,"address":[],"length":0,"stats":{"Line":6}},{"line":651,"address":[3011483,3011580],"length":1,"stats":{"Line":6}},{"line":652,"address":[],"length":0,"stats":{"Line":5}},{"line":653,"address":[3011726,3011625],"length":1,"stats":{"Line":8}},{"line":654,"address":[2667266,2667367],"length":1,"stats":{"Line":5}},{"line":655,"address":[],"length":0,"stats":{"Line":11}},{"line":656,"address":[3011957,3011850],"length":1,"stats":{"Line":6}},{"line":657,"address":[2667497,2667607],"length":1,"stats":{"Line":11}},{"line":658,"address":[3297659,3297774],"length":1,"stats":{"Line":8}},{"line":659,"address":[3012093,3012234],"length":1,"stats":{"Line":11}},{"line":660,"address":[3012308,3012201],"length":1,"stats":{"Line":7}},{"line":662,"address":[3012415,3012275],"length":1,"stats":{"Line":10}},{"line":663,"address":[],"length":0,"stats":{"Line":4}},{"line":664,"address":[3023738],"length":1,"stats":{"Line":10}},{"line":669,"address":[3021024],"length":1,"stats":{"Line":4}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[3306769],"length":1,"stats":{"Line":4}},{"line":672,"address":[2676464],"length":1,"stats":{"Line":1}},{"line":673,"address":[2878626,2878608],"length":1,"stats":{"Line":3}},{"line":674,"address":[2744178,2744160],"length":1,"stats":{"Line":1}},{"line":676,"address":[3021152],"length":1,"stats":{"Line":5}},{"line":677,"address":[2744242,2744224],"length":1,"stats":{"Line":3}},{"line":679,"address":[2676526],"length":1,"stats":{"Line":5}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[3032679,3032611],"length":1,"stats":{"Line":3}},{"line":683,"address":[3021392,3021531],"length":1,"stats":{"Line":1}},{"line":684,"address":[3307152],"length":1,"stats":{"Line":1}},{"line":685,"address":[3308462,3307320],"length":1,"stats":{"Line":0}},{"line":686,"address":[3022715],"length":1,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[3034104],"length":1,"stats":{"Line":0}},{"line":690,"address":[3034208],"length":1,"stats":{"Line":0}},{"line":693,"address":[2676916,2677006],"length":1,"stats":{"Line":1}},{"line":694,"address":[3307354,3307500],"length":1,"stats":{"Line":2}},{"line":695,"address":[2677263,2677097],"length":1,"stats":{"Line":0}},{"line":696,"address":[2677235,2677382],"length":1,"stats":{"Line":0}},{"line":697,"address":[2677501,2677354],"length":1,"stats":{"Line":0}},{"line":698,"address":[3022348,3022201],"length":1,"stats":{"Line":0}},{"line":699,"address":[2677743,2677592],"length":1,"stats":{"Line":0}},{"line":700,"address":[2677905,2677711],"length":1,"stats":{"Line":0}},{"line":701,"address":[3308206],"length":1,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":6}},{"line":708,"address":[3036512,3039402,3039434],"length":1,"stats":{"Line":9}},{"line":710,"address":[],"length":0,"stats":{"Line":10}},{"line":711,"address":[],"length":0,"stats":{"Line":19}},{"line":712,"address":[3036741,3038871],"length":1,"stats":{"Line":2}},{"line":713,"address":[3027689],"length":1,"stats":{"Line":1}},{"line":714,"address":[3039000,3039138],"length":1,"stats":{"Line":2}},{"line":716,"address":[],"length":0,"stats":{"Line":2}},{"line":717,"address":[3039083],"length":1,"stats":{"Line":1}},{"line":720,"address":[3313427],"length":1,"stats":{"Line":1}},{"line":721,"address":[3039050,3039164],"length":1,"stats":{"Line":2}},{"line":723,"address":[3025497,3025446],"length":1,"stats":{"Line":32}},{"line":724,"address":[3038708,3036822],"length":1,"stats":{"Line":6}},{"line":726,"address":[3027550],"length":1,"stats":{"Line":3}},{"line":727,"address":[3027569],"length":1,"stats":{"Line":3}},{"line":729,"address":[2680719,2680833,2682502,2680772],"length":1,"stats":{"Line":39}},{"line":730,"address":[3025647,3025594,3027176,3025708],"length":1,"stats":{"Line":39}},{"line":731,"address":[3311431,3312690,3311317,3311370],"length":1,"stats":{"Line":31}},{"line":732,"address":[3026908,3025744,3025858,3025797],"length":1,"stats":{"Line":33}},{"line":733,"address":[2681954,2681072,2681133,2681019],"length":1,"stats":{"Line":33}},{"line":734,"address":[3311656,3311542,3311595,3312255],"length":1,"stats":{"Line":33}},{"line":736,"address":[3037286,3037233],"length":1,"stats":{"Line":26}},{"line":737,"address":[3037347,3037717],"length":1,"stats":{"Line":6}},{"line":739,"address":[],"length":0,"stats":{"Line":3}},{"line":741,"address":[],"length":0,"stats":{"Line":26}},{"line":742,"address":[3311947,3311818],"length":1,"stats":{"Line":6}},{"line":744,"address":[3312077],"length":1,"stats":{"Line":3}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[3037388,3037454],"length":1,"stats":{"Line":20}},{"line":753,"address":[3025152],"length":1,"stats":{"Line":12}},{"line":754,"address":[3036444],"length":1,"stats":{"Line":14}},{"line":757,"address":[3020592],"length":1,"stats":{"Line":3}},{"line":758,"address":[3031962],"length":1,"stats":{"Line":3}},{"line":761,"address":[],"length":0,"stats":{"Line":3}},{"line":762,"address":[3020847],"length":1,"stats":{"Line":1}},{"line":765,"address":[3032169],"length":1,"stats":{"Line":4}},{"line":766,"address":[3032176],"length":1,"stats":{"Line":4}},{"line":767,"address":[2592883,2592848],"length":1,"stats":{"Line":18}},{"line":769,"address":[],"length":0,"stats":{"Line":4}},{"line":772,"address":[],"length":0,"stats":{"Line":11}},{"line":773,"address":[3023207,3023123],"length":1,"stats":{"Line":22}},{"line":774,"address":[3308876],"length":1,"stats":{"Line":11}},{"line":775,"address":[3308883],"length":1,"stats":{"Line":11}},{"line":777,"address":[],"length":0,"stats":{"Line":11}},{"line":780,"address":[3020272],"length":1,"stats":{"Line":2}},{"line":781,"address":[3020315],"length":1,"stats":{"Line":2}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[3305994],"length":1,"stats":{"Line":2}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[2604034,2604016],"length":1,"stats":{"Line":0}},{"line":790,"address":[2675858,2675689],"length":1,"stats":{"Line":2}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[3020485],"length":1,"stats":{"Line":2}},{"line":793,"address":[3020492],"length":1,"stats":{"Line":2}},{"line":794,"address":[],"length":0,"stats":{"Line":6}},{"line":800,"address":[3040776,3040512,3040782],"length":1,"stats":{"Line":3}},{"line":801,"address":[3040564],"length":1,"stats":{"Line":2}},{"line":802,"address":[2684489,2684554],"length":1,"stats":{"Line":4}},{"line":803,"address":[],"length":0,"stats":{"Line":4}},{"line":807,"address":[3301392,3301692,3301686],"length":1,"stats":{"Line":5}},{"line":808,"address":[],"length":0,"stats":{"Line":11}},{"line":810,"address":[2671347],"length":1,"stats":{"Line":11}},{"line":812,"address":[3015888,3015954],"length":1,"stats":{"Line":11}}],"covered":308,"coverable":390},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","interpreter","stmt.rs"],"content":"use std::io::Write;\nuse std::fs::{File, OpenOptions};\nuse std::process::{Command, Stdio};\n\nuse crate::ast::*;\nuse crate::error::{Error, Result};\nuse crate::value::Value;\n\nuse super::{Interpreter, OutputFile};\n\n/// Result of executing a statement\npub enum StmtResult {\n    Normal,\n    Break,\n    Continue,\n    Return(Value),\n}\n\nimpl\u003c'a\u003e Interpreter\u003c'a\u003e {\n    pub fn execute_block\u003cW: Write\u003e(\u0026mut self, block: \u0026Block, output: \u0026mut W) -\u003e Result\u003cStmtResult\u003e {\n        for stmt in \u0026block.statements {\n            let result = self.execute_stmt(stmt, output)?;\n            match result {\n                StmtResult::Normal =\u003e continue,\n                other =\u003e return Ok(other),\n            }\n        }\n        Ok(StmtResult::Normal)\n    }\n\n    pub fn execute_stmt\u003cW: Write\u003e(\u0026mut self, stmt: \u0026Stmt, output: \u0026mut W) -\u003e Result\u003cStmtResult\u003e {\n        match stmt {\n            Stmt::Empty =\u003e Ok(StmtResult::Normal),\n\n            Stmt::Expr(expr) =\u003e {\n                self.eval_expr_with_output(expr, output)?;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Print { args, output: redirect, .. } =\u003e {\n                self.execute_print(args, redirect, output)?;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Printf { format, args, output: redirect, .. } =\u003e {\n                self.execute_printf(format, args, redirect, output)?;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::If { condition, then_branch, else_branch, .. } =\u003e {\n                let cond = self.eval_expr_with_output(condition, output)?;\n                if cond.is_truthy() {\n                    self.execute_stmt(then_branch, output)\n                } else if let Some(else_stmt) = else_branch {\n                    self.execute_stmt(else_stmt, output)\n                } else {\n                    Ok(StmtResult::Normal)\n                }\n            }\n\n            Stmt::While { condition, body, .. } =\u003e {\n                loop {\n                    let cond = self.eval_expr_with_output(condition, output)?;\n                    if !cond.is_truthy() {\n                        break;\n                    }\n                    match self.execute_stmt(body, output)? {\n                        StmtResult::Normal | StmtResult::Continue =\u003e continue,\n                        StmtResult::Break =\u003e break,\n                        StmtResult::Return(v) =\u003e return Ok(StmtResult::Return(v)),\n                    }\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::DoWhile { body, condition, .. } =\u003e {\n                loop {\n                    match self.execute_stmt(body, output)? {\n                        StmtResult::Normal | StmtResult::Continue =\u003e {}\n                        StmtResult::Break =\u003e break,\n                        StmtResult::Return(v) =\u003e return Ok(StmtResult::Return(v)),\n                    }\n                    let cond = self.eval_expr_with_output(condition, output)?;\n                    if !cond.is_truthy() {\n                        break;\n                    }\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::For { init, condition, update, body, .. } =\u003e {\n                // Execute init\n                if let Some(init_stmt) = init {\n                    self.execute_stmt(init_stmt, output)?;\n                }\n\n                loop {\n                    // Check condition\n                    if let Some(cond_expr) = condition {\n                        let cond = self.eval_expr_with_output(cond_expr, output)?;\n                        if !cond.is_truthy() {\n                            break;\n                        }\n                    }\n\n                    // Execute body\n                    match self.execute_stmt(body, output)? {\n                        StmtResult::Normal | StmtResult::Continue =\u003e {}\n                        StmtResult::Break =\u003e break,\n                        StmtResult::Return(v) =\u003e return Ok(StmtResult::Return(v)),\n                    }\n\n                    // Execute update\n                    if let Some(update_expr) = update {\n                        self.eval_expr_with_output(update_expr, output)?;\n                    }\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::ForIn { var, array, body, .. } =\u003e {\n                // Get keys from array (resolve aliases for pass-by-reference)\n                let resolved_array = self.array_aliases.get(array).map(|s| s.as_str()).unwrap_or(array);\n                let keys: Vec\u003cString\u003e = self.arrays\n                    .get(resolved_array)\n                    .map(|arr| arr.keys().cloned().collect())\n                    .unwrap_or_default();\n\n                for key in keys {\n                    self.set_variable_value(var, Value::from_string(key));\n                    match self.execute_stmt(body, output)? {\n                        StmtResult::Normal | StmtResult::Continue =\u003e continue,\n                        StmtResult::Break =\u003e break,\n                        StmtResult::Return(v) =\u003e return Ok(StmtResult::Return(v)),\n                    }\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Block(block) =\u003e self.execute_block(block, output),\n\n            Stmt::Break { .. } =\u003e Ok(StmtResult::Break),\n\n            Stmt::Continue { .. } =\u003e Ok(StmtResult::Continue),\n\n            Stmt::Next { .. } =\u003e {\n                self.should_next = true;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Nextfile { .. } =\u003e {\n                self.should_nextfile = true;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Exit { code, .. } =\u003e {\n                self.exit_code = code.as_ref()\n                    .map(|e| self.eval_expr_with_output(e, output).map(|v| v.to_number() as i32))\n                    .transpose()?\n                    .unwrap_or(0);\n                self.should_exit = true;\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Return { value, .. } =\u003e {\n                let val = value.as_ref()\n                    .map(|e| self.eval_expr_with_output(e, output))\n                    .transpose()?\n                    .unwrap_or(Value::Uninitialized);\n                Ok(StmtResult::Return(val))\n            }\n\n            Stmt::Delete { array, index, .. } =\u003e {\n                if index.is_empty() {\n                    // delete array (entire array)\n                    self.arrays.remove(array);\n                } else {\n                    let key_parts: Result\u003cVec\u003cValue\u003e\u003e = index.iter()\n                        .map(|e| self.eval_expr_with_output(e, output))\n                        .collect();\n                    let key = self.make_array_key(\u0026key_parts?);\n                    self.delete_array_element(array, \u0026key);\n                }\n                Ok(StmtResult::Normal)\n            }\n\n            Stmt::Getline { var, input, location } =\u003e {\n                // Getline as a statement\n                let _result = self.eval_getline(var.as_ref(), input.as_ref(), *location)?;\n                Ok(StmtResult::Normal)\n            }\n        }\n    }\n\n    fn execute_print\u003cW: Write\u003e(\n        \u0026mut self,\n        args: \u0026[Expr],\n        redirect: \u0026Option\u003cOutputRedirect\u003e,\n        default_output: \u0026mut W,\n    ) -\u003e Result\u003c()\u003e {\n        let values: Result\u003cVec\u003cString\u003e\u003e = args.iter()\n            .map(|e| self.eval_expr_with_output(e, default_output).map(|v| v.to_string_val()))\n            .collect();\n        let values = values?;\n\n        let line = if values.is_empty() {\n            // print without args prints $0\n            self.record.clone()\n        } else {\n            values.join(\u0026self.ofs)\n        };\n\n        // Handle output redirection\n        match redirect {\n            None =\u003e {\n                writeln!(default_output, \"{}\", line).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Truncate(target_expr)) =\u003e {\n                let filename = self.eval_expr_with_output(target_expr, default_output)?.to_string_val();\n                let file = self.get_or_open_file(\u0026filename, false)?;\n                writeln!(file, \"{}\", line).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Append(target_expr)) =\u003e {\n                let filename = self.eval_expr_with_output(target_expr, default_output)?.to_string_val();\n                let file = self.get_or_open_file(\u0026filename, true)?;\n                writeln!(file, \"{}\", line).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Pipe(cmd_expr)) =\u003e {\n                let cmd = self.eval_expr_with_output(cmd_expr, default_output)?.to_string_val();\n                let pipe = self.get_or_open_pipe(\u0026cmd)?;\n                writeln!(pipe, \"{}\", line).map_err(Error::Io)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute_printf\u003cW: Write\u003e(\n        \u0026mut self,\n        format_expr: \u0026Expr,\n        args: \u0026[Expr],\n        redirect: \u0026Option\u003cOutputRedirect\u003e,\n        default_output: \u0026mut W,\n    ) -\u003e Result\u003c()\u003e {\n        let format = self.eval_expr_with_output(format_expr, default_output)?.to_string_val();\n        let values: Result\u003cVec\u003cValue\u003e\u003e = args.iter()\n            .map(|e| self.eval_expr_with_output(e, default_output))\n            .collect();\n        let values = values?;\n\n        let formatted = self.format_printf(\u0026format, \u0026values);\n\n        // Handle output redirection\n        match redirect {\n            None =\u003e {\n                write!(default_output, \"{}\", formatted).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Truncate(target_expr)) =\u003e {\n                let filename = self.eval_expr_with_output(target_expr, default_output)?.to_string_val();\n                let file = self.get_or_open_file(\u0026filename, false)?;\n                write!(file, \"{}\", formatted).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Append(target_expr)) =\u003e {\n                let filename = self.eval_expr_with_output(target_expr, default_output)?.to_string_val();\n                let file = self.get_or_open_file(\u0026filename, true)?;\n                write!(file, \"{}\", formatted).map_err(Error::Io)?;\n            }\n            Some(OutputRedirect::Pipe(cmd_expr)) =\u003e {\n                let cmd = self.eval_expr_with_output(cmd_expr, default_output)?.to_string_val();\n                let pipe = self.get_or_open_pipe(\u0026cmd)?;\n                write!(pipe, \"{}\", formatted).map_err(Error::Io)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get or open a file for output redirection\n    fn get_or_open_file(\u0026mut self, filename: \u0026str, append: bool) -\u003e Result\u003c\u0026mut OutputFile\u003e {\n        if !self.output_files.contains_key(filename) {\n            let file = if append {\n                OpenOptions::new()\n                    .create(true)\n                    .append(true)\n                    .open(filename)\n                    .map_err(Error::Io)?\n            } else {\n                File::create(filename).map_err(Error::Io)?\n            };\n            self.output_files.insert(filename.to_string(), OutputFile::File(file));\n        }\n        Ok(self.output_files.get_mut(filename).unwrap())\n    }\n\n    /// Get or open a pipe for output redirection\n    fn get_or_open_pipe(\u0026mut self, cmd: \u0026str) -\u003e Result\u003c\u0026mut OutputFile\u003e {\n        if !self.output_files.contains_key(cmd) {\n            let child = Command::new(\"sh\")\n                .arg(\"-c\")\n                .arg(cmd)\n                .stdin(Stdio::piped())\n                .spawn()\n                .map_err(Error::Io)?;\n\n            let stdin = child.stdin.unwrap();\n            self.output_files.insert(cmd.to_string(), OutputFile::Pipe(stdin));\n        }\n        Ok(self.output_files.get_mut(cmd).unwrap())\n    }\n\n    pub(crate) fn format_printf(\u0026self, format: \u0026str, args: \u0026[Value]) -\u003e String {\n        let mut result = String::new();\n        let mut chars = format.chars().peekable();\n        let mut arg_idx = 0;\n\n        while let Some(ch) = chars.next() {\n            if ch != '%' {\n                result.push(ch);\n                continue;\n            }\n\n            // Check for %%\n            if chars.peek() == Some(\u0026'%') {\n                chars.next();\n                result.push('%');\n                continue;\n            }\n\n            // Parse format specifier\n            let mut width = String::new();\n            let mut precision = String::new();\n            let mut flags = String::new();\n\n            // Flags\n            while let Some(\u0026c) = chars.peek() {\n                if c == '-' || c == '+' || c == ' ' || c == '#' || c == '0' {\n                    flags.push(c);\n                    chars.next();\n                } else {\n                    break;\n                }\n            }\n\n            // Width\n            while let Some(\u0026c) = chars.peek() {\n                if c.is_ascii_digit() {\n                    width.push(c);\n                    chars.next();\n                } else {\n                    break;\n                }\n            }\n\n            // Precision\n            if chars.peek() == Some(\u0026'.') {\n                chars.next();\n                while let Some(\u0026c) = chars.peek() {\n                    if c.is_ascii_digit() {\n                        precision.push(c);\n                        chars.next();\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            // Conversion specifier\n            let spec = chars.next().unwrap_or('s');\n            let arg = args.get(arg_idx).cloned().unwrap_or(Value::Uninitialized);\n            arg_idx += 1;\n\n            let width_num: Option\u003cusize\u003e = width.parse().ok();\n            let precision_num: Option\u003cusize\u003e = precision.parse().ok();\n            let left_align = flags.contains('-');\n\n            let formatted = match spec {\n                's' =\u003e {\n                    let s = arg.to_string_val();\n                    let s = if let Some(p) = precision_num {\n                        s.chars().take(p).collect()\n                    } else {\n                        s\n                    };\n                    if let Some(w) = width_num {\n                        if left_align {\n                            format!(\"{:\u003cwidth$}\", s, width = w)\n                        } else {\n                            format!(\"{:\u003ewidth$}\", s, width = w)\n                        }\n                    } else {\n                        s\n                    }\n                }\n                'd' | 'i' =\u003e {\n                    let n = arg.to_number() as i64;\n                    if let Some(w) = width_num {\n                        if flags.contains('0') \u0026\u0026 !left_align {\n                            format!(\"{:0\u003ewidth$}\", n, width = w)\n                        } else if left_align {\n                            format!(\"{:\u003cwidth$}\", n, width = w)\n                        } else {\n                            format!(\"{:\u003ewidth$}\", n, width = w)\n                        }\n                    } else {\n                        format!(\"{}\", n)\n                    }\n                }\n                'f' | 'F' =\u003e {\n                    let n = arg.to_number();\n                    let p = precision_num.unwrap_or(6);\n                    if let Some(w) = width_num {\n                        if left_align {\n                            format!(\"{:\u003cwidth$.prec$}\", n, width = w, prec = p)\n                        } else {\n                            format!(\"{:\u003ewidth$.prec$}\", n, width = w, prec = p)\n                        }\n                    } else {\n                        format!(\"{:.prec$}\", n, prec = p)\n                    }\n                }\n                'e' | 'E' =\u003e {\n                    let n = arg.to_number();\n                    let p = precision_num.unwrap_or(6);\n                    format!(\"{:.prec$e}\", n, prec = p)\n                }\n                'g' | 'G' =\u003e {\n                    let n = arg.to_number();\n                    let p = precision_num.unwrap_or(6);\n                    // Simplified %g implementation\n                    if n.abs() \u003e= 1e-4 \u0026\u0026 n.abs() \u003c 10f64.powi(p as i32) {\n                        format!(\"{:.prec$}\", n, prec = p)\n                    } else {\n                        format!(\"{:.prec$e}\", n, prec = p)\n                    }\n                }\n                'o' =\u003e format!(\"{:o}\", arg.to_number() as u64),\n                'x' =\u003e format!(\"{:x}\", arg.to_number() as u64),\n                'X' =\u003e format!(\"{:X}\", arg.to_number() as u64),\n                'c' =\u003e {\n                    let n = arg.to_number() as u32;\n                    char::from_u32(n).map(|c| c.to_string()).unwrap_or_default()\n                }\n                _ =\u003e format!(\"%{}\", spec),\n            };\n\n            result.push_str(\u0026formatted);\n        }\n\n        result\n    }\n}\n","traces":[{"line":20,"address":[2810192,2809552],"length":1,"stats":{"Line":19}},{"line":21,"address":[2634160,2634176],"length":1,"stats":{"Line":28}},{"line":22,"address":[],"length":0,"stats":{"Line":9}},{"line":23,"address":[2278077],"length":1,"stats":{"Line":3}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[2278147],"length":1,"stats":{"Line":4}},{"line":28,"address":[2908695],"length":1,"stats":{"Line":10}},{"line":31,"address":[2902151,2902157,2898512],"length":1,"stats":{"Line":20}},{"line":32,"address":[2799830,2790022],"length":1,"stats":{"Line":8}},{"line":33,"address":[2615201],"length":1,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":15}},{"line":36,"address":[2613051,2615279],"length":1,"stats":{"Line":14}},{"line":37,"address":[],"length":0,"stats":{"Line":13}},{"line":40,"address":[2624396],"length":1,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[2792681,2802489],"length":1,"stats":{"Line":10}},{"line":45,"address":[2459583],"length":1,"stats":{"Line":3}},{"line":46,"address":[2459629,2462000],"length":1,"stats":{"Line":3}},{"line":47,"address":[2270596],"length":1,"stats":{"Line":4}},{"line":50,"address":[2268301],"length":1,"stats":{"Line":3}},{"line":51,"address":[2627131,2624810],"length":1,"stats":{"Line":4}},{"line":52,"address":[2235062,2235127],"length":1,"stats":{"Line":7}},{"line":53,"address":[2627666,2627378],"length":1,"stats":{"Line":7}},{"line":54,"address":[2616264,2616152,2616078],"length":1,"stats":{"Line":11}},{"line":55,"address":[2627424,2627538],"length":1,"stats":{"Line":4}},{"line":57,"address":[2235254],"length":1,"stats":{"Line":5}},{"line":61,"address":[2624891],"length":1,"stats":{"Line":3}},{"line":62,"address":[2624934],"length":1,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":6}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[2628590],"length":1,"stats":{"Line":0}},{"line":73,"address":[2793850,2803658],"length":1,"stats":{"Line":3}},{"line":76,"address":[2232751],"length":1,"stats":{"Line":2}},{"line":77,"address":[2613726],"length":1,"stats":{"Line":2}},{"line":78,"address":[2236588],"length":1,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[2629338],"length":1,"stats":{"Line":0}},{"line":83,"address":[2903555,2903910],"length":1,"stats":{"Line":2}},{"line":84,"address":[2618459,2618394],"length":1,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[2617988],"length":1,"stats":{"Line":2}},{"line":91,"address":[2625003],"length":1,"stats":{"Line":5}},{"line":93,"address":[2273303,2268649],"length":1,"stats":{"Line":10}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[2904198,2904614],"length":1,"stats":{"Line":12}},{"line":100,"address":[2904726,2904622],"length":1,"stats":{"Line":7}},{"line":101,"address":[2904923,2904858],"length":1,"stats":{"Line":11}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[2465310,2465672],"length":1,"stats":{"Line":11}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[2466034],"length":1,"stats":{"Line":0}},{"line":114,"address":[2619734,2619985],"length":1,"stats":{"Line":7}},{"line":115,"address":[2274782],"length":1,"stats":{"Line":4}},{"line":118,"address":[2796300,2806108],"length":1,"stats":{"Line":4}},{"line":121,"address":[2790954,2800762],"length":1,"stats":{"Line":4}},{"line":123,"address":[2989897,2989888],"length":1,"stats":{"Line":4}},{"line":124,"address":[2899725],"length":1,"stats":{"Line":4}},{"line":125,"address":[2625348],"length":1,"stats":{"Line":4}},{"line":126,"address":[3001251,3001232],"length":1,"stats":{"Line":12}},{"line":129,"address":[2466524,2460411,2466595],"length":1,"stats":{"Line":12}},{"line":130,"address":[],"length":0,"stats":{"Line":8}},{"line":131,"address":[2631973,2632577],"length":1,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[2807855,2798047],"length":1,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[2899900],"length":1,"stats":{"Line":4}},{"line":142,"address":[2614283],"length":1,"stats":{"Line":3}},{"line":144,"address":[2233434],"length":1,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[2233528],"length":1,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[2460845],"length":1,"stats":{"Line":1}},{"line":153,"address":[2269380],"length":1,"stats":{"Line":1}},{"line":156,"address":[2460938],"length":1,"stats":{"Line":2}},{"line":157,"address":[2798314,2808122,2808200,2791723,2791781,2798392,2801589,2801531],"length":1,"stats":{"Line":6}},{"line":158,"address":[2791747,2801555],"length":1,"stats":{"Line":6}},{"line":159,"address":[2798280,2808088,2791760,2801568],"length":1,"stats":{"Line":2}},{"line":160,"address":[2467681],"length":1,"stats":{"Line":2}},{"line":161,"address":[2276241],"length":1,"stats":{"Line":2}},{"line":162,"address":[2621464],"length":1,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[2276360,2269677,2269617],"length":1,"stats":{"Line":8}},{"line":167,"address":[2539744,2539782],"length":1,"stats":{"Line":12}},{"line":169,"address":[2467922],"length":1,"stats":{"Line":4}},{"line":170,"address":[2276506],"length":1,"stats":{"Line":5}},{"line":173,"address":[2614937],"length":1,"stats":{"Line":2}},{"line":174,"address":[2900628],"length":1,"stats":{"Line":2}},{"line":176,"address":[2808737,2798929],"length":1,"stats":{"Line":1}},{"line":178,"address":[2240894],"length":1,"stats":{"Line":2}},{"line":179,"address":[2621891],"length":1,"stats":{"Line":6}},{"line":181,"address":[2276817,2276709],"length":1,"stats":{"Line":4}},{"line":182,"address":[2809063,2799255],"length":1,"stats":{"Line":3}},{"line":184,"address":[2241501],"length":1,"stats":{"Line":2}},{"line":187,"address":[2801860,2792052],"length":1,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[2622737],"length":1,"stats":{"Line":0}},{"line":195,"address":[2625630,2623488,2627461],"length":1,"stats":{"Line":10}},{"line":201,"address":[2909261],"length":1,"stats":{"Line":6}},{"line":202,"address":[2278422],"length":1,"stats":{"Line":32}},{"line":204,"address":[],"length":0,"stats":{"Line":5}},{"line":206,"address":[2278630,2278707],"length":1,"stats":{"Line":10}},{"line":208,"address":[2909792,2909622],"length":1,"stats":{"Line":8}},{"line":210,"address":[2470185,2470291],"length":1,"stats":{"Line":11}},{"line":214,"address":[2624119,2624154],"length":1,"stats":{"Line":7}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[2624203,2624550,2624274],"length":1,"stats":{"Line":14}},{"line":218,"address":[2815747,2811923],"length":1,"stats":{"Line":1}},{"line":219,"address":[2636900,2635876,2636011],"length":1,"stats":{"Line":2}},{"line":220,"address":[2625089,2625628],"length":1,"stats":{"Line":1}},{"line":221,"address":[2625315,2625604],"length":1,"stats":{"Line":1}},{"line":223,"address":[2811974,2815798],"length":1,"stats":{"Line":1}},{"line":224,"address":[2911289,2912175,2910315],"length":1,"stats":{"Line":2}},{"line":225,"address":[2637789,2637247],"length":1,"stats":{"Line":1}},{"line":226,"address":[2472743,2472454],"length":1,"stats":{"Line":1}},{"line":228,"address":[2812028,2815852],"length":1,"stats":{"Line":1}},{"line":229,"address":[2817595,2815872,2818443,2812048,2814619,2813771],"length":1,"stats":{"Line":2}},{"line":230,"address":[2912522,2913086],"length":1,"stats":{"Line":1}},{"line":231,"address":[2638678,2638361],"length":1,"stats":{"Line":1}},{"line":235,"address":[2243559],"length":1,"stats":{"Line":7}},{"line":238,"address":[2476168,2478039,2473728],"length":1,"stats":{"Line":3}},{"line":245,"address":[2473842],"length":1,"stats":{"Line":3}},{"line":246,"address":[2627936],"length":1,"stats":{"Line":3}},{"line":247,"address":[2913643],"length":1,"stats":{"Line":9}},{"line":249,"address":[2282800,2286565],"length":1,"stats":{"Line":3}},{"line":251,"address":[2639517,2639610],"length":1,"stats":{"Line":22}},{"line":254,"address":[],"length":0,"stats":{"Line":3}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[2823615,2823950,2823686,2819806,2819542,2819471],"length":1,"stats":{"Line":7}},{"line":258,"address":[2283678],"length":1,"stats":{"Line":1}},{"line":259,"address":[2283813,2284702,2283698],"length":1,"stats":{"Line":2}},{"line":260,"address":[2284694,2284155],"length":1,"stats":{"Line":1}},{"line":261,"address":[2629634,2629923],"length":1,"stats":{"Line":1}},{"line":263,"address":[2640238],"length":1,"stats":{"Line":0}},{"line":264,"address":[2825001,2819927,2825827,2820857,2824071,2821683],"length":1,"stats":{"Line":0}},{"line":265,"address":[2249305,2249847],"length":1,"stats":{"Line":0}},{"line":266,"address":[2285278,2285567],"length":1,"stats":{"Line":0}},{"line":268,"address":[2914680],"length":1,"stats":{"Line":0}},{"line":269,"address":[2642115,2640308,2643042],"length":1,"stats":{"Line":0}},{"line":270,"address":[2286523,2285940],"length":1,"stats":{"Line":0}},{"line":271,"address":[2917400,2917064],"length":1,"stats":{"Line":0}},{"line":275,"address":[2475071],"length":1,"stats":{"Line":3}},{"line":279,"address":[3336180,3336209,3335376],"length":1,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[3336039,3335501],"length":1,"stats":{"Line":2}},{"line":282,"address":[3061609,3061390,3061300],"length":1,"stats":{"Line":2}},{"line":285,"address":[3335741],"length":1,"stats":{"Line":1}},{"line":286,"address":[3061581,3061371],"length":1,"stats":{"Line":1}},{"line":288,"address":[2704530,2704759],"length":1,"stats":{"Line":1}},{"line":290,"address":[3050439,3050271],"length":1,"stats":{"Line":2}},{"line":292,"address":[3049878],"length":1,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[3062923,3061936],"length":1,"stats":{"Line":2}},{"line":298,"address":[3050705,3051123,3051015],"length":1,"stats":{"Line":2}},{"line":300,"address":[3062168],"length":1,"stats":{"Line":1}},{"line":301,"address":[3050920],"length":1,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":2}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[3062613,3062689],"length":1,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":13}},{"line":312,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[3328108,3328191],"length":1,"stats":{"Line":19}},{"line":314,"address":[2697310],"length":1,"stats":{"Line":14}},{"line":316,"address":[],"length":0,"stats":{"Line":6}},{"line":317,"address":[2697409],"length":1,"stats":{"Line":14}},{"line":318,"address":[],"length":0,"stats":{"Line":8}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[2697531,2697483],"length":1,"stats":{"Line":17}},{"line":324,"address":[3042860],"length":1,"stats":{"Line":1}},{"line":325,"address":[3335337],"length":1,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[3328501],"length":1,"stats":{"Line":5}},{"line":331,"address":[3042890],"length":1,"stats":{"Line":12}},{"line":332,"address":[3054261,3054213],"length":1,"stats":{"Line":17}},{"line":335,"address":[2697803,2697739],"length":1,"stats":{"Line":16}},{"line":336,"address":[3054402,3054465],"length":1,"stats":{"Line":10}},{"line":337,"address":[3043187],"length":1,"stats":{"Line":5}},{"line":338,"address":[],"length":0,"stats":{"Line":3}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[3043145,3043276],"length":1,"stats":{"Line":14}},{"line":346,"address":[3329036,3328988],"length":1,"stats":{"Line":9}},{"line":347,"address":[3329042],"length":1,"stats":{"Line":4}},{"line":348,"address":[2698140],"length":1,"stats":{"Line":5}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[3043354,3043448],"length":1,"stats":{"Line":7}},{"line":356,"address":[3329179],"length":1,"stats":{"Line":4}},{"line":357,"address":[3054816],"length":1,"stats":{"Line":4}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":4}},{"line":360,"address":[2698407],"length":1,"stats":{"Line":4}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":6}},{"line":369,"address":[2698475],"length":1,"stats":{"Line":5}},{"line":370,"address":[2698645,2698570],"length":1,"stats":{"Line":11}},{"line":372,"address":[],"length":0,"stats":{"Line":17}},{"line":373,"address":[],"length":0,"stats":{"Line":5}},{"line":374,"address":[],"length":0,"stats":{"Line":11}},{"line":376,"address":[],"length":0,"stats":{"Line":6}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[3055721,3055947],"length":1,"stats":{"Line":11}},{"line":379,"address":[3044824,3044691],"length":1,"stats":{"Line":12}},{"line":380,"address":[2699401,2699550],"length":1,"stats":{"Line":0}},{"line":382,"address":[3056024],"length":1,"stats":{"Line":5}},{"line":384,"address":[2699730,2699631],"length":1,"stats":{"Line":8}},{"line":385,"address":[3045012],"length":1,"stats":{"Line":4}},{"line":386,"address":[],"length":0,"stats":{"Line":6}},{"line":388,"address":[3056351,3056492],"length":1,"stats":{"Line":2}},{"line":391,"address":[3056282],"length":1,"stats":{"Line":4}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":8}},{"line":396,"address":[3331424],"length":1,"stats":{"Line":4}},{"line":397,"address":[3045936,3045879,3045814],"length":1,"stats":{"Line":9}},{"line":398,"address":[3045950],"length":1,"stats":{"Line":3}},{"line":399,"address":[3057180],"length":1,"stats":{"Line":0}},{"line":400,"address":[2701088,2700871],"length":1,"stats":{"Line":0}},{"line":402,"address":[3057537,3057440],"length":1,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":6}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[3332385,3330150],"length":1,"stats":{"Line":8}},{"line":410,"address":[3332394],"length":1,"stats":{"Line":2}},{"line":411,"address":[3058060],"length":1,"stats":{"Line":2}},{"line":412,"address":[2701473],"length":1,"stats":{"Line":1}},{"line":413,"address":[2701895,2701608],"length":1,"stats":{"Line":0}},{"line":415,"address":[3058314,3058169],"length":1,"stats":{"Line":2}},{"line":418,"address":[],"length":0,"stats":{"Line":5}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[3330177,3333324],"length":1,"stats":{"Line":2}},{"line":423,"address":[3047685],"length":1,"stats":{"Line":1}},{"line":424,"address":[2702367],"length":1,"stats":{"Line":1}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[3047970,3044556],"length":1,"stats":{"Line":2}},{"line":428,"address":[2702599],"length":1,"stats":{"Line":1}},{"line":430,"address":[],"length":0,"stats":{"Line":2}},{"line":431,"address":[3048419,3048198],"length":1,"stats":{"Line":2}},{"line":433,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[3059875,3055847],"length":1,"stats":{"Line":2}},{"line":437,"address":[2699274,2703453],"length":1,"stats":{"Line":2}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":4}},{"line":441,"address":[2990512,2990528],"length":1,"stats":{"Line":6}},{"line":443,"address":[3060668,3055675],"length":1,"stats":{"Line":0}},{"line":446,"address":[3045676,3049571],"length":1,"stats":{"Line":6}},{"line":449,"address":[3042688],"length":1,"stats":{"Line":3}}],"covered":204,"coverable":253},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","lexer","mod.rs"],"content":"mod tokens;\n\npub use tokens::{keyword_to_token, Token, TokenKind};\n\nuse crate::error::{Error, Result};\n\n/// AWK lexer that tokenizes source code\npub struct Lexer\u003c'a\u003e {\n    source: \u0026'a str,\n    chars: std::iter::Peekable\u003cstd::str::CharIndices\u003c'a\u003e\u003e,\n    line: usize,\n    column: usize,\n    last_token_produces_value: bool,\n}\n\nimpl\u003c'a\u003e Lexer\u003c'a\u003e {\n    pub fn new(source: \u0026'a str) -\u003e Self {\n        Self {\n            source,\n            chars: source.char_indices().peekable(),\n            line: 1,\n            column: 1,\n            last_token_produces_value: false,\n        }\n    }\n\n    /// Tokenize the entire source, returning all tokens\n    pub fn tokenize(\u0026mut self) -\u003e Result\u003cVec\u003cToken\u003e\u003e {\n        // Pre-allocate based on source length (rough estimate: 1 token per 4 chars)\n        let estimated_tokens = self.source.len() / 4 + 1;\n        let mut tokens = Vec::with_capacity(estimated_tokens.min(1024));\n\n        loop {\n            let token = self.next_token()?;\n            let is_eof = matches!(token.kind, TokenKind::Eof);\n            tokens.push(token);\n            if is_eof {\n                break;\n            }\n        }\n        Ok(tokens)\n    }\n\n    /// Get the next token from the source\n    pub fn next_token(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        self.skip_whitespace_and_comments();\n\n        let (line, col) = (self.line, self.column);\n\n        let Some((_pos, ch)) = self.peek_char() else {\n            return Ok(Token::new(TokenKind::Eof, line, col));\n        };\n\n        let token = match ch {\n            // Newlines are significant in AWK\n            '\\n' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Newline, line, col)\n            }\n\n            // String literals\n            '\"' =\u003e self.scan_string()?,\n\n            // Regex or division - depends on context\n            '/' =\u003e {\n                if self.last_token_produces_value {\n                    self.advance();\n                    if self.peek_char_is('=') {\n                        self.advance();\n                        Token::new(TokenKind::SlashAssign, line, col)\n                    } else {\n                        Token::new(TokenKind::Slash, line, col)\n                    }\n                } else {\n                    self.scan_regex()?\n                }\n            }\n\n            // Numbers\n            '0'..='9' | '.' if ch == '.' \u0026\u0026 self.peek_next_is_digit() =\u003e self.scan_number()?,\n            '0'..='9' =\u003e self.scan_number()?,\n\n            // Identifiers and keywords\n            'a'..='z' | 'A'..='Z' | '_' =\u003e self.scan_identifier()?,\n\n            // Operators and delimiters\n            '+' =\u003e {\n                self.advance();\n                if self.peek_char_is('+') {\n                    self.advance();\n                    Token::new(TokenKind::Increment, line, col)\n                } else if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::PlusAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Plus, line, col)\n                }\n            }\n            '-' =\u003e {\n                self.advance();\n                if self.peek_char_is('-') {\n                    self.advance();\n                    Token::new(TokenKind::Decrement, line, col)\n                } else if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::MinusAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Minus, line, col)\n                }\n            }\n            '*' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::StarAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Star, line, col)\n                }\n            }\n            '%' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::PercentAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Percent, line, col)\n                }\n            }\n            '^' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::CaretAssign, line, col)\n                } else {\n                    Token::new(TokenKind::Caret, line, col)\n                }\n            }\n            '\u003c' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::LessEqual, line, col)\n                } else {\n                    Token::new(TokenKind::Less, line, col)\n                }\n            }\n            '\u003e' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::GreaterEqual, line, col)\n                } else if self.peek_char_is('\u003e') {\n                    self.advance();\n                    Token::new(TokenKind::Append, line, col)\n                } else {\n                    Token::new(TokenKind::Greater, line, col)\n                }\n            }\n            '=' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::Equal, line, col)\n                } else {\n                    Token::new(TokenKind::Assign, line, col)\n                }\n            }\n            '!' =\u003e {\n                self.advance();\n                if self.peek_char_is('=') {\n                    self.advance();\n                    Token::new(TokenKind::NotEqual, line, col)\n                } else if self.peek_char_is('~') {\n                    self.advance();\n                    Token::new(TokenKind::NotMatch, line, col)\n                } else {\n                    Token::new(TokenKind::Not, line, col)\n                }\n            }\n            '~' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Match, line, col)\n            }\n            '\u0026' =\u003e {\n                self.advance();\n                if self.peek_char_is('\u0026') {\n                    self.advance();\n                    Token::new(TokenKind::And, line, col)\n                } else {\n                    return Err(Error::lexer(\"unexpected '\u0026', did you mean '\u0026\u0026'?\", line, col));\n                }\n            }\n            '|' =\u003e {\n                self.advance();\n                if self.peek_char_is('|') {\n                    self.advance();\n                    Token::new(TokenKind::Or, line, col)\n                } else {\n                    Token::new(TokenKind::Pipe, line, col)\n                }\n            }\n            '$' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Dollar, line, col)\n            }\n            '?' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Question, line, col)\n            }\n            ':' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Colon, line, col)\n            }\n            '(' =\u003e {\n                self.advance();\n                Token::new(TokenKind::LeftParen, line, col)\n            }\n            ')' =\u003e {\n                self.advance();\n                Token::new(TokenKind::RightParen, line, col)\n            }\n            '{' =\u003e {\n                self.advance();\n                Token::new(TokenKind::LeftBrace, line, col)\n            }\n            '}' =\u003e {\n                self.advance();\n                Token::new(TokenKind::RightBrace, line, col)\n            }\n            '[' =\u003e {\n                self.advance();\n                Token::new(TokenKind::LeftBracket, line, col)\n            }\n            ']' =\u003e {\n                self.advance();\n                Token::new(TokenKind::RightBracket, line, col)\n            }\n            ';' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Semicolon, line, col)\n            }\n            ',' =\u003e {\n                self.advance();\n                Token::new(TokenKind::Comma, line, col)\n            }\n\n            _ =\u003e {\n                return Err(Error::lexer(\n                    format!(\"unexpected character '{}'\", ch),\n                    line,\n                    col,\n                ));\n            }\n        };\n\n        self.last_token_produces_value = token.kind.produces_value();\n        Ok(token)\n    }\n\n    fn peek_char(\u0026mut self) -\u003e Option\u003c(usize, char)\u003e {\n        self.chars.peek().copied()\n    }\n\n    fn peek_char_is(\u0026mut self, expected: char) -\u003e bool {\n        self.chars.peek().map(|(_, c)| *c == expected).unwrap_or(false)\n    }\n\n    fn peek_next_is_digit(\u0026self) -\u003e bool {\n        let mut chars = self.chars.clone();\n        chars.next(); // skip current\n        chars.next().map(|(_, c)| c.is_ascii_digit()).unwrap_or(false)\n    }\n\n    fn advance(\u0026mut self) -\u003e Option\u003c(usize, char)\u003e {\n        let result = self.chars.next();\n        if let Some((_, ch)) = result {\n            if ch == '\\n' {\n                self.line += 1;\n                self.column = 1;\n            } else {\n                self.column += 1;\n            }\n        }\n        result\n    }\n\n    fn skip_whitespace_and_comments(\u0026mut self) {\n        loop {\n            match self.peek_char() {\n                Some((_, ' ' | '\\t' | '\\r')) =\u003e {\n                    self.advance();\n                }\n                Some((_, '\\\\')) =\u003e {\n                    // Line continuation\n                    let mut chars = self.chars.clone();\n                    chars.next();\n                    if chars.peek().map(|(_, c)| *c == '\\n').unwrap_or(false) {\n                        self.advance(); // consume backslash\n                        self.advance(); // consume newline\n                    } else {\n                        break;\n                    }\n                }\n                Some((_, '#')) =\u003e {\n                    // Comment - skip to end of line\n                    while let Some((_, ch)) = self.peek_char() {\n                        if ch == '\\n' {\n                            break;\n                        }\n                        self.advance();\n                    }\n                }\n                _ =\u003e break,\n            }\n        }\n    }\n\n    fn scan_string(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let (line, col) = (self.line, self.column);\n        self.advance(); // consume opening quote\n\n        let mut value = String::new();\n\n        loop {\n            match self.advance() {\n                Some((_, '\"')) =\u003e break,\n                Some((_, '\\\\')) =\u003e {\n                    // Escape sequence\n                    match self.peek_char() {\n                        Some((_, 'n')) =\u003e { self.advance(); value.push('\\n'); }\n                        Some((_, 't')) =\u003e { self.advance(); value.push('\\t'); }\n                        Some((_, 'r')) =\u003e { self.advance(); value.push('\\r'); }\n                        Some((_, 'b')) =\u003e { self.advance(); value.push('\\x08'); }\n                        Some((_, 'f')) =\u003e { self.advance(); value.push('\\x0C'); }\n                        Some((_, 'a')) =\u003e { self.advance(); value.push('\\x07'); }\n                        Some((_, 'v')) =\u003e { self.advance(); value.push('\\x0B'); }\n                        Some((_, '\\\\')) =\u003e { self.advance(); value.push('\\\\'); }\n                        Some((_, '\"')) =\u003e { self.advance(); value.push('\"'); }\n                        Some((_, '/')) =\u003e { self.advance(); value.push('/'); }\n                        Some((_, 'x')) =\u003e {\n                            // Hex escape: \\xNN\n                            self.advance(); // consume 'x'\n                            let hex = self.read_hex_digits(2);\n                            if let Some(ch) = u8::from_str_radix(\u0026hex, 16).ok().map(|b| b as char) {\n                                value.push(ch);\n                            } else {\n                                value.push_str(\"\\\\x\");\n                                value.push_str(\u0026hex);\n                            }\n                        }\n                        Some((_, c)) if c.is_ascii_digit() \u0026\u0026 c != '8' \u0026\u0026 c != '9' =\u003e {\n                            // Octal escape: \\NNN (1-3 octal digits)\n                            let octal = self.read_octal_digits(3);\n                            if let Some(ch) = u8::from_str_radix(\u0026octal, 8).ok().map(|b| b as char) {\n                                value.push(ch);\n                            } else {\n                                value.push('\\\\');\n                                value.push_str(\u0026octal);\n                            }\n                        }\n                        Some((_, c)) =\u003e {\n                            // Unknown escape, just use the character\n                            self.advance();\n                            value.push(c);\n                        }\n                        None =\u003e {\n                            return Err(Error::lexer(\"unterminated string\", line, col));\n                        }\n                    }\n                }\n                Some((_, '\\n')) =\u003e {\n                    return Err(Error::lexer(\"unterminated string (newline in string)\", line, col));\n                }\n                Some((_, ch)) =\u003e value.push(ch),\n                None =\u003e {\n                    return Err(Error::lexer(\"unterminated string\", line, col));\n                }\n            }\n        }\n\n        Ok(Token::new(TokenKind::String(value), line, col))\n    }\n\n    fn read_hex_digits(\u0026mut self, max_count: usize) -\u003e String {\n        let mut result = String::new();\n        for _ in 0..max_count {\n            match self.peek_char() {\n                Some((_, c)) if c.is_ascii_hexdigit() =\u003e {\n                    self.advance();\n                    result.push(c);\n                }\n                _ =\u003e break,\n            }\n        }\n        result\n    }\n\n    fn read_octal_digits(\u0026mut self, max_count: usize) -\u003e String {\n        let mut result = String::new();\n        for _ in 0..max_count {\n            match self.peek_char() {\n                Some((_, c)) if c \u003e= '0' \u0026\u0026 c \u003c= '7' =\u003e {\n                    self.advance();\n                    result.push(c);\n                }\n                _ =\u003e break,\n            }\n        }\n        result\n    }\n\n    fn scan_regex(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let (line, col) = (self.line, self.column);\n        self.advance(); // consume opening slash\n\n        let mut pattern = String::new();\n\n        loop {\n            match self.advance() {\n                Some((_, '/')) =\u003e break,\n                Some((_, '\\\\')) =\u003e {\n                    // Escape next character in regex\n                    pattern.push('\\\\');\n                    if let Some((_, ch)) = self.advance() {\n                        pattern.push(ch);\n                    } else {\n                        return Err(Error::lexer(\"unterminated regex\", line, col));\n                    }\n                }\n                Some((_, '\\n')) =\u003e {\n                    return Err(Error::lexer(\"unterminated regex (newline in regex)\", line, col));\n                }\n                Some((_, ch)) =\u003e pattern.push(ch),\n                None =\u003e {\n                    return Err(Error::lexer(\"unterminated regex\", line, col));\n                }\n            }\n        }\n\n        Ok(Token::new(TokenKind::Regex(pattern), line, col))\n    }\n\n    fn scan_number(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let (line, col) = (self.line, self.column);\n        let start_pos = self.chars.peek().map(|(pos, _)| *pos).unwrap_or(0);\n        let mut end_pos = start_pos;\n\n        // Integer part\n        while let Some((pos, ch)) = self.peek_char() {\n            if ch.is_ascii_digit() {\n                end_pos = pos + 1;\n                self.advance();\n            } else {\n                break;\n            }\n        }\n\n        // Decimal part\n        if self.peek_char_is('.') {\n            self.advance();\n            end_pos += 1;\n\n            while let Some((pos, ch)) = self.peek_char() {\n                if ch.is_ascii_digit() {\n                    end_pos = pos + 1;\n                    self.advance();\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // Exponent part\n        if let Some((_, 'e' | 'E')) = self.peek_char() {\n            self.advance();\n            end_pos += 1;\n\n            if let Some((_, '+' | '-')) = self.peek_char() {\n                self.advance();\n                end_pos += 1;\n            }\n\n            while let Some((pos, ch)) = self.peek_char() {\n                if ch.is_ascii_digit() {\n                    end_pos = pos + 1;\n                    self.advance();\n                } else {\n                    break;\n                }\n            }\n        }\n\n        let number_str = \u0026self.source[start_pos..end_pos];\n        let value: f64 = number_str\n            .parse()\n            .map_err(|_| Error::lexer(format!(\"invalid number '{}'\", number_str), line, col))?;\n\n        Ok(Token::new(TokenKind::Number(value), line, col))\n    }\n\n    fn scan_identifier(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let (line, col) = (self.line, self.column);\n        let start_pos = self.chars.peek().map(|(pos, _)| *pos).unwrap_or(0);\n        let mut end_pos = start_pos;\n\n        while let Some((pos, ch)) = self.peek_char() {\n            if ch.is_ascii_alphanumeric() || ch == '_' {\n                end_pos = pos + 1;\n                self.advance();\n            } else {\n                break;\n            }\n        }\n\n        let ident = \u0026self.source[start_pos..end_pos];\n\n        // Check if it's a keyword\n        let kind = keyword_to_token(ident).unwrap_or_else(|| TokenKind::Identifier(ident.to_string()));\n\n        Ok(Token::new(kind, line, col))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_tokens() {\n        // Test operators in context where / is division (after identifier)\n        let mut lexer = Lexer::new(\"x + y - z * w / v % u\");\n        let tokens = lexer.tokenize().unwrap();\n\n        assert!(matches!(tokens[1].kind, TokenKind::Plus));\n        assert!(matches!(tokens[3].kind, TokenKind::Minus));\n        assert!(matches!(tokens[5].kind, TokenKind::Star));\n        assert!(matches!(tokens[7].kind, TokenKind::Slash));\n        assert!(matches!(tokens[9].kind, TokenKind::Percent));\n    }\n\n    #[test]\n    fn test_keywords() {\n        let mut lexer = Lexer::new(\"BEGIN END if else while for print\");\n        let tokens = lexer.tokenize().unwrap();\n\n        assert!(matches!(tokens[0].kind, TokenKind::Begin));\n        assert!(matches!(tokens[1].kind, TokenKind::End));\n        assert!(matches!(tokens[2].kind, TokenKind::If));\n        assert!(matches!(tokens[3].kind, TokenKind::Else));\n        assert!(matches!(tokens[4].kind, TokenKind::While));\n        assert!(matches!(tokens[5].kind, TokenKind::For));\n        assert!(matches!(tokens[6].kind, TokenKind::Print));\n    }\n\n    #[test]\n    fn test_numbers() {\n        let mut lexer = Lexer::new(\"42 3.14 1e10 2.5e-3\");\n        let tokens = lexer.tokenize().unwrap();\n\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if n == 42.0));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if (n - 3.14).abs() \u003c 0.001));\n        assert!(matches!(tokens[2].kind, TokenKind::Number(n) if n == 1e10));\n        assert!(matches!(tokens[3].kind, TokenKind::Number(n) if (n - 2.5e-3).abs() \u003c 0.0001));\n    }\n\n    #[test]\n    fn test_strings() {\n        let mut lexer = Lexer::new(r#\"\"hello\" \"world\\n\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::String(s) if s == \"hello\"));\n        assert!(matches!(\u0026tokens[1].kind, TokenKind::String(s) if s == \"world\\n\"));\n    }\n\n    #[test]\n    fn test_regex_vs_division() {\n        // After identifier, / is division\n        let mut lexer = Lexer::new(\"x / 2\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Slash));\n\n        // At start, / begins a regex\n        let mut lexer = Lexer::new(\"/pattern/\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Regex(s) if s == \"pattern\"));\n    }\n\n    #[test]\n    fn test_line_tracking() {\n        let mut lexer = Lexer::new(\"a\\nb\\nc\");\n        let tokens = lexer.tokenize().unwrap();\n\n        assert_eq!(tokens[0].location.line, 1);\n        assert_eq!(tokens[2].location.line, 2);\n        assert_eq!(tokens[4].location.line, 3);\n    }\n\n    #[test]\n    fn test_comparison_operators() {\n        let mut lexer = Lexer::new(\"\u003c \u003c= \u003e \u003e= == !=\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Less));\n        assert!(matches!(tokens[1].kind, TokenKind::LessEqual));\n        assert!(matches!(tokens[2].kind, TokenKind::Greater));\n        assert!(matches!(tokens[3].kind, TokenKind::GreaterEqual));\n        assert!(matches!(tokens[4].kind, TokenKind::Equal));\n        assert!(matches!(tokens[5].kind, TokenKind::NotEqual));\n    }\n\n    #[test]\n    fn test_logical_operators() {\n        let mut lexer = Lexer::new(\"\u0026\u0026 || !\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::And));\n        assert!(matches!(tokens[1].kind, TokenKind::Or));\n        assert!(matches!(tokens[2].kind, TokenKind::Not));\n    }\n\n    #[test]\n    fn test_regex_match_operators() {\n        let mut lexer = Lexer::new(\"x ~ y x !~ y\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Match));\n        assert!(matches!(tokens[4].kind, TokenKind::NotMatch));\n    }\n\n    #[test]\n    fn test_assignment_operators() {\n        // Put value-producing tokens before /= to avoid regex interpretation\n        let mut lexer = Lexer::new(\"x = 1 x += 1 x -= 1 x *= 1 x /= 1 x %= 1 x ^= 1\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Assign));\n        assert!(matches!(tokens[4].kind, TokenKind::PlusAssign));\n        assert!(matches!(tokens[7].kind, TokenKind::MinusAssign));\n        assert!(matches!(tokens[10].kind, TokenKind::StarAssign));\n        assert!(matches!(tokens[13].kind, TokenKind::SlashAssign));\n        assert!(matches!(tokens[16].kind, TokenKind::PercentAssign));\n        assert!(matches!(tokens[19].kind, TokenKind::CaretAssign));\n    }\n\n    #[test]\n    fn test_increment_decrement() {\n        let mut lexer = Lexer::new(\"++ --\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Increment));\n        assert!(matches!(tokens[1].kind, TokenKind::Decrement));\n    }\n\n    #[test]\n    fn test_delimiters() {\n        let mut lexer = Lexer::new(\"( ) { } [ ] ; ,\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::LeftParen));\n        assert!(matches!(tokens[1].kind, TokenKind::RightParen));\n        assert!(matches!(tokens[2].kind, TokenKind::LeftBrace));\n        assert!(matches!(tokens[3].kind, TokenKind::RightBrace));\n        assert!(matches!(tokens[4].kind, TokenKind::LeftBracket));\n        assert!(matches!(tokens[5].kind, TokenKind::RightBracket));\n        assert!(matches!(tokens[6].kind, TokenKind::Semicolon));\n        assert!(matches!(tokens[7].kind, TokenKind::Comma));\n    }\n\n    #[test]\n    fn test_special_operators() {\n        let mut lexer = Lexer::new(\"$ ? : | \u003e\u003e\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Dollar));\n        assert!(matches!(tokens[1].kind, TokenKind::Question));\n        assert!(matches!(tokens[2].kind, TokenKind::Colon));\n        assert!(matches!(tokens[3].kind, TokenKind::Pipe));\n        assert!(matches!(tokens[4].kind, TokenKind::Append));\n    }\n\n    #[test]\n    fn test_exponent() {\n        let mut lexer = Lexer::new(\"x ^ 2\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Caret));\n    }\n\n    #[test]\n    fn test_comments() {\n        let mut lexer = Lexer::new(\"x # this is a comment\\ny\");\n        let tokens = lexer.tokenize().unwrap();\n        // Comment should be skipped\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Identifier(s) if s == \"x\"));\n        assert!(matches!(tokens[1].kind, TokenKind::Newline));\n        assert!(matches!(\u0026tokens[2].kind, TokenKind::Identifier(s) if s == \"y\"));\n    }\n\n    #[test]\n    fn test_line_continuation() {\n        let mut lexer = Lexer::new(\"x \\\\\\ny\");\n        let tokens = lexer.tokenize().unwrap();\n        // Backslash-newline should be skipped\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Identifier(s) if s == \"x\"));\n        assert!(matches!(\u0026tokens[1].kind, TokenKind::Identifier(s) if s == \"y\"));\n    }\n\n    #[test]\n    fn test_string_escapes() {\n        let mut lexer = Lexer::new(r#\"\"\\t\\r\\n\\b\\f\\a\\v\\\\\\\"\\/\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert!(s.contains('\\t'));\n            assert!(s.contains('\\r'));\n            assert!(s.contains('\\n'));\n            assert!(s.contains('\\\\'));\n            assert!(s.contains('\"'));\n            assert!(s.contains('/'));\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_hex_escape() {\n        let mut lexer = Lexer::new(r#\"\"\\x41\\x42\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert_eq!(s, \"AB\");\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_octal_escape() {\n        let mut lexer = Lexer::new(r#\"\"\\101\\102\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert_eq!(s, \"AB\");\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_regex_with_escapes() {\n        let mut lexer = Lexer::new(r#\"/a\\/b/\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::Regex(s) = \u0026tokens[0].kind {\n            assert!(s.contains(\"\\\\/\"));\n        } else {\n            panic!(\"Expected regex token\");\n        }\n    }\n\n    #[test]\n    fn test_more_keywords() {\n        let mut lexer = Lexer::new(\"do break continue function return delete exit next nextfile getline printf in BEGINFILE ENDFILE\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Do));\n        assert!(matches!(tokens[1].kind, TokenKind::Break));\n        assert!(matches!(tokens[2].kind, TokenKind::Continue));\n        assert!(matches!(tokens[3].kind, TokenKind::Function));\n        assert!(matches!(tokens[4].kind, TokenKind::Return));\n        assert!(matches!(tokens[5].kind, TokenKind::Delete));\n        assert!(matches!(tokens[6].kind, TokenKind::Exit));\n        assert!(matches!(tokens[7].kind, TokenKind::Next));\n        assert!(matches!(tokens[8].kind, TokenKind::Nextfile));\n        assert!(matches!(tokens[9].kind, TokenKind::Getline));\n        assert!(matches!(tokens[10].kind, TokenKind::Printf));\n        assert!(matches!(tokens[11].kind, TokenKind::In));\n        assert!(matches!(tokens[12].kind, TokenKind::BeginFile));\n        assert!(matches!(tokens[13].kind, TokenKind::EndFile));\n    }\n\n    #[test]\n    fn test_number_with_exponent() {\n        let mut lexer = Lexer::new(\"1e+5 1E-5\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if n == 1e5));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if n == 1e-5));\n    }\n\n    #[test]\n    fn test_decimal_starting_with_dot() {\n        let mut lexer = Lexer::new(\".5 .123\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if (n - 0.5).abs() \u003c 0.001));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if (n - 0.123).abs() \u003c 0.001));\n    }\n\n    #[test]\n    fn test_unexpected_character_error() {\n        let mut lexer = Lexer::new(\"@\");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_unterminated_string_error() {\n        let mut lexer = Lexer::new(\"\\\"unterminated\");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_unterminated_regex_error() {\n        let mut lexer = Lexer::new(\"/unterminated\");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_string_with_newline_error() {\n        let mut lexer = Lexer::new(\"\\\"hello\\nworld\\\"\");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_single_ampersand_error() {\n        let mut lexer = Lexer::new(\"\u0026 \");\n        let result = lexer.tokenize();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_eof_token() {\n        let mut lexer = Lexer::new(\"\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Eof));\n    }\n\n    #[test]\n    fn test_regex_with_escapes_complete() {\n        let mut lexer = Lexer::new(r#\"/\\d+\\.\\d*/\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::Regex(s) = \u0026tokens[0].kind {\n            assert!(s.contains(r\"\\d\"));\n        } else {\n            panic!(\"Expected regex token\");\n        }\n    }\n\n    #[test]\n    fn test_string_unknown_escape() {\n        // Unknown escape sequences should just use the character\n        let mut lexer = Lexer::new(r#\"\"\\q\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert_eq!(s, \"q\");\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_number_leading_dot() {\n        let mut lexer = Lexer::new(\".123 .5e2\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if (n - 0.123).abs() \u003c 0.001));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if n == 50.0));\n    }\n\n    #[test]\n    fn test_number_exponent_variations() {\n        let mut lexer = Lexer::new(\"1e5 1E5 1e+5 1e-5 1.5e10\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[0].kind, TokenKind::Number(n) if n == 1e5));\n        assert!(matches!(tokens[1].kind, TokenKind::Number(n) if n == 1e5));\n        assert!(matches!(tokens[2].kind, TokenKind::Number(n) if n == 1e5));\n        assert!(matches!(tokens[3].kind, TokenKind::Number(n) if n == 1e-5));\n        assert!(matches!(tokens[4].kind, TokenKind::Number(n) if n == 1.5e10));\n    }\n\n    #[test]\n    fn test_regex_after_comma() {\n        // After comma, / should be regex\n        let mut lexer = Lexer::new(\"gsub(/a/, /b/)\");\n        let tokens = lexer.tokenize().unwrap();\n        // gsub ( /a/ , /b/ )\n        assert!(matches!(\u0026tokens[2].kind, TokenKind::Regex(s) if s == \"a\"));\n        assert!(matches!(\u0026tokens[4].kind, TokenKind::Regex(s) if s == \"b\"));\n    }\n\n    #[test]\n    fn test_regex_after_operators() {\n        // After various operators, / should be regex\n        let mut lexer = Lexer::new(\"x ~ /a/ \u0026\u0026 /b/\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(\u0026tokens[2].kind, TokenKind::Regex(s) if s == \"a\"));\n        assert!(matches!(\u0026tokens[4].kind, TokenKind::Regex(s) if s == \"b\"));\n    }\n\n    #[test]\n    fn test_multiple_newlines() {\n        let mut lexer = Lexer::new(\"a\\n\\n\\nb\");\n        let tokens = lexer.tokenize().unwrap();\n        // Should have multiple newline tokens\n        let newline_count = tokens.iter().filter(|t| matches!(t.kind, TokenKind::Newline)).count();\n        assert!(newline_count \u003e= 2);\n    }\n\n    #[test]\n    fn test_comment_at_end() {\n        let mut lexer = Lexer::new(\"x # comment at end\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Identifier(s) if s == \"x\"));\n        assert!(matches!(tokens[1].kind, TokenKind::Eof));\n    }\n\n    #[test]\n    fn test_identifier_with_underscore() {\n        let mut lexer = Lexer::new(\"_var var_name my_func_2\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(\u0026tokens[0].kind, TokenKind::Identifier(s) if s == \"_var\"));\n        assert!(matches!(\u0026tokens[1].kind, TokenKind::Identifier(s) if s == \"var_name\"));\n        assert!(matches!(\u0026tokens[2].kind, TokenKind::Identifier(s) if s == \"my_func_2\"));\n    }\n\n    #[test]\n    fn test_string_with_all_escapes() {\n        let mut lexer = Lexer::new(r#\"\"\\b\\f\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            assert!(s.contains('\\x08'));  // backspace\n            assert!(s.contains('\\x0C'));  // form feed\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_invalid_hex_escape() {\n        // Invalid hex should fall back gracefully\n        let mut lexer = Lexer::new(r#\"\"\\xGG\"\"#);\n        let tokens = lexer.tokenize().unwrap();\n        if let TokenKind::String(s) = \u0026tokens[0].kind {\n            // Should contain x since the hex parse failed\n            assert!(s.contains(\"GG\") || s.contains(\"x\"));\n        } else {\n            panic!(\"Expected string token\");\n        }\n    }\n\n    #[test]\n    fn test_single_pipe() {\n        let mut lexer = Lexer::new(\"a | b\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Pipe));\n    }\n\n    #[test]\n    fn test_double_pipe() {\n        let mut lexer = Lexer::new(\"a || b\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Or));\n    }\n\n    #[test]\n    fn test_colon() {\n        let mut lexer = Lexer::new(\"a ? b : c\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Question));\n        assert!(matches!(tokens[3].kind, TokenKind::Colon));\n    }\n\n    #[test]\n    fn test_caret() {\n        let mut lexer = Lexer::new(\"x ^ 2 x ^= 3\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::Caret));\n        assert!(matches!(tokens[4].kind, TokenKind::CaretAssign));\n    }\n\n    #[test]\n    fn test_all_assignment_types() {\n        let mut lexer = Lexer::new(\"a += 1 b -= 1 c *= 1 d %= 1\");\n        let tokens = lexer.tokenize().unwrap();\n        assert!(matches!(tokens[1].kind, TokenKind::PlusAssign));\n        assert!(matches!(tokens[4].kind, TokenKind::MinusAssign));\n        assert!(matches!(tokens[7].kind, TokenKind::StarAssign));\n        assert!(matches!(tokens[10].kind, TokenKind::PercentAssign));\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":72}},{"line":20,"address":[],"length":0,"stats":{"Line":42}},{"line":28,"address":[2186867,2186893,2186208],"length":1,"stats":{"Line":72}},{"line":30,"address":[2999022,2999106],"length":1,"stats":{"Line":42}},{"line":31,"address":[2987815],"length":1,"stats":{"Line":72}},{"line":33,"address":[2186739],"length":1,"stats":{"Line":9}},{"line":34,"address":[2186347,2186404],"length":1,"stats":{"Line":51}},{"line":35,"address":[2186589],"length":1,"stats":{"Line":39}},{"line":36,"address":[2999414],"length":1,"stats":{"Line":9}},{"line":37,"address":[2988266],"length":1,"stats":{"Line":39}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[2999562],"length":1,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":72}},{"line":46,"address":[2174918],"length":1,"stats":{"Line":42}},{"line":48,"address":[2976288],"length":1,"stats":{"Line":79}},{"line":50,"address":[],"length":0,"stats":{"Line":49}},{"line":51,"address":[2976455],"length":1,"stats":{"Line":3}},{"line":54,"address":[2987666],"length":1,"stats":{"Line":79}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[2987813],"length":1,"stats":{"Line":2}},{"line":58,"address":[3262212],"length":1,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":7}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":67,"address":[2978102],"length":1,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[2978308],"length":1,"stats":{"Line":2}},{"line":70,"address":[3263971],"length":1,"stats":{"Line":2}},{"line":72,"address":[3263912],"length":1,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[2179012,2175160,2179083,2175323,2176982,2177217,2178803],"length":1,"stats":{"Line":113}},{"line":81,"address":[2980444,2980620],"length":1,"stats":{"Line":3}},{"line":84,"address":[2976710,2980245,2980200],"length":1,"stats":{"Line":141}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[2976783],"length":1,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[2978795],"length":1,"stats":{"Line":4}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[2976811],"length":1,"stats":{"Line":3}},{"line":101,"address":[2175457],"length":1,"stats":{"Line":3}},{"line":102,"address":[3264523],"length":1,"stats":{"Line":2}},{"line":103,"address":[2177500],"length":1,"stats":{"Line":2}},{"line":104,"address":[2177464],"length":1,"stats":{"Line":3}},{"line":105,"address":[2978983],"length":1,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[3264587],"length":1,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[3262497],"length":1,"stats":{"Line":3}},{"line":113,"address":[3262507],"length":1,"stats":{"Line":3}},{"line":114,"address":[2979091],"length":1,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[3262535],"length":1,"stats":{"Line":3}},{"line":122,"address":[2988161],"length":1,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[2979214],"length":1,"stats":{"Line":2}},{"line":126,"address":[2979155],"length":1,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[2175561],"length":1,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[2177909],"length":1,"stats":{"Line":2}},{"line":133,"address":[3264970],"length":1,"stats":{"Line":2}},{"line":135,"address":[2177866],"length":1,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[2976973],"length":1,"stats":{"Line":8}},{"line":141,"address":[3265063],"length":1,"stats":{"Line":9}},{"line":142,"address":[2979430],"length":1,"stats":{"Line":9}},{"line":144,"address":[2177972],"length":1,"stats":{"Line":5}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[2988265],"length":1,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[2178094],"length":1,"stats":{"Line":2}},{"line":151,"address":[2178109],"length":1,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[3265251],"length":1,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[3265207],"length":1,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[3262687],"length":1,"stats":{"Line":23}},{"line":161,"address":[],"length":0,"stats":{"Line":23}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[2178321],"length":1,"stats":{"Line":4}},{"line":165,"address":[2990931],"length":1,"stats":{"Line":22}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[3262725],"length":1,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[2991055],"length":1,"stats":{"Line":2}},{"line":172,"address":[2979806],"length":1,"stats":{"Line":2}},{"line":173,"address":[3265418],"length":1,"stats":{"Line":2}},{"line":174,"address":[3265547],"length":1,"stats":{"Line":3}},{"line":175,"address":[3265562],"length":1,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[2175751],"length":1,"stats":{"Line":5}},{"line":182,"address":[2988394],"length":1,"stats":{"Line":5}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[2977174],"length":1,"stats":{"Line":2}},{"line":186,"address":[2175819],"length":1,"stats":{"Line":2}},{"line":187,"address":[2980038],"length":1,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[2991227],"length":1,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[2988476],"length":1,"stats":{"Line":2}},{"line":195,"address":[2175857],"length":1,"stats":{"Line":2}},{"line":196,"address":[2991410],"length":1,"stats":{"Line":2}},{"line":197,"address":[2991425],"length":1,"stats":{"Line":2}},{"line":199,"address":[2178691],"length":1,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[2977250],"length":1,"stats":{"Line":3}},{"line":204,"address":[3262913],"length":1,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[3262957],"length":1,"stats":{"Line":4}},{"line":208,"address":[3262972],"length":1,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[3263016],"length":1,"stats":{"Line":4}},{"line":212,"address":[2977383],"length":1,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[2176059],"length":1,"stats":{"Line":7}},{"line":216,"address":[],"length":0,"stats":{"Line":7}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[2977486],"length":1,"stats":{"Line":3}},{"line":220,"address":[2176132],"length":1,"stats":{"Line":13}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[2977545],"length":1,"stats":{"Line":8}},{"line":224,"address":[2977560],"length":1,"stats":{"Line":8}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[2977604],"length":1,"stats":{"Line":3}},{"line":228,"address":[2977619],"length":1,"stats":{"Line":5}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[2176291],"length":1,"stats":{"Line":19}},{"line":232,"address":[2977678],"length":1,"stats":{"Line":19}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[3263370],"length":1,"stats":{"Line":13}},{"line":236,"address":[2176364],"length":1,"stats":{"Line":13}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[3263426],"length":1,"stats":{"Line":5}},{"line":240,"address":[],"length":0,"stats":{"Line":8}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":6}},{"line":244,"address":[3263497],"length":1,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[2989644],"length":1,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[2179371,2176515],"length":1,"stats":{"Line":17}},{"line":257,"address":[2992062],"length":1,"stats":{"Line":39}},{"line":260,"address":[3274112],"length":1,"stats":{"Line":72}},{"line":261,"address":[2999733],"length":1,"stats":{"Line":42}},{"line":264,"address":[2996816],"length":1,"stats":{"Line":4}},{"line":265,"address":[2717552,2717562],"length":1,"stats":{"Line":14}},{"line":268,"address":[2185456],"length":1,"stats":{"Line":1}},{"line":269,"address":[2185468],"length":1,"stats":{"Line":1}},{"line":270,"address":[2185482],"length":1,"stats":{"Line":1}},{"line":271,"address":[3272646],"length":1,"stats":{"Line":3}},{"line":274,"address":[2186000],"length":1,"stats":{"Line":10}},{"line":275,"address":[2998782],"length":1,"stats":{"Line":10}},{"line":276,"address":[2186032],"length":1,"stats":{"Line":10}},{"line":277,"address":[2186067,2186165,2186193],"length":1,"stats":{"Line":50}},{"line":278,"address":[2186093,2186167,2186153],"length":1,"stats":{"Line":4}},{"line":279,"address":[2987662],"length":1,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":20}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[2987040],"length":1,"stats":{"Line":72}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[3272707],"length":1,"stats":{"Line":42}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":65}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[3272829],"length":1,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":3}},{"line":298,"address":[2185792],"length":1,"stats":{"Line":1}},{"line":299,"address":[3272958],"length":1,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[2998513,2998584],"length":1,"stats":{"Line":5}},{"line":307,"address":[2987328],"length":1,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[2987342],"length":1,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[2184031,2181760,2183518],"length":1,"stats":{"Line":6}},{"line":319,"address":[2181810],"length":1,"stats":{"Line":6}},{"line":320,"address":[2994578],"length":1,"stats":{"Line":7}},{"line":322,"address":[2181863],"length":1,"stats":{"Line":17}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[2983426,2983348],"length":1,"stats":{"Line":35}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[2182354,2182494],"length":1,"stats":{"Line":8}},{"line":330,"address":[],"length":0,"stats":{"Line":6}},{"line":331,"address":[2984208,2984418],"length":1,"stats":{"Line":2}},{"line":332,"address":[2995707,2995490],"length":1,"stats":{"Line":2}},{"line":333,"address":[3269892,3270116],"length":1,"stats":{"Line":2}},{"line":334,"address":[3270141,3269910],"length":1,"stats":{"Line":2}},{"line":335,"address":[2995782,2995544],"length":1,"stats":{"Line":2}},{"line":336,"address":[2995807,2995562],"length":1,"stats":{"Line":2}},{"line":337,"address":[2183096,2182844],"length":1,"stats":{"Line":2}},{"line":338,"address":[2995598,2995857],"length":1,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":2}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[3270018],"length":1,"stats":{"Line":3}},{"line":343,"address":[2984651],"length":1,"stats":{"Line":4}},{"line":344,"address":[2183194,2183270],"length":1,"stats":{"Line":12}},{"line":345,"address":[2996186,2996152],"length":1,"stats":{"Line":7}},{"line":347,"address":[2984895],"length":1,"stats":{"Line":1}},{"line":348,"address":[2996218],"length":1,"stats":{"Line":1}},{"line":351,"address":[2182675,2183528,2183572],"length":1,"stats":{"Line":9}},{"line":353,"address":[3270750],"length":1,"stats":{"Line":3}},{"line":354,"address":[2705408,2705415],"length":1,"stats":{"Line":12}},{"line":355,"address":[2183902,2183875],"length":1,"stats":{"Line":6}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[2183934],"length":1,"stats":{"Line":0}},{"line":361,"address":[2183542],"length":1,"stats":{"Line":1}},{"line":363,"address":[2183560],"length":1,"stats":{"Line":1}},{"line":364,"address":[3270769],"length":1,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[3269714],"length":1,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[2183984,2182386],"length":1,"stats":{"Line":2}},{"line":374,"address":[2985514,2983651],"length":1,"stats":{"Line":64}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[2994812],"length":1,"stats":{"Line":1}},{"line":381,"address":[2182424,2182239],"length":1,"stats":{"Line":50}},{"line":384,"address":[2184519,2184513,2184128],"length":1,"stats":{"Line":4}},{"line":385,"address":[2184176],"length":1,"stats":{"Line":3}},{"line":386,"address":[3271398,3271322],"length":1,"stats":{"Line":6}},{"line":387,"address":[2184380,2184311],"length":1,"stats":{"Line":6}},{"line":388,"address":[2985910],"length":1,"stats":{"Line":3}},{"line":389,"address":[2985973],"length":1,"stats":{"Line":3}},{"line":390,"address":[],"length":0,"stats":{"Line":3}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[2985825],"length":1,"stats":{"Line":3}},{"line":398,"address":[2998196,2998202,2997792],"length":1,"stats":{"Line":3}},{"line":399,"address":[2986576],"length":1,"stats":{"Line":3}},{"line":400,"address":[],"length":0,"stats":{"Line":6}},{"line":401,"address":[2185210,2185279],"length":1,"stats":{"Line":6}},{"line":402,"address":[2185324],"length":1,"stats":{"Line":3}},{"line":403,"address":[2185400],"length":1,"stats":{"Line":3}},{"line":404,"address":[2185416],"length":1,"stats":{"Line":3}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":3}},{"line":412,"address":[2993013,2993042,2992160],"length":1,"stats":{"Line":5}},{"line":413,"address":[2992198],"length":1,"stats":{"Line":5}},{"line":414,"address":[2992240],"length":1,"stats":{"Line":6}},{"line":416,"address":[],"length":0,"stats":{"Line":4}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[2992334,2992268],"length":1,"stats":{"Line":14}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[2179978],"length":1,"stats":{"Line":2}},{"line":424,"address":[3267174],"length":1,"stats":{"Line":2}},{"line":425,"address":[2981651,2981603],"length":1,"stats":{"Line":4}},{"line":427,"address":[3267309,3267268],"length":1,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[2992969,2992691],"length":1,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":14}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[3266813],"length":1,"stats":{"Line":1}},{"line":440,"address":[2981466,2981295],"length":1,"stats":{"Line":10}},{"line":443,"address":[3267440],"length":1,"stats":{"Line":3}},{"line":444,"address":[2993094],"length":1,"stats":{"Line":3}},{"line":445,"address":[2665989,2665984],"length":1,"stats":{"Line":9}},{"line":446,"address":[2180454],"length":1,"stats":{"Line":4}},{"line":449,"address":[],"length":0,"stats":{"Line":3}},{"line":450,"address":[2981994],"length":1,"stats":{"Line":4}},{"line":451,"address":[3267734,3267689],"length":1,"stats":{"Line":4}},{"line":452,"address":[3267724],"length":1,"stats":{"Line":4}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[2982016],"length":1,"stats":{"Line":4}},{"line":460,"address":[2993432],"length":1,"stats":{"Line":3}},{"line":461,"address":[3267821,3267861],"length":1,"stats":{"Line":3}},{"line":463,"address":[2180789,2180769],"length":1,"stats":{"Line":6}},{"line":464,"address":[],"length":0,"stats":{"Line":3}},{"line":465,"address":[3267995,3268040],"length":1,"stats":{"Line":3}},{"line":466,"address":[2993646],"length":1,"stats":{"Line":3}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[3268053,3267752],"length":1,"stats":{"Line":13}},{"line":475,"address":[2982646],"length":1,"stats":{"Line":5}},{"line":476,"address":[2982651,2982746],"length":1,"stats":{"Line":5}},{"line":478,"address":[2982759,2982694,2982896],"length":1,"stats":{"Line":11}},{"line":479,"address":[2181408],"length":1,"stats":{"Line":1}},{"line":480,"address":[3268506,3268546],"length":1,"stats":{"Line":1}},{"line":483,"address":[],"length":0,"stats":{"Line":8}},{"line":484,"address":[2994210],"length":1,"stats":{"Line":4}},{"line":485,"address":[2982973,2983016],"length":1,"stats":{"Line":5}},{"line":486,"address":[2994270],"length":1,"stats":{"Line":5}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[2993700],"length":1,"stats":{"Line":8}},{"line":494,"address":[],"length":0,"stats":{"Line":13}},{"line":496,"address":[2990864,2990832],"length":1,"stats":{"Line":24}},{"line":498,"address":[2181655],"length":1,"stats":{"Line":27}},{"line":501,"address":[],"length":0,"stats":{"Line":69}},{"line":502,"address":[3271718],"length":1,"stats":{"Line":42}},{"line":503,"address":[2666277,2666272],"length":1,"stats":{"Line":180}},{"line":504,"address":[],"length":0,"stats":{"Line":42}},{"line":506,"address":[2184672],"length":1,"stats":{"Line":69}},{"line":507,"address":[2986229,2986447],"length":1,"stats":{"Line":84}},{"line":508,"address":[2185010,2184970],"length":1,"stats":{"Line":69}},{"line":509,"address":[],"length":0,"stats":{"Line":42}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[2997526],"length":1,"stats":{"Line":69}},{"line":518,"address":[2184826],"length":1,"stats":{"Line":160}},{"line":520,"address":[2986376],"length":1,"stats":{"Line":39}}],"covered":251,"coverable":311},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","lexer","tokens.rs"],"content":"use crate::error::SourceLocation;\n\n/// All token types in AWK\n#[derive(Debug, Clone, PartialEq)]\npub enum TokenKind {\n    // Literals\n    Number(f64),\n    String(String),\n    Regex(String),\n\n    // Identifiers and keywords\n    Identifier(String),\n    Begin,\n    End,\n    BeginFile,  // gawk extension\n    EndFile,    // gawk extension\n    If,\n    Else,\n    While,\n    For,\n    Do,\n    Break,\n    Continue,\n    Function,\n    Return,\n    Delete,\n    Exit,\n    Next,\n    Nextfile,\n    Getline,\n    Print,\n    Printf,\n    In,\n\n    // Operators - Arithmetic\n    Plus,        // +\n    Minus,       // -\n    Star,        // *\n    Slash,       // /\n    Percent,     // %\n    Caret,       // ^\n\n    // Operators - Comparison\n    Less,        // \u003c\n    LessEqual,   // \u003c=\n    Greater,     // \u003e\n    GreaterEqual,// \u003e=\n    Equal,       // ==\n    NotEqual,    // !=\n\n    // Operators - Logical\n    And,         // \u0026\u0026\n    Or,          // ||\n    Not,         // !\n\n    // Operators - Regex\n    Match,       // ~\n    NotMatch,    // !~\n\n    // Operators - Assignment\n    Assign,      // =\n    PlusAssign,  // +=\n    MinusAssign, // -=\n    StarAssign,  // *=\n    SlashAssign, // /=\n    PercentAssign, // %=\n    CaretAssign, // ^=\n\n    // Operators - Increment/Decrement\n    Increment,   // ++\n    Decrement,   // --\n\n    // Special operators\n    Dollar,      // $ (field access)\n    Question,    // ?\n    Colon,       // :\n    Pipe,        // |\n    Append,      // \u003e\u003e\n\n    // Delimiters\n    LeftParen,   // (\n    RightParen,  // )\n    LeftBrace,   // {\n    RightBrace,  // }\n    LeftBracket, // [\n    RightBracket,// ]\n    Semicolon,   // ;\n    Comma,       // ,\n    Newline,     // \\n (significant in AWK)\n\n    // End of file\n    Eof,\n}\n\nimpl TokenKind {\n    /// Check if this token is a keyword\n    pub fn is_keyword(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            TokenKind::Begin\n                | TokenKind::End\n                | TokenKind::If\n                | TokenKind::Else\n                | TokenKind::While\n                | TokenKind::For\n                | TokenKind::Do\n                | TokenKind::Break\n                | TokenKind::Continue\n                | TokenKind::Function\n                | TokenKind::Return\n                | TokenKind::Delete\n                | TokenKind::Exit\n                | TokenKind::Next\n                | TokenKind::Nextfile\n                | TokenKind::Getline\n                | TokenKind::Print\n                | TokenKind::Printf\n                | TokenKind::In\n        )\n    }\n\n    /// Check if this token can start an expression\n    pub fn can_start_expression(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            TokenKind::Number(_)\n                | TokenKind::String(_)\n                | TokenKind::Regex(_)\n                | TokenKind::Identifier(_)\n                | TokenKind::LeftParen\n                | TokenKind::Dollar\n                | TokenKind::Not\n                | TokenKind::Plus\n                | TokenKind::Minus\n                | TokenKind::Increment\n                | TokenKind::Decrement\n                | TokenKind::Getline\n        )\n    }\n\n    /// Check if this token produces a value (for regex vs division disambiguation)\n    pub fn produces_value(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            TokenKind::Number(_)\n                | TokenKind::String(_)\n                | TokenKind::Identifier(_)\n                | TokenKind::RightParen\n                | TokenKind::RightBracket\n                | TokenKind::Increment\n                | TokenKind::Decrement\n        )\n    }\n}\n\n/// A token with its location in the source\n#[derive(Debug, Clone)]\npub struct Token {\n    pub kind: TokenKind,\n    pub location: SourceLocation,\n}\n\nimpl Token {\n    pub fn new(kind: TokenKind, line: usize, column: usize) -\u003e Self {\n        Self {\n            kind,\n            location: SourceLocation::new(line, column),\n        }\n    }\n}\n\n/// Map keyword strings to token kinds\npub fn keyword_to_token(s: \u0026str) -\u003e Option\u003cTokenKind\u003e {\n    match s {\n        \"BEGIN\" =\u003e Some(TokenKind::Begin),\n        \"END\" =\u003e Some(TokenKind::End),\n        \"BEGINFILE\" =\u003e Some(TokenKind::BeginFile),\n        \"ENDFILE\" =\u003e Some(TokenKind::EndFile),\n        \"if\" =\u003e Some(TokenKind::If),\n        \"else\" =\u003e Some(TokenKind::Else),\n        \"while\" =\u003e Some(TokenKind::While),\n        \"for\" =\u003e Some(TokenKind::For),\n        \"do\" =\u003e Some(TokenKind::Do),\n        \"break\" =\u003e Some(TokenKind::Break),\n        \"continue\" =\u003e Some(TokenKind::Continue),\n        \"function\" =\u003e Some(TokenKind::Function),\n        \"return\" =\u003e Some(TokenKind::Return),\n        \"delete\" =\u003e Some(TokenKind::Delete),\n        \"exit\" =\u003e Some(TokenKind::Exit),\n        \"next\" =\u003e Some(TokenKind::Next),\n        \"nextfile\" =\u003e Some(TokenKind::Nextfile),\n        \"getline\" =\u003e Some(TokenKind::Getline),\n        \"print\" =\u003e Some(TokenKind::Print),\n        \"printf\" =\u003e Some(TokenKind::Printf),\n        \"in\" =\u003e Some(TokenKind::In),\n        _ =\u003e None,\n    }\n}\n","traces":[{"line":97,"address":[2875712],"length":1,"stats":{"Line":0}},{"line":98,"address":[2875725],"length":1,"stats":{"Line":0}},{"line":99,"address":[2875717],"length":1,"stats":{"Line":0}},{"line":123,"address":[2887136],"length":1,"stats":{"Line":17}},{"line":124,"address":[2613501],"length":1,"stats":{"Line":17}},{"line":125,"address":[2875877],"length":1,"stats":{"Line":13}},{"line":142,"address":[2613392],"length":1,"stats":{"Line":36}},{"line":143,"address":[2613405],"length":1,"stats":{"Line":38}},{"line":144,"address":[2875781],"length":1,"stats":{"Line":8}},{"line":164,"address":[3161344,3161152,3161338],"length":1,"stats":{"Line":9}},{"line":167,"address":[2875569],"length":1,"stats":{"Line":10}},{"line":173,"address":[2610944],"length":1,"stats":{"Line":69}},{"line":175,"address":[2611062,2611003],"length":1,"stats":{"Line":106}},{"line":176,"address":[2873533,2873418],"length":1,"stats":{"Line":8}},{"line":177,"address":[2884884,2884769],"length":1,"stats":{"Line":8}},{"line":178,"address":[3159240,3159358],"length":1,"stats":{"Line":17}},{"line":179,"address":[2873682,2873812],"length":1,"stats":{"Line":69}},{"line":180,"address":[2885048,2885178],"length":1,"stats":{"Line":47}},{"line":181,"address":[2611502,2611632],"length":1,"stats":{"Line":68}},{"line":182,"address":[2611604,2611734],"length":1,"stats":{"Line":51}},{"line":183,"address":[2611706,2611836],"length":1,"stats":{"Line":62}},{"line":184,"address":[2874192,2874322],"length":1,"stats":{"Line":42}},{"line":185,"address":[2874294,2874424],"length":1,"stats":{"Line":64}},{"line":186,"address":[2885660,2885790],"length":1,"stats":{"Line":45}},{"line":187,"address":[2885762,2885892],"length":1,"stats":{"Line":65}},{"line":188,"address":[3160378,3160248],"length":1,"stats":{"Line":43}},{"line":189,"address":[2886096,2885966],"length":1,"stats":{"Line":67}},{"line":190,"address":[2612550,2612420],"length":1,"stats":{"Line":47}},{"line":191,"address":[2886300,2886170],"length":1,"stats":{"Line":66}},{"line":192,"address":[2612624,2612754],"length":1,"stats":{"Line":46}},{"line":193,"address":[2886374,2886504],"length":1,"stats":{"Line":81}},{"line":194,"address":[2612828,2612958],"length":1,"stats":{"Line":55}},{"line":195,"address":[2875422,2875314],"length":1,"stats":{"Line":61}},{"line":196,"address":[2875408],"length":1,"stats":{"Line":63}}],"covered":31,"coverable":34},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","lib.rs"],"content":"//! rawk - A 100% POSIX-compatible AWK implementation in Rust\n//!\n//! This crate provides a complete AWK interpreter that aims for full compatibility\n//! with POSIX AWK and GNU AWK extensions.\n//!\n//! # Example\n//!\n//! ```\n//! use rawk::{Lexer, Parser, Interpreter};\n//! use std::io::BufReader;\n//!\n//! // Parse an AWK program\n//! let source = r#\"BEGIN { print \"Hello, World!\" }\"#;\n//! let mut lexer = Lexer::new(source);\n//! let tokens = lexer.tokenize().unwrap();\n//! let mut parser = Parser::new(tokens);\n//! let program = parser.parse().unwrap();\n//!\n//! // Run the program\n//! let mut interpreter = Interpreter::new(\u0026program);\n//! let mut output = Vec::new();\n//! let inputs: Vec\u003cBufReader\u003c\u0026[u8]\u003e\u003e = vec![];\n//! interpreter.run(inputs, \u0026mut output).unwrap();\n//!\n//! assert_eq!(String::from_utf8(output).unwrap(), \"Hello, World!\\n\");\n//! ```\n//!\n//! # Field Processing Example\n//!\n//! ```\n//! use rawk::{Lexer, Parser, Interpreter};\n//! use std::io::BufReader;\n//!\n//! let source = r#\"{ print $1, $2 }\"#;\n//! let mut lexer = Lexer::new(source);\n//! let tokens = lexer.tokenize().unwrap();\n//! let mut parser = Parser::new(tokens);\n//! let program = parser.parse().unwrap();\n//!\n//! let mut interpreter = Interpreter::new(\u0026program);\n//! interpreter.set_fs(\",\");  // Use comma as field separator\n//!\n//! let input = b\"hello,world\\nfoo,bar\\n\";\n//! let mut output = Vec::new();\n//! let inputs = vec![BufReader::new(\u0026input[..])];\n//! interpreter.run(inputs, \u0026mut output).unwrap();\n//!\n//! assert_eq!(String::from_utf8(output).unwrap(), \"hello world\\nfoo bar\\n\");\n//! ```\n//!\n//! # Pattern Matching Example\n//!\n//! ```\n//! use rawk::{Lexer, Parser, Interpreter};\n//! use std::io::BufReader;\n//!\n//! let source = r#\"/error/ { print \"Found:\", $0 }\"#;\n//! let mut lexer = Lexer::new(source);\n//! let tokens = lexer.tokenize().unwrap();\n//! let mut parser = Parser::new(tokens);\n//! let program = parser.parse().unwrap();\n//!\n//! let mut interpreter = Interpreter::new(\u0026program);\n//! let input = b\"info: ok\\nerror: failed\\ninfo: done\\n\";\n//! let mut output = Vec::new();\n//! let inputs = vec![BufReader::new(\u0026input[..])];\n//! interpreter.run(inputs, \u0026mut output).unwrap();\n//!\n//! assert_eq!(String::from_utf8(output).unwrap(), \"Found: error: failed\\n\");\n//! ```\n\npub mod ast;\npub mod error;\npub mod interpreter;\npub mod lexer;\npub mod parser;\npub mod value;\n\npub use error::{Error, Result, SourceLocation};\npub use interpreter::Interpreter;\npub use lexer::{Lexer, Token, TokenKind};\npub use parser::Parser;\npub use value::Value;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","main.rs"],"content":"use std::env;\nuse std::fs::{self, File};\nuse std::io::{self, BufReader};\nuse std::process;\n\nuse rawk::{Interpreter, Lexer, Parser};\n\nfn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    match run(\u0026args[1..]) {\n        Ok(code) =\u003e process::exit(code),\n        Err(e) =\u003e {\n            eprintln!(\"rawk: {}\", e);\n            process::exit(2);\n        }\n    }\n}\n\nfn run(args: \u0026[String]) -\u003e Result\u003ci32, Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut field_separator = \" \".to_string();\n    let mut program_source: Option\u003cString\u003e = None;\n    let mut input_files: Vec\u003cString\u003e = Vec::new();\n    let mut variables: Vec\u003c(String, String)\u003e = Vec::new();\n    let mut posix_mode = false;\n    let mut traditional_mode = false;\n\n    let mut i = 0;\n    while i \u003c args.len() {\n        let arg = \u0026args[i];\n\n        if arg == \"--help\" || arg == \"-h\" {\n            print_help();\n            return Ok(0);\n        }\n\n        if arg == \"--version\" {\n            println!(\"rawk {}\", env!(\"CARGO_PKG_VERSION\"));\n            return Ok(0);\n        }\n\n        if arg == \"--posix\" || arg == \"-P\" {\n            posix_mode = true;\n            traditional_mode = false;\n            i += 1;\n            continue;\n        }\n\n        if arg == \"--traditional\" || arg == \"--compat\" || arg == \"-c\" {\n            traditional_mode = true;\n            posix_mode = false;\n            i += 1;\n            continue;\n        }\n\n        if arg == \"-F\" {\n            i += 1;\n            if i \u003e= args.len() {\n                return Err(\"option -F requires an argument\".into());\n            }\n            field_separator = args[i].clone();\n        } else if let Some(fs) = arg.strip_prefix(\"-F\") {\n            field_separator = fs.to_string();\n        } else if arg == \"-v\" {\n            i += 1;\n            if i \u003e= args.len() {\n                return Err(\"option -v requires an argument\".into());\n            }\n            let var_assign = \u0026args[i];\n            if let Some((name, value)) = var_assign.split_once('=') {\n                variables.push((name.to_string(), value.to_string()));\n            } else {\n                return Err(format!(\"invalid variable assignment: {}\", var_assign).into());\n            }\n        } else if arg == \"-f\" {\n            i += 1;\n            if i \u003e= args.len() {\n                return Err(\"option -f requires an argument\".into());\n            }\n            let script_file = \u0026args[i];\n            program_source = Some(fs::read_to_string(script_file)?);\n        } else if arg == \"--\" {\n            // End of options\n            i += 1;\n            input_files.extend(args[i..].iter().cloned());\n            break;\n        } else if arg.starts_with('-') \u0026\u0026 arg != \"-\" {\n            return Err(format!(\"unknown option: {}\", arg).into());\n        } else if program_source.is_none() {\n            // First non-option argument is the program\n            program_source = Some(arg.clone());\n        } else {\n            // Rest are input files\n            input_files.push(arg.clone());\n        }\n\n        i += 1;\n    }\n\n    let program_source = program_source.ok_or(\"no program provided\")?;\n\n    // Parse the program\n    let mut lexer = Lexer::new(\u0026program_source);\n    let tokens = lexer.tokenize()?;\n    let mut parser = Parser::new(tokens);\n    let program = parser.parse()?;\n\n    // Create interpreter\n    let mut interpreter = Interpreter::new(\u0026program);\n\n    // Set mode flags\n    interpreter.set_posix_mode(posix_mode);\n    interpreter.set_traditional_mode(traditional_mode);\n\n    // Set field separator\n    interpreter.set_fs(\u0026field_separator);\n\n    // Set ARGC and ARGV (ARGV[0] is \"awk\", ARGV[1...] are input files)\n    let mut argv = vec![\"awk\".to_string()];\n    argv.extend(input_files.iter().cloned());\n    interpreter.set_args(argv);\n\n    // Set variables\n    for (name, value) in \u0026variables {\n        interpreter.set_variable(name, value);\n    }\n\n    // Prepare output\n    let stdout = io::stdout();\n    let mut output = stdout.lock();\n\n    // Prepare inputs\n    let exit_code = if input_files.is_empty() {\n        // Read from stdin\n        interpreter.set_filename(\"\");\n        let stdin = io::stdin();\n        let inputs = vec![BufReader::new(stdin.lock())];\n        interpreter.run(inputs, \u0026mut output)?\n    } else {\n        // Read from files\n        let mut exit_code = 0;\n        for filename in \u0026input_files {\n            interpreter.set_filename(filename);\n            if filename == \"-\" {\n                let stdin = io::stdin();\n                let inputs = vec![BufReader::new(stdin.lock())];\n                exit_code = interpreter.run(inputs, \u0026mut output)?;\n            } else {\n                let file = File::open(filename)?;\n                let inputs = vec![BufReader::new(file)];\n                exit_code = interpreter.run(inputs, \u0026mut output)?;\n            }\n        }\n        exit_code\n    };\n\n    Ok(exit_code)\n}\n\nfn print_help() {\n    println!(\n        r#\"Usage: rawk [OPTIONS] 'program' [file ...]\n       rawk [OPTIONS] -f progfile [file ...]\n\nA 100% POSIX-compatible AWK implementation in Rust with gawk extensions.\n\nOptions:\n  -F fs            Set the field separator to fs\n  -v var=val       Assign value to variable before execution\n  -f progfile      Read the AWK program from file\n  -P, --posix      Strict POSIX mode (disable gawk extensions)\n  -c, --traditional Traditional AWK mode (disable gawk extensions)\n  --version        Print version information\n  --help           Print this help message\n\nGAWK Extensions (disabled with --posix or --traditional):\n  FPAT             Field pattern for content-based splitting\n  FIELDWIDTHS      Fixed-width field splitting\n  BEGINFILE/ENDFILE Patterns for file processing\n  systime(), mktime(), strftime() Time functions\n  gensub(), patsplit(), asort(), asorti() String/array functions\n\nExamples:\n  rawk '{{ print $1 }}' file.txt\n  rawk -F: '{{ print $1 }}' /etc/passwd\n  rawk 'BEGIN {{ print \"Hello\" }}'\n  rawk '/pattern/ {{ print }}' file.txt\n\"#\n    );\n}\n","traces":[{"line":8,"address":[2221315,2220944,2221309],"length":1,"stats":{"Line":0}},{"line":9,"address":[2220951],"length":1,"stats":{"Line":0}},{"line":11,"address":[2221080,2220995],"length":1,"stats":{"Line":0}},{"line":12,"address":[2221163],"length":1,"stats":{"Line":0}},{"line":13,"address":[2221115],"length":1,"stats":{"Line":0}},{"line":14,"address":[2221140,2221224],"length":1,"stats":{"Line":0}},{"line":15,"address":[2221293],"length":1,"stats":{"Line":0}},{"line":20,"address":[2217286,2211616,2220926],"length":1,"stats":{"Line":0}},{"line":21,"address":[2211686],"length":1,"stats":{"Line":0}},{"line":22,"address":[2211747],"length":1,"stats":{"Line":0}},{"line":23,"address":[2211773],"length":1,"stats":{"Line":0}},{"line":24,"address":[2211841],"length":1,"stats":{"Line":0}},{"line":25,"address":[2211889],"length":1,"stats":{"Line":0}},{"line":26,"address":[2211897],"length":1,"stats":{"Line":0}},{"line":28,"address":[2211905],"length":1,"stats":{"Line":0}},{"line":29,"address":[2211925,2220578],"length":1,"stats":{"Line":0}},{"line":30,"address":[2212021,2212119],"length":1,"stats":{"Line":0}},{"line":32,"address":[2212238,2212074,2212186],"length":1,"stats":{"Line":0}},{"line":33,"address":[2212221],"length":1,"stats":{"Line":0}},{"line":34,"address":[2220772],"length":1,"stats":{"Line":0}},{"line":37,"address":[2212244],"length":1,"stats":{"Line":0}},{"line":38,"address":[2220718,2212315],"length":1,"stats":{"Line":0}},{"line":39,"address":[2220745],"length":1,"stats":{"Line":0}},{"line":42,"address":[2212286,2212356,2212451],"length":1,"stats":{"Line":0}},{"line":43,"address":[2212391],"length":1,"stats":{"Line":0}},{"line":44,"address":[2212399],"length":1,"stats":{"Line":0}},{"line":45,"address":[2220684,2212407],"length":1,"stats":{"Line":0}},{"line":49,"address":[2212588,2212457],"length":1,"stats":{"Line":0}},{"line":50,"address":[2212528],"length":1,"stats":{"Line":0}},{"line":51,"address":[2212536],"length":1,"stats":{"Line":0}},{"line":52,"address":[2220642,2212544],"length":1,"stats":{"Line":0}},{"line":56,"address":[2220557,2212636],"length":1,"stats":{"Line":0}},{"line":57,"address":[2220233,2212709,2220253],"length":1,"stats":{"Line":0}},{"line":58,"address":[2220241],"length":1,"stats":{"Line":0}},{"line":59,"address":[2220622,2220302],"length":1,"stats":{"Line":0}},{"line":61,"address":[2220354,2220282,2220434],"length":1,"stats":{"Line":0}},{"line":62,"address":[2212678,2212762],"length":1,"stats":{"Line":0}},{"line":63,"address":[2212892,2212962,2212943],"length":1,"stats":{"Line":0}},{"line":64,"address":[2213129,2212911],"length":1,"stats":{"Line":0}},{"line":65,"address":[2213164,2219472,2219492],"length":1,"stats":{"Line":0}},{"line":66,"address":[2219480],"length":1,"stats":{"Line":0}},{"line":67,"address":[2220205,2219541],"length":1,"stats":{"Line":0}},{"line":69,"address":[2219647,2219593,2219521],"length":1,"stats":{"Line":0}},{"line":70,"address":[2219609,2219691],"length":1,"stats":{"Line":0}},{"line":71,"address":[2219870,2219803],"length":1,"stats":{"Line":0}},{"line":73,"address":[2220025,2219830],"length":1,"stats":{"Line":0}},{"line":75,"address":[2213135,2219416,2213208],"length":1,"stats":{"Line":0}},{"line":76,"address":[2213243,2218907,2218927],"length":1,"stats":{"Line":0}},{"line":77,"address":[2218915],"length":1,"stats":{"Line":0}},{"line":78,"address":[2219444,2218976],"length":1,"stats":{"Line":0}},{"line":80,"address":[2218956,2219072,2219028],"length":1,"stats":{"Line":0}},{"line":81,"address":[2219052,2219421,2219277,2219109],"length":1,"stats":{"Line":0}},{"line":82,"address":[2213287,2213214],"length":1,"stats":{"Line":0}},{"line":84,"address":[2213324,2214020,2214066],"length":1,"stats":{"Line":0}},{"line":85,"address":[2214103,2214028],"length":1,"stats":{"Line":0}},{"line":87,"address":[2213293,2213435,2213377],"length":1,"stats":{"Line":0}},{"line":88,"address":[2213485,2213809],"length":1,"stats":{"Line":0}},{"line":89,"address":[2213804,2213421,2213522],"length":1,"stats":{"Line":0}},{"line":91,"address":[2213665,2213555,2213614],"length":1,"stats":{"Line":0}},{"line":94,"address":[2213528,2213582],"length":1,"stats":{"Line":0}},{"line":97,"address":[2220583,2213085,2220570],"length":1,"stats":{"Line":0}},{"line":100,"address":[2211935,2218886,2214221],"length":1,"stats":{"Line":0}},{"line":103,"address":[2214477,2214394],"length":1,"stats":{"Line":0}},{"line":104,"address":[2214496,2218884],"length":1,"stats":{"Line":0}},{"line":105,"address":[2214727],"length":1,"stats":{"Line":0}},{"line":106,"address":[2218827,2214919,2214835],"length":1,"stats":{"Line":0}},{"line":109,"address":[2215117],"length":1,"stats":{"Line":0}},{"line":112,"address":[2215188],"length":1,"stats":{"Line":0}},{"line":113,"address":[2215256],"length":1,"stats":{"Line":0}},{"line":116,"address":[2215291],"length":1,"stats":{"Line":0}},{"line":119,"address":[2218822,2215359],"length":1,"stats":{"Line":0}},{"line":120,"address":[2215618,2215710],"length":1,"stats":{"Line":0}},{"line":121,"address":[2215807],"length":1,"stats":{"Line":0}},{"line":124,"address":[2215882],"length":1,"stats":{"Line":0}},{"line":125,"address":[2218721,2216051],"length":1,"stats":{"Line":0}},{"line":129,"address":[2216077],"length":1,"stats":{"Line":0}},{"line":130,"address":[2216112],"length":1,"stats":{"Line":0}},{"line":133,"address":[2216228,2216155,2218434],"length":1,"stats":{"Line":0}},{"line":135,"address":[2216280],"length":1,"stats":{"Line":0}},{"line":136,"address":[2217883],"length":1,"stats":{"Line":0}},{"line":137,"address":[2217928,2218676],"length":1,"stats":{"Line":0}},{"line":138,"address":[2218603,2218274],"length":1,"stats":{"Line":0}},{"line":141,"address":[2216234],"length":1,"stats":{"Line":0}},{"line":142,"address":[2216327,2216245],"length":1,"stats":{"Line":0}},{"line":143,"address":[2216433,2216537],"length":1,"stats":{"Line":0}},{"line":144,"address":[2217868,2216556,2217269],"length":1,"stats":{"Line":0}},{"line":145,"address":[2217347,2216625],"length":1,"stats":{"Line":0}},{"line":146,"address":[2217878,2217365],"length":1,"stats":{"Line":0}},{"line":147,"address":[2217711,2217873],"length":1,"stats":{"Line":0}},{"line":149,"address":[2217319,2216598,2216663],"length":1,"stats":{"Line":0}},{"line":150,"address":[2216829,2217292,2216765],"length":1,"stats":{"Line":0}},{"line":151,"address":[2217274,2217104],"length":1,"stats":{"Line":0}},{"line":154,"address":[2216464],"length":1,"stats":{"Line":0}},{"line":157,"address":[2216486],"length":1,"stats":{"Line":0}},{"line":160,"address":[2211568],"length":1,"stats":{"Line":0}},{"line":161,"address":[2211572],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":96},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","parser","mod.rs"],"content":"use crate::ast::*;\nuse crate::error::{Error, Result, SourceLocation};\nuse crate::lexer::{Token, TokenKind};\n\n/// AWK parser using recursive descent\npub struct Parser {\n    tokens: Vec\u003cToken\u003e,\n    current: usize,\n}\n\nimpl Parser {\n    pub fn new(tokens: Vec\u003cToken\u003e) -\u003e Self {\n        Self { tokens, current: 0 }\n    }\n\n    /// Parse a complete AWK program\n    pub fn parse(\u0026mut self) -\u003e Result\u003cProgram\u003e {\n        let mut program = Program::new();\n\n        self.skip_newlines();\n\n        while !self.is_at_end() {\n            // Check for function definition\n            if self.check(\u0026TokenKind::Function) {\n                program.functions.push(self.parse_function()?);\n            } else {\n                program.rules.push(self.parse_rule()?);\n            }\n            self.skip_newlines();\n        }\n\n        Ok(program)\n    }\n\n    /// Parse a function definition\n    fn parse_function(\u0026mut self) -\u003e Result\u003cFunctionDef\u003e {\n        let location = self.current_location();\n        self.expect(\u0026TokenKind::Function)?;\n\n        let name = self.expect_identifier()?;\n        self.expect(\u0026TokenKind::LeftParen)?;\n\n        let mut params = Vec::new();\n        if !self.check(\u0026TokenKind::RightParen) {\n            params.push(self.expect_identifier()?);\n            while self.match_token(\u0026TokenKind::Comma) {\n                params.push(self.expect_identifier()?);\n            }\n        }\n        self.expect(\u0026TokenKind::RightParen)?;\n        self.skip_newlines();\n\n        let body = self.parse_block()?;\n\n        Ok(FunctionDef {\n            name,\n            params,\n            body,\n            location,\n        })\n    }\n\n    /// Parse a pattern-action rule\n    fn parse_rule(\u0026mut self) -\u003e Result\u003cRule\u003e {\n        let location = self.current_location();\n\n        // Check for BEGIN/END/BEGINFILE/ENDFILE\n        if self.check(\u0026TokenKind::Begin) {\n            self.advance();\n            self.skip_newlines();\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: Some(Pattern::Begin),\n                action,\n                location,\n            });\n        }\n\n        if self.check(\u0026TokenKind::End) {\n            self.advance();\n            self.skip_newlines();\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: Some(Pattern::End),\n                action,\n                location,\n            });\n        }\n\n        if self.check(\u0026TokenKind::BeginFile) {\n            self.advance();\n            self.skip_newlines();\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: Some(Pattern::BeginFile),\n                action,\n                location,\n            });\n        }\n\n        if self.check(\u0026TokenKind::EndFile) {\n            self.advance();\n            self.skip_newlines();\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: Some(Pattern::EndFile),\n                action,\n                location,\n            });\n        }\n\n        // Check for action-only rule (just a block)\n        if self.check(\u0026TokenKind::LeftBrace) {\n            let action = Some(self.parse_block()?);\n            return Ok(Rule {\n                pattern: None,\n                action,\n                location,\n            });\n        }\n\n        // Parse pattern\n        let pattern = Some(self.parse_pattern()?);\n        self.skip_newlines();\n\n        // Optional action\n        let action = if self.check(\u0026TokenKind::LeftBrace) {\n            Some(self.parse_block()?)\n        } else {\n            None\n        };\n\n        Ok(Rule {\n            pattern,\n            action,\n            location,\n        })\n    }\n\n    /// Parse a pattern (expression or regex)\n    fn parse_pattern(\u0026mut self) -\u003e Result\u003cPattern\u003e {\n        // Check for regex pattern\n        if let Some(TokenKind::Regex(pattern)) = self.peek_kind() {\n            let pattern = pattern.clone();\n            self.advance();\n\n            // Check for range pattern\n            if self.match_token(\u0026TokenKind::Comma) {\n                self.skip_newlines();\n                let end = self.parse_pattern()?;\n                return Ok(Pattern::Range {\n                    start: Box::new(Pattern::Regex(pattern)),\n                    end: Box::new(end),\n                });\n            }\n\n            return Ok(Pattern::Regex(pattern));\n        }\n\n        // Parse as expression pattern\n        let expr = self.parse_expression()?;\n\n        // Check for range pattern\n        if self.match_token(\u0026TokenKind::Comma) {\n            self.skip_newlines();\n            let end = self.parse_pattern()?;\n            return Ok(Pattern::Range {\n                start: Box::new(Pattern::Expr(expr)),\n                end: Box::new(end),\n            });\n        }\n\n        Ok(Pattern::Expr(expr))\n    }\n\n    /// Parse a block { ... }\n    fn parse_block(\u0026mut self) -\u003e Result\u003cBlock\u003e {\n        let location = self.current_location();\n        self.expect(\u0026TokenKind::LeftBrace)?;\n        self.skip_newlines();\n\n        let mut statements = Vec::new();\n\n        while !self.check(\u0026TokenKind::RightBrace) \u0026\u0026 !self.is_at_end() {\n            statements.push(self.parse_statement()?);\n            self.skip_terminators();\n        }\n\n        self.expect(\u0026TokenKind::RightBrace)?;\n\n        Ok(Block::new(statements, location))\n    }\n\n    /// Parse a single statement\n    fn parse_statement(\u0026mut self) -\u003e Result\u003cStmt\u003e {\n        self.skip_newlines();\n\n        let location = self.current_location();\n\n        // Empty statement\n        if self.check(\u0026TokenKind::Semicolon) {\n            self.advance();\n            return Ok(Stmt::Empty);\n        }\n\n        // Block\n        if self.check(\u0026TokenKind::LeftBrace) {\n            return Ok(Stmt::Block(self.parse_block()?));\n        }\n\n        // If statement\n        if self.match_token(\u0026TokenKind::If) {\n            return self.parse_if_statement(location);\n        }\n\n        // While statement\n        if self.match_token(\u0026TokenKind::While) {\n            return self.parse_while_statement(location);\n        }\n\n        // For statement\n        if self.match_token(\u0026TokenKind::For) {\n            return self.parse_for_statement(location);\n        }\n\n        // Do-while statement\n        if self.match_token(\u0026TokenKind::Do) {\n            return self.parse_do_while_statement(location);\n        }\n\n        // Break\n        if self.match_token(\u0026TokenKind::Break) {\n            return Ok(Stmt::Break { location });\n        }\n\n        // Continue\n        if self.match_token(\u0026TokenKind::Continue) {\n            return Ok(Stmt::Continue { location });\n        }\n\n        // Next\n        if self.match_token(\u0026TokenKind::Next) {\n            return Ok(Stmt::Next { location });\n        }\n\n        // Nextfile\n        if self.match_token(\u0026TokenKind::Nextfile) {\n            return Ok(Stmt::Nextfile { location });\n        }\n\n        // Exit\n        if self.match_token(\u0026TokenKind::Exit) {\n            let code = if self.can_start_expression() {\n                Some(self.parse_expression()?)\n            } else {\n                None\n            };\n            return Ok(Stmt::Exit { code, location });\n        }\n\n        // Return\n        if self.match_token(\u0026TokenKind::Return) {\n            let value = if self.can_start_expression() {\n                Some(self.parse_expression()?)\n            } else {\n                None\n            };\n            return Ok(Stmt::Return { value, location });\n        }\n\n        // Delete\n        if self.match_token(\u0026TokenKind::Delete) {\n            let name = self.expect_identifier()?;\n\n            // Check if there's an index (delete array[i]) or not (delete array)\n            let indices = if self.match_token(\u0026TokenKind::LeftBracket) {\n                let mut indices = vec![self.parse_expression()?];\n                while self.match_token(\u0026TokenKind::Comma) {\n                    indices.push(self.parse_expression()?);\n                }\n                self.expect(\u0026TokenKind::RightBracket)?;\n                indices\n            } else {\n                // delete array (entire array)\n                Vec::new()\n            };\n\n            return Ok(Stmt::Delete {\n                array: name,\n                index: indices,\n                location,\n            });\n        }\n\n        // Print statement\n        if self.match_token(\u0026TokenKind::Print) {\n            return self.parse_print_statement(location);\n        }\n\n        // Printf statement\n        if self.match_token(\u0026TokenKind::Printf) {\n            return self.parse_printf_statement(location);\n        }\n\n        // Expression statement\n        let expr = self.parse_expression()?;\n        Ok(Stmt::Expr(expr))\n    }\n\n    fn parse_if_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        self.expect(\u0026TokenKind::LeftParen)?;\n        let condition = self.parse_expression()?;\n        self.expect(\u0026TokenKind::RightParen)?;\n        self.skip_newlines();\n\n        let then_branch = Box::new(self.parse_statement()?);\n\n        // Skip terminators (semicolons and newlines) before checking for else\n        self.skip_terminators();\n        let else_branch = if self.match_token(\u0026TokenKind::Else) {\n            self.skip_newlines();\n            Some(Box::new(self.parse_statement()?))\n        } else {\n            None\n        };\n\n        Ok(Stmt::If {\n            condition,\n            then_branch,\n            else_branch,\n            location,\n        })\n    }\n\n    fn parse_while_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        self.expect(\u0026TokenKind::LeftParen)?;\n        let condition = self.parse_expression()?;\n        self.expect(\u0026TokenKind::RightParen)?;\n        self.skip_newlines();\n\n        let body = Box::new(self.parse_statement()?);\n\n        Ok(Stmt::While {\n            condition,\n            body,\n            location,\n        })\n    }\n\n    fn parse_for_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        self.expect(\u0026TokenKind::LeftParen)?;\n\n        // Check for for-in loop: for (var in array)\n        if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n            let name = name.clone();\n            let saved_pos = self.current;\n            self.advance();\n\n            if self.match_token(\u0026TokenKind::In) {\n                let array = self.expect_identifier()?;\n                self.expect(\u0026TokenKind::RightParen)?;\n                self.skip_newlines();\n                let body = Box::new(self.parse_statement()?);\n\n                return Ok(Stmt::ForIn {\n                    var: name,\n                    array,\n                    body,\n                    location,\n                });\n            }\n\n            // Not a for-in, backtrack\n            self.current = saved_pos;\n        }\n\n        // C-style for loop\n        let init = if !self.check(\u0026TokenKind::Semicolon) {\n            Some(Box::new(self.parse_statement()?))\n        } else {\n            None\n        };\n        self.expect(\u0026TokenKind::Semicolon)?;\n\n        let condition = if !self.check(\u0026TokenKind::Semicolon) {\n            Some(self.parse_expression()?)\n        } else {\n            None\n        };\n        self.expect(\u0026TokenKind::Semicolon)?;\n\n        let update = if !self.check(\u0026TokenKind::RightParen) {\n            Some(self.parse_expression()?)\n        } else {\n            None\n        };\n        self.expect(\u0026TokenKind::RightParen)?;\n        self.skip_newlines();\n\n        let body = Box::new(self.parse_statement()?);\n\n        Ok(Stmt::For {\n            init,\n            condition,\n            update,\n            body,\n            location,\n        })\n    }\n\n    fn parse_do_while_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        self.skip_newlines();\n        let body = Box::new(self.parse_statement()?);\n        self.skip_newlines();\n        self.expect(\u0026TokenKind::While)?;\n        self.expect(\u0026TokenKind::LeftParen)?;\n        let condition = self.parse_expression()?;\n        self.expect(\u0026TokenKind::RightParen)?;\n\n        Ok(Stmt::DoWhile {\n            body,\n            condition,\n            location,\n        })\n    }\n\n    fn parse_print_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        let mut args = Vec::new();\n\n        // Check for arguments (print without args prints $0)\n        if self.can_start_expression() \u0026\u0026 !self.check(\u0026TokenKind::Greater) \u0026\u0026 !self.check(\u0026TokenKind::Append) \u0026\u0026 !self.check(\u0026TokenKind::Pipe) {\n            args.push(self.parse_print_arg()?);\n            while self.match_token(\u0026TokenKind::Comma) {\n                args.push(self.parse_print_arg()?);\n            }\n        }\n\n        // Check for output redirection\n        let output = self.parse_output_redirect()?;\n\n        Ok(Stmt::Print {\n            args,\n            output,\n            location,\n        })\n    }\n\n    fn parse_printf_statement(\u0026mut self, location: SourceLocation) -\u003e Result\u003cStmt\u003e {\n        let format = self.parse_print_arg()?;\n        let mut args = Vec::new();\n\n        while self.match_token(\u0026TokenKind::Comma) {\n            args.push(self.parse_print_arg()?);\n        }\n\n        let output = self.parse_output_redirect()?;\n\n        Ok(Stmt::Printf {\n            format,\n            args,\n            output,\n            location,\n        })\n    }\n\n    fn parse_print_arg(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        // Print arguments don't include comparison operators with \u003e at the top level\n        // because \u003e is used for output redirection. We parse up to concatenation level.\n        self.parse_print_ternary()\n    }\n\n    fn parse_print_ternary(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_print_or()?;\n\n        if self.match_token(\u0026TokenKind::Question) {\n            let location = self.current_location();\n            let then_expr = self.parse_print_ternary()?;\n            self.expect(\u0026TokenKind::Colon)?;\n            let else_expr = self.parse_print_ternary()?;\n            return Ok(Expr::Ternary {\n                condition: Box::new(expr),\n                then_expr: Box::new(then_expr),\n                else_expr: Box::new(else_expr),\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_or(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_print_and()?;\n\n        while self.match_token(\u0026TokenKind::Or) {\n            let location = self.current_location();\n            let right = self.parse_print_and()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::Or,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_and(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_print_in()?;\n\n        while self.match_token(\u0026TokenKind::And) {\n            let location = self.current_location();\n            let right = self.parse_print_in()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::And,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_in(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_print_match()?;\n\n        if self.match_token(\u0026TokenKind::In) {\n            let location = self.current_location();\n            let array = self.expect_identifier()?;\n            return Ok(Expr::InArray {\n                key: vec![expr],\n                array,\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_match(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_print_comparison()?;\n\n        let location = self.current_location();\n        if self.match_token(\u0026TokenKind::Match) {\n            let pattern = self.parse_print_comparison()?;\n            return Ok(Expr::Match {\n                expr: Box::new(expr),\n                pattern: Box::new(pattern),\n                negated: false,\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::NotMatch) {\n            let pattern = self.parse_print_comparison()?;\n            return Ok(Expr::Match {\n                expr: Box::new(expr),\n                pattern: Box::new(pattern),\n                negated: true,\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_print_comparison(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_concat()?;\n\n        // For print args, we DON'T consume \u003e or \u003e\u003e because they're used for output redirection\n        // But we DO handle \u003e=, \u003c, \u003c=, ==, !=\n        loop {\n            let location = self.current_location();\n            let op = if self.match_token(\u0026TokenKind::Less) {\n                BinaryOp::Lt\n            } else if self.match_token(\u0026TokenKind::LessEqual) {\n                BinaryOp::Le\n            } else if self.match_token(\u0026TokenKind::GreaterEqual) {\n                BinaryOp::Ge\n            } else if self.match_token(\u0026TokenKind::Equal) {\n                BinaryOp::Eq\n            } else if self.match_token(\u0026TokenKind::NotEqual) {\n                BinaryOp::Ne\n            } else {\n                // Don't consume \u003e or \u003e\u003e for print arguments (used for output redirection)\n                break;\n            };\n\n            let right = self.parse_concat()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_output_redirect(\u0026mut self) -\u003e Result\u003cOption\u003cOutputRedirect\u003e\u003e {\n        if self.match_token(\u0026TokenKind::Greater) {\n            let target = self.parse_print_arg()?;\n            Ok(Some(OutputRedirect::Truncate(target)))\n        } else if self.match_token(\u0026TokenKind::Append) {\n            let target = self.parse_print_arg()?;\n            Ok(Some(OutputRedirect::Append(target)))\n        } else if self.match_token(\u0026TokenKind::Pipe) {\n            let target = self.parse_print_arg()?;\n            Ok(Some(OutputRedirect::Pipe(target)))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse an expression\n    fn parse_expression(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        self.parse_assignment()\n    }\n\n    fn parse_assignment(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_ternary()?;\n\n        // Check for assignment operators\n        let location = self.current_location();\n        let op = if self.match_token(\u0026TokenKind::Assign) {\n            Some(AssignOp::Assign)\n        } else if self.match_token(\u0026TokenKind::PlusAssign) {\n            Some(AssignOp::AddAssign)\n        } else if self.match_token(\u0026TokenKind::MinusAssign) {\n            Some(AssignOp::SubAssign)\n        } else if self.match_token(\u0026TokenKind::StarAssign) {\n            Some(AssignOp::MulAssign)\n        } else if self.match_token(\u0026TokenKind::SlashAssign) {\n            Some(AssignOp::DivAssign)\n        } else if self.match_token(\u0026TokenKind::PercentAssign) {\n            Some(AssignOp::ModAssign)\n        } else if self.match_token(\u0026TokenKind::CaretAssign) {\n            Some(AssignOp::PowAssign)\n        } else {\n            None\n        };\n\n        if let Some(op) = op {\n            let value = self.parse_assignment()?;\n            return Ok(Expr::Assign {\n                target: Box::new(expr),\n                op,\n                value: Box::new(value),\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_ternary(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_or()?;\n\n        if self.match_token(\u0026TokenKind::Question) {\n            let location = self.current_location();\n            let then_expr = self.parse_expression()?;\n            self.expect(\u0026TokenKind::Colon)?;\n            let else_expr = self.parse_ternary()?;\n            return Ok(Expr::Ternary {\n                condition: Box::new(expr),\n                then_expr: Box::new(then_expr),\n                else_expr: Box::new(else_expr),\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_or(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_and()?;\n\n        while self.match_token(\u0026TokenKind::Or) {\n            let location = self.current_location();\n            let right = self.parse_and()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::Or,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_and(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_in()?;\n\n        while self.match_token(\u0026TokenKind::And) {\n            let location = self.current_location();\n            let right = self.parse_in()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::And,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_in(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_pipe_getline()?;\n\n        // Check for \"in\" (array membership)\n        // Format: (expr) in array or expr in array\n        if self.match_token(\u0026TokenKind::In) {\n            let location = self.current_location();\n            let array = self.expect_identifier()?;\n            return Ok(Expr::InArray {\n                key: vec![expr],\n                array,\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    /// Handle `cmd | getline [var]` syntax\n    fn parse_pipe_getline(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_match()?;\n\n        // Check for pipe to getline: expr | getline [var]\n        if self.check(\u0026TokenKind::Pipe) {\n            // Look ahead to see if getline follows\n            let saved_pos = self.current;\n            self.advance(); // consume |\n\n            if self.check(\u0026TokenKind::Getline) {\n                let location = self.current_location();\n                self.advance(); // consume getline\n\n                // Optional variable name\n                let var = if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n                    let name = name.clone();\n                    self.advance();\n                    Some(name)\n                } else {\n                    None\n                };\n\n                return Ok(Expr::Getline {\n                    var,\n                    input: Some(GetlineInput::Pipe(Box::new(expr))),\n                    location,\n                });\n            } else {\n                // Not getline, backtrack\n                self.current = saved_pos;\n            }\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_match(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_comparison()?;\n\n        let location = self.current_location();\n        if self.match_token(\u0026TokenKind::Match) {\n            let pattern = self.parse_comparison()?;\n            return Ok(Expr::Match {\n                expr: Box::new(expr),\n                pattern: Box::new(pattern),\n                negated: false,\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::NotMatch) {\n            let pattern = self.parse_comparison()?;\n            return Ok(Expr::Match {\n                expr: Box::new(expr),\n                pattern: Box::new(pattern),\n                negated: true,\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_comparison(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_concat()?;\n\n        loop {\n            let location = self.current_location();\n            let op = if self.match_token(\u0026TokenKind::Less) {\n                BinaryOp::Lt\n            } else if self.match_token(\u0026TokenKind::LessEqual) {\n                BinaryOp::Le\n            } else if self.match_token(\u0026TokenKind::Greater) {\n                BinaryOp::Gt\n            } else if self.match_token(\u0026TokenKind::GreaterEqual) {\n                BinaryOp::Ge\n            } else if self.match_token(\u0026TokenKind::Equal) {\n                BinaryOp::Eq\n            } else if self.match_token(\u0026TokenKind::NotEqual) {\n                BinaryOp::Ne\n            } else {\n                break;\n            };\n\n            let right = self.parse_concat()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_concat(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_additive()?;\n\n        // Concatenation is implicit between adjacent expressions\n        // But we need to be careful about operators that could follow\n        while self.can_start_concat_operand() {\n            let right = self.parse_additive()?;\n            let location = expr.location();\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::Concat,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn can_start_concat_operand(\u0026mut self) -\u003e bool {\n        if let Some(kind) = self.peek_kind() {\n            matches!(\n                kind,\n                TokenKind::Number(_)\n                    | TokenKind::String(_)\n                    | TokenKind::Identifier(_)\n                    | TokenKind::Dollar\n                    | TokenKind::LeftParen\n                    | TokenKind::Not\n                    | TokenKind::Increment\n                    | TokenKind::Decrement\n            )\n        } else {\n            false\n        }\n    }\n\n    fn parse_additive(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_multiplicative()?;\n\n        loop {\n            let location = self.current_location();\n            let op = if self.match_token(\u0026TokenKind::Plus) {\n                BinaryOp::Add\n            } else if self.match_token(\u0026TokenKind::Minus) {\n                BinaryOp::Sub\n            } else {\n                break;\n            };\n\n            let right = self.parse_multiplicative()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_multiplicative(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_power()?;\n\n        loop {\n            let location = self.current_location();\n            let op = if self.match_token(\u0026TokenKind::Star) {\n                BinaryOp::Mul\n            } else if self.match_token(\u0026TokenKind::Slash) {\n                BinaryOp::Div\n            } else if self.match_token(\u0026TokenKind::Percent) {\n                BinaryOp::Mod\n            } else {\n                break;\n            };\n\n            let right = self.parse_power()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                op,\n                right: Box::new(right),\n                location,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_power(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let expr = self.parse_unary()?;\n\n        // Exponentiation is right-associative\n        if self.match_token(\u0026TokenKind::Caret) {\n            let location = self.current_location();\n            let right = self.parse_power()?;\n            return Ok(Expr::Binary {\n                left: Box::new(expr),\n                op: BinaryOp::Pow,\n                right: Box::new(right),\n                location,\n            });\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_unary(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let location = self.current_location();\n\n        if self.match_token(\u0026TokenKind::Not) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary {\n                op: UnaryOp::Not,\n                operand: Box::new(operand),\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::Minus) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary {\n                op: UnaryOp::Neg,\n                operand: Box::new(operand),\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::Plus) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary {\n                op: UnaryOp::Pos,\n                operand: Box::new(operand),\n                location,\n            });\n        }\n\n        if self.match_token(\u0026TokenKind::Increment) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::PreIncrement(Box::new(operand), location));\n        }\n\n        if self.match_token(\u0026TokenKind::Decrement) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::PreDecrement(Box::new(operand), location));\n        }\n\n        self.parse_postfix()\n    }\n\n    fn parse_postfix(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut expr = self.parse_field()?;\n\n        loop {\n            let location = self.current_location();\n\n            if self.match_token(\u0026TokenKind::Increment) {\n                expr = Expr::PostIncrement(Box::new(expr), location);\n            } else if self.match_token(\u0026TokenKind::Decrement) {\n                expr = Expr::PostDecrement(Box::new(expr), location);\n            } else if self.match_token(\u0026TokenKind::LeftBracket) {\n                // Array access\n                if let Expr::Var(name, _) = expr {\n                    let mut indices = vec![self.parse_expression()?];\n                    while self.match_token(\u0026TokenKind::Comma) {\n                        indices.push(self.parse_expression()?);\n                    }\n                    self.expect(\u0026TokenKind::RightBracket)?;\n                    expr = Expr::ArrayAccess {\n                        array: name,\n                        indices,\n                        location,\n                    };\n                } else {\n                    return Err(Error::parser(\"array access requires variable name\", location.line, location.column));\n                }\n            } else {\n                break;\n            }\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_field(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        if self.match_token(\u0026TokenKind::Dollar) {\n            let location = self.current_location();\n            let expr = self.parse_field()?;\n            return Ok(Expr::Field(Box::new(expr), location));\n        }\n\n        self.parse_primary()\n    }\n\n    fn parse_primary(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let location = self.current_location();\n\n        // Number literal\n        if let Some(TokenKind::Number(n)) = self.peek_kind() {\n            let n = *n;\n            self.advance();\n            return Ok(Expr::Number(n, location));\n        }\n\n        // String literal\n        if let Some(TokenKind::String(s)) = self.peek_kind() {\n            let s = s.clone();\n            self.advance();\n            return Ok(Expr::String(s, location));\n        }\n\n        // Regex literal\n        if let Some(TokenKind::Regex(r)) = self.peek_kind() {\n            let r = r.clone();\n            self.advance();\n            return Ok(Expr::Regex(r, location));\n        }\n\n        // Identifier (variable or function call)\n        if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n            let name = name.clone();\n            self.advance();\n\n            // Check for function call\n            if self.match_token(\u0026TokenKind::LeftParen) {\n                let mut args = Vec::new();\n                if !self.check(\u0026TokenKind::RightParen) {\n                    args.push(self.parse_expression()?);\n                    while self.match_token(\u0026TokenKind::Comma) {\n                        args.push(self.parse_expression()?);\n                    }\n                }\n                self.expect(\u0026TokenKind::RightParen)?;\n                return Ok(Expr::Call {\n                    name,\n                    args,\n                    location,\n                });\n            }\n\n            return Ok(Expr::Var(name, location));\n        }\n\n        // Getline\n        if self.match_token(\u0026TokenKind::Getline) {\n            let var = if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n                let name = name.clone();\n                self.advance();\n                Some(name)\n            } else {\n                None\n            };\n\n            let input = if self.match_token(\u0026TokenKind::Less) {\n                Some(GetlineInput::File(Box::new(self.parse_primary()?)))\n            } else {\n                None\n            };\n\n            return Ok(Expr::Getline {\n                var,\n                input,\n                location,\n            });\n        }\n\n        // Parenthesized expression\n        if self.match_token(\u0026TokenKind::LeftParen) {\n            let expr = self.parse_expression()?;\n            self.expect(\u0026TokenKind::RightParen)?;\n            return Ok(Expr::Group(Box::new(expr), location));\n        }\n\n        Err(Error::parser(\n            format!(\"unexpected token {:?}\", self.peek_kind()),\n            location.line,\n            location.column,\n        ))\n    }\n\n    // ===== Helper methods =====\n\n    fn peek_kind(\u0026self) -\u003e Option\u003c\u0026TokenKind\u003e {\n        self.tokens.get(self.current).map(|t| \u0026t.kind)\n    }\n\n    fn current_location(\u0026self) -\u003e SourceLocation {\n        self.tokens\n            .get(self.current)\n            .map(|t| t.location)\n            .unwrap_or(SourceLocation::new(0, 0))\n    }\n\n    fn is_at_end(\u0026self) -\u003e bool {\n        matches!(self.peek_kind(), None | Some(TokenKind::Eof))\n    }\n\n    fn check(\u0026self, kind: \u0026TokenKind) -\u003e bool {\n        self.peek_kind().map(|k| std::mem::discriminant(k) == std::mem::discriminant(kind)).unwrap_or(false)\n    }\n\n    fn advance(\u0026mut self) -\u003e Option\u003c\u0026Token\u003e {\n        if !self.is_at_end() {\n            self.current += 1;\n        }\n        self.tokens.get(self.current - 1)\n    }\n\n    fn match_token(\u0026mut self, kind: \u0026TokenKind) -\u003e bool {\n        if self.check(kind) {\n            self.advance();\n            true\n        } else {\n            false\n        }\n    }\n\n    fn expect(\u0026mut self, kind: \u0026TokenKind) -\u003e Result\u003c\u0026Token\u003e {\n        if self.check(kind) {\n            Ok(self.advance().unwrap())\n        } else {\n            let loc = self.current_location();\n            Err(Error::parser(\n                format!(\"expected {:?}, found {:?}\", kind, self.peek_kind()),\n                loc.line,\n                loc.column,\n            ))\n        }\n    }\n\n    fn expect_identifier(\u0026mut self) -\u003e Result\u003cString\u003e {\n        if let Some(TokenKind::Identifier(name)) = self.peek_kind() {\n            let name = name.clone();\n            self.advance();\n            Ok(name)\n        } else {\n            let loc = self.current_location();\n            Err(Error::parser(\n                format!(\"expected identifier, found {:?}\", self.peek_kind()),\n                loc.line,\n                loc.column,\n            ))\n        }\n    }\n\n    fn skip_newlines(\u0026mut self) {\n        while self.match_token(\u0026TokenKind::Newline) {}\n    }\n\n    fn skip_terminators(\u0026mut self) {\n        while self.match_token(\u0026TokenKind::Newline) || self.match_token(\u0026TokenKind::Semicolon) {}\n    }\n\n    fn can_start_expression(\u0026self) -\u003e bool {\n        self.peek_kind().map(|k| k.can_start_expression()).unwrap_or(false)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::lexer::Lexer;\n\n    fn parse(source: \u0026str) -\u003e Result\u003cProgram\u003e {\n        let mut lexer = Lexer::new(source);\n        let tokens = lexer.tokenize()?;\n        let mut parser = Parser::new(tokens);\n        parser.parse()\n    }\n\n    #[test]\n    fn test_simple_print() {\n        let program = parse(r#\"{ print \"hello\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_begin_end() {\n        let program = parse(r#\"BEGIN { x = 1 } END { print x }\"#).unwrap();\n        assert_eq!(program.rules.len(), 2);\n        assert!(matches!(program.rules[0].pattern, Some(Pattern::Begin)));\n        assert!(matches!(program.rules[1].pattern, Some(Pattern::End)));\n    }\n\n    #[test]\n    fn test_regex_pattern() {\n        let program = parse(r#\"/foo/ { print }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n        assert!(matches!(\n            \u0026program.rules[0].pattern,\n            Some(Pattern::Regex(r)) if r == \"foo\"\n        ));\n    }\n\n    #[test]\n    fn test_arithmetic() {\n        let program = parse(r#\"{ x = 1 + 2 * 3 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_function_def() {\n        let program = parse(r#\"function add(a, b) { return a + b }\"#).unwrap();\n        assert_eq!(program.functions.len(), 1);\n        assert_eq!(program.functions[0].name, \"add\");\n        assert_eq!(program.functions[0].params, vec![\"a\", \"b\"]);\n    }\n\n    #[test]\n    fn test_if_else() {\n        let program = parse(r#\"{ if (x) print 1; else print 2 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_while_loop() {\n        let program = parse(r#\"{ while (x \u003c 10) x++ }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_for_loop() {\n        let program = parse(r#\"{ for (i=0; i\u003c10; i++) print i }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_for_in_loop() {\n        let program = parse(r#\"{ for (k in a) print k }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_do_while() {\n        let program = parse(r#\"{ do { x++ } while (x \u003c 10) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_delete() {\n        let program = parse(r#\"{ delete a[1] }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_delete_array() {\n        let program = parse(r#\"{ delete a }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_break_continue() {\n        let program = parse(r#\"{ break; continue }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_next_nextfile() {\n        let program = parse(r#\"{ next } { nextfile }\"#).unwrap();\n        assert_eq!(program.rules.len(), 2);\n    }\n\n    #[test]\n    fn test_exit() {\n        let program = parse(r#\"{ exit 0 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_return() {\n        let program = parse(r#\"function f() { return 42 }\"#).unwrap();\n        assert_eq!(program.functions.len(), 1);\n    }\n\n    #[test]\n    fn test_printf() {\n        let program = parse(r#\"{ printf \"%d\", x }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_getline() {\n        let program = parse(r#\"{ getline x \u003c \"file\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_pipe_getline() {\n        let program = parse(r#\"{ \"cmd\" | getline x }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_output_redirect() {\n        let program = parse(r#\"{ print \"x\" \u003e \"file\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_output_append() {\n        let program = parse(r#\"{ print \"x\" \u003e\u003e \"file\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_output_pipe() {\n        let program = parse(r#\"{ print \"x\" | \"cmd\" }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_ternary() {\n        let program = parse(r#\"{ x = a ? b : c }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_logical_and_or() {\n        let program = parse(r#\"{ x = a \u0026\u0026 b || c }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_array_in() {\n        let program = parse(r#\"{ x = (1 in a) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_regex_match() {\n        let program = parse(r#\"{ x = ($0 ~ /foo/) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_concatenation() {\n        let program = parse(r#\"{ x = a b c }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_field_access() {\n        let program = parse(r#\"{ print $1, $NF, $(2+1) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_array_multi_index() {\n        let program = parse(r#\"{ a[1,2,3] = x }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_function_call() {\n        let program = parse(r#\"{ x = substr(s, 1, 5) }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_pre_increment() {\n        let program = parse(r#\"{ ++x; --y }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_post_increment() {\n        let program = parse(r#\"{ x++; y-- }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_compound_assign() {\n        let program = parse(r#\"{ x += 1; y -= 1; z *= 2; w /= 2; v %= 3; p ^= 2 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_range_pattern() {\n        let program = parse(r#\"/start/,/end/ { print }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n        assert!(matches!(\u0026program.rules[0].pattern, Some(Pattern::Range { .. })));\n    }\n\n    #[test]\n    fn test_expression_pattern() {\n        let program = parse(r#\"NR \u003e 5 { print }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_beginfile_endfile() {\n        let program = parse(r#\"BEGINFILE { x = 1 } ENDFILE { print }\"#).unwrap();\n        assert_eq!(program.rules.len(), 2);\n        assert!(matches!(program.rules[0].pattern, Some(Pattern::BeginFile)));\n        assert!(matches!(program.rules[1].pattern, Some(Pattern::EndFile)));\n    }\n\n    #[test]\n    fn test_empty_statement() {\n        let program = parse(r#\"{ ; ; ; }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_block_statement() {\n        let program = parse(r#\"{ { { x = 1 } } }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_multiple_rules() {\n        let program = parse(r#\"BEGIN { } { } END { }\"#).unwrap();\n        assert_eq!(program.rules.len(), 3);\n    }\n\n    #[test]\n    fn test_parenthesized_expression() {\n        let program = parse(r#\"{ x = (1 + 2) * 3 }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_unary_ops() {\n        let program = parse(r#\"{ x = -a + +b }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_not_operator() {\n        let program = parse(r#\"{ x = !a }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_comparison_ops() {\n        let program = parse(r#\"{ x = a \u003c b \u0026\u0026 b \u003c= c \u0026\u0026 c \u003e d \u0026\u0026 d \u003e= e \u0026\u0026 e == f \u0026\u0026 f != g }\"#).unwrap();\n        assert_eq!(program.rules.len(), 1);\n    }\n\n    #[test]\n    fn test_exponentiation() {\n        let program = parse(r#\"{ x = 2^3^4 }\"#).unwrap();  // right associative\n        assert_eq!(program.rules.len(), 1);\n    }\n}\n","traces":[{"line":12,"address":[2966608],"length":1,"stats":{"Line":10}},{"line":17,"address":[2967623,2967629,2966720],"length":1,"stats":{"Line":20}},{"line":18,"address":[2475667],"length":1,"stats":{"Line":22}},{"line":20,"address":[2966817,2966769],"length":1,"stats":{"Line":76}},{"line":22,"address":[2475728],"length":1,"stats":{"Line":30}},{"line":24,"address":[3241234,3241323],"length":1,"stats":{"Line":78}},{"line":25,"address":[2966970,2967331,2967605],"length":1,"stats":{"Line":6}},{"line":27,"address":[2476205,2475862,2475918],"length":1,"stats":{"Line":50}},{"line":29,"address":[3241687,3241984],"length":1,"stats":{"Line":7}},{"line":32,"address":[3241252],"length":1,"stats":{"Line":3}},{"line":36,"address":[3209498,3209506,3207600],"length":1,"stats":{"Line":3}},{"line":37,"address":[3207638],"length":1,"stats":{"Line":3}},{"line":38,"address":[2922026],"length":1,"stats":{"Line":3}},{"line":40,"address":[3207804],"length":1,"stats":{"Line":3}},{"line":41,"address":[2933609,2933675,2935120],"length":1,"stats":{"Line":6}},{"line":43,"address":[2933828],"length":1,"stats":{"Line":3}},{"line":44,"address":[2922588,2922654],"length":1,"stats":{"Line":6}},{"line":45,"address":[2443573,2444070,2443626],"length":1,"stats":{"Line":6}},{"line":46,"address":[2922913],"length":1,"stats":{"Line":3}},{"line":47,"address":[2934221],"length":1,"stats":{"Line":2}},{"line":50,"address":[2444088,2443585,2444697],"length":1,"stats":{"Line":6}},{"line":51,"address":[2923346],"length":1,"stats":{"Line":3}},{"line":53,"address":[2444692,2444242],"length":1,"stats":{"Line":3}},{"line":55,"address":[2444504],"length":1,"stats":{"Line":3}},{"line":56,"address":[2923540],"length":1,"stats":{"Line":3}},{"line":57,"address":[2934852],"length":1,"stats":{"Line":3}},{"line":64,"address":[2418908,2418914,2417472],"length":1,"stats":{"Line":31}},{"line":65,"address":[2907318],"length":1,"stats":{"Line":48}},{"line":68,"address":[2896090],"length":1,"stats":{"Line":48}},{"line":69,"address":[3181782],"length":1,"stats":{"Line":25}},{"line":70,"address":[3181792],"length":1,"stats":{"Line":50}},{"line":71,"address":[2419922,2417610],"length":1,"stats":{"Line":15}},{"line":72,"address":[3184276],"length":1,"stats":{"Line":5}},{"line":73,"address":[2898594],"length":1,"stats":{"Line":3}},{"line":79,"address":[3181759],"length":1,"stats":{"Line":10}},{"line":80,"address":[2417703],"length":1,"stats":{"Line":3}},{"line":81,"address":[2417713],"length":1,"stats":{"Line":3}},{"line":82,"address":[2907532,2909497],"length":1,"stats":{"Line":4}},{"line":83,"address":[2419812],"length":1,"stats":{"Line":4}},{"line":84,"address":[2898346],"length":1,"stats":{"Line":4}},{"line":90,"address":[2896225],"length":1,"stats":{"Line":8}},{"line":91,"address":[3182016],"length":1,"stats":{"Line":3}},{"line":92,"address":[3182026],"length":1,"stats":{"Line":3}},{"line":93,"address":[3183624,3182036],"length":1,"stats":{"Line":3}},{"line":94,"address":[2419556],"length":1,"stats":{"Line":3}},{"line":95,"address":[3183737],"length":1,"stats":{"Line":3}},{"line":101,"address":[2417799],"length":1,"stats":{"Line":8}},{"line":102,"address":[2896492],"length":1,"stats":{"Line":2}},{"line":103,"address":[2907766],"length":1,"stats":{"Line":2}},{"line":104,"address":[3183367,3182160],"length":1,"stats":{"Line":2}},{"line":105,"address":[2897866],"length":1,"stats":{"Line":2}},{"line":106,"address":[2909096],"length":1,"stats":{"Line":2}},{"line":113,"address":[2907729],"length":1,"stats":{"Line":6}},{"line":114,"address":[2908755,2907925],"length":1,"stats":{"Line":4}},{"line":115,"address":[2419044],"length":1,"stats":{"Line":4}},{"line":116,"address":[2419036],"length":1,"stats":{"Line":4}},{"line":123,"address":[2418041,2418183],"length":1,"stats":{"Line":5}},{"line":124,"address":[2418408],"length":1,"stats":{"Line":4}},{"line":127,"address":[2418875,2418506,2418460],"length":1,"stats":{"Line":8}},{"line":128,"address":[2418521,2418709],"length":1,"stats":{"Line":7}},{"line":130,"address":[2908307],"length":1,"stats":{"Line":1}},{"line":133,"address":[3182786],"length":1,"stats":{"Line":4}},{"line":134,"address":[2897086],"length":1,"stats":{"Line":3}},{"line":135,"address":[3182760],"length":1,"stats":{"Line":4}},{"line":141,"address":[2908384,2909629,2909566],"length":1,"stats":{"Line":5}},{"line":143,"address":[3194227,3194070],"length":1,"stats":{"Line":9}},{"line":144,"address":[2919860],"length":1,"stats":{"Line":5}},{"line":145,"address":[3194271],"length":1,"stats":{"Line":5}},{"line":148,"address":[3194324],"length":1,"stats":{"Line":5}},{"line":149,"address":[2430072],"length":1,"stats":{"Line":3}},{"line":150,"address":[2920855,2920144],"length":1,"stats":{"Line":3}},{"line":151,"address":[3195151],"length":1,"stats":{"Line":3}},{"line":152,"address":[2909332,2909188],"length":1,"stats":{"Line":6}},{"line":153,"address":[2920604],"length":1,"stats":{"Line":3}},{"line":157,"address":[2908713],"length":1,"stats":{"Line":4}},{"line":161,"address":[3195306,3194156],"length":1,"stats":{"Line":4}},{"line":164,"address":[3195603,3195540],"length":1,"stats":{"Line":8}},{"line":165,"address":[3195710],"length":1,"stats":{"Line":0}},{"line":166,"address":[2432079,2431288],"length":1,"stats":{"Line":0}},{"line":167,"address":[2431991],"length":1,"stats":{"Line":0}},{"line":168,"address":[2921895,2921657],"length":1,"stats":{"Line":0}},{"line":169,"address":[2431833],"length":1,"stats":{"Line":0}},{"line":173,"address":[2909961],"length":1,"stats":{"Line":4}},{"line":177,"address":[2910064,2910985,2911017],"length":1,"stats":{"Line":30}},{"line":178,"address":[2898838],"length":1,"stats":{"Line":3}},{"line":179,"address":[2898882],"length":1,"stats":{"Line":30}},{"line":180,"address":[3184660],"length":1,"stats":{"Line":33}},{"line":182,"address":[2899017],"length":1,"stats":{"Line":27}},{"line":184,"address":[2420600,2420481,2420544],"length":1,"stats":{"Line":113}},{"line":185,"address":[2420619,2420822],"length":1,"stats":{"Line":37}},{"line":186,"address":[2899385],"length":1,"stats":{"Line":6}},{"line":189,"address":[2420866,2420571,2421128],"length":1,"stats":{"Line":9}},{"line":191,"address":[3185237],"length":1,"stats":{"Line":3}},{"line":195,"address":[2448592,2451459,2451561],"length":1,"stats":{"Line":38}},{"line":196,"address":[3213461],"length":1,"stats":{"Line":37}},{"line":198,"address":[2939095],"length":1,"stats":{"Line":38}},{"line":201,"address":[2448699],"length":1,"stats":{"Line":37}},{"line":202,"address":[2448743],"length":1,"stats":{"Line":2}},{"line":203,"address":[2939185],"length":1,"stats":{"Line":2}},{"line":207,"address":[2448720],"length":1,"stats":{"Line":38}},{"line":208,"address":[2942711,2939242],"length":1,"stats":{"Line":4}},{"line":212,"address":[2448787],"length":1,"stats":{"Line":37}},{"line":213,"address":[2928093],"length":1,"stats":{"Line":4}},{"line":217,"address":[2939319],"length":1,"stats":{"Line":38}},{"line":218,"address":[2939410],"length":1,"stats":{"Line":3}},{"line":222,"address":[3213756],"length":1,"stats":{"Line":37}},{"line":223,"address":[2449030],"length":1,"stats":{"Line":7}},{"line":227,"address":[2939425],"length":1,"stats":{"Line":36}},{"line":228,"address":[2449083],"length":1,"stats":{"Line":2}},{"line":232,"address":[2939478],"length":1,"stats":{"Line":32}},{"line":233,"address":[2928300],"length":1,"stats":{"Line":3}},{"line":237,"address":[3213915],"length":1,"stats":{"Line":36}},{"line":238,"address":[2939653],"length":1,"stats":{"Line":3}},{"line":242,"address":[3214004],"length":1,"stats":{"Line":32}},{"line":243,"address":[2928478],"length":1,"stats":{"Line":3}},{"line":247,"address":[2449276],"length":1,"stats":{"Line":36}},{"line":248,"address":[3214215],"length":1,"stats":{"Line":2}},{"line":252,"address":[2928534],"length":1,"stats":{"Line":32}},{"line":253,"address":[2449477,2451902,2452209],"length":1,"stats":{"Line":5}},{"line":254,"address":[3216788,3216977],"length":1,"stats":{"Line":2}},{"line":256,"address":[2942389],"length":1,"stats":{"Line":1}},{"line":258,"address":[2931207],"length":1,"stats":{"Line":2}},{"line":262,"address":[2939887],"length":1,"stats":{"Line":36}},{"line":263,"address":[3216768,3216459,3214340],"length":1,"stats":{"Line":7}},{"line":264,"address":[3216655,3216466],"length":1,"stats":{"Line":3}},{"line":266,"address":[2930803],"length":1,"stats":{"Line":1}},{"line":268,"address":[2930885],"length":1,"stats":{"Line":3}},{"line":272,"address":[2928669],"length":1,"stats":{"Line":32}},{"line":273,"address":[2929124,2928738],"length":1,"stats":{"Line":2}},{"line":276,"address":[2930385,2929324,2929258],"length":1,"stats":{"Line":6}},{"line":277,"address":[2450475,2451473,2450182,2451551],"length":1,"stats":{"Line":4}},{"line":278,"address":[2941329,2941395],"length":1,"stats":{"Line":4}},{"line":279,"address":[2930177,2930430],"length":1,"stats":{"Line":0}},{"line":281,"address":[2930409,2930142,2930187],"length":1,"stats":{"Line":4}},{"line":282,"address":[3215985],"length":1,"stats":{"Line":2}},{"line":285,"address":[3215022,3214978],"length":1,"stats":{"Line":6}},{"line":288,"address":[2450318],"length":1,"stats":{"Line":2}},{"line":289,"address":[3215039],"length":1,"stats":{"Line":2}},{"line":290,"address":[2929447],"length":1,"stats":{"Line":2}},{"line":296,"address":[2449546],"length":1,"stats":{"Line":36}},{"line":297,"address":[2449683],"length":1,"stats":{"Line":17}},{"line":301,"address":[2928815],"length":1,"stats":{"Line":33}},{"line":302,"address":[2940216],"length":1,"stats":{"Line":3}},{"line":306,"address":[2449698,2449791],"length":1,"stats":{"Line":28}},{"line":307,"address":[2929046],"length":1,"stats":{"Line":7}},{"line":310,"address":[2459950,2458496,2459960],"length":1,"stats":{"Line":4}},{"line":311,"address":[2458552],"length":1,"stats":{"Line":5}},{"line":312,"address":[3223696],"length":1,"stats":{"Line":5}},{"line":313,"address":[2938402,2939367,2938336],"length":1,"stats":{"Line":10}},{"line":314,"address":[2949824],"length":1,"stats":{"Line":5}},{"line":316,"address":[3225013,3224228],"length":1,"stats":{"Line":5}},{"line":319,"address":[2459410],"length":1,"stats":{"Line":4}},{"line":320,"address":[2950570,2950158,2950118],"length":1,"stats":{"Line":12}},{"line":321,"address":[2938901],"length":1,"stats":{"Line":3}},{"line":322,"address":[3224746],"length":1,"stats":{"Line":3}},{"line":324,"address":[2459490],"length":1,"stats":{"Line":4}},{"line":327,"address":[2938963],"length":1,"stats":{"Line":5}},{"line":328,"address":[2459519],"length":1,"stats":{"Line":4}},{"line":329,"address":[2950201],"length":1,"stats":{"Line":5}},{"line":330,"address":[2938950],"length":1,"stats":{"Line":5}},{"line":335,"address":[3235584,3236678,3236684],"length":1,"stats":{"Line":3}},{"line":336,"address":[2470312],"length":1,"stats":{"Line":3}},{"line":337,"address":[2961386],"length":1,"stats":{"Line":3}},{"line":338,"address":[2961674,2962292,2961740],"length":1,"stats":{"Line":6}},{"line":339,"address":[2470938],"length":1,"stats":{"Line":3}},{"line":341,"address":[2471302,2470958],"length":1,"stats":{"Line":3}},{"line":343,"address":[2950893],"length":1,"stats":{"Line":3}},{"line":344,"address":[2471159],"length":1,"stats":{"Line":3}},{"line":350,"address":[2940672,2942195,2942242],"length":1,"stats":{"Line":7}},{"line":351,"address":[3226391],"length":1,"stats":{"Line":7}},{"line":354,"address":[2940983,2941167,2940895],"length":1,"stats":{"Line":21}},{"line":355,"address":[2461577],"length":1,"stats":{"Line":7}},{"line":356,"address":[3226681],"length":1,"stats":{"Line":7}},{"line":357,"address":[2941050],"length":1,"stats":{"Line":7}},{"line":359,"address":[2461677],"length":1,"stats":{"Line":7}},{"line":360,"address":[3227849,3226833],"length":1,"stats":{"Line":4}},{"line":361,"address":[2952736,2952670,2953418],"length":1,"stats":{"Line":8}},{"line":362,"address":[3227278],"length":1,"stats":{"Line":4}},{"line":363,"address":[2462208,2462698],"length":1,"stats":{"Line":4}},{"line":365,"address":[2941990],"length":1,"stats":{"Line":3}},{"line":366,"address":[2953142],"length":1,"stats":{"Line":3}},{"line":367,"address":[2953198],"length":1,"stats":{"Line":3}},{"line":374,"address":[2461715],"length":1,"stats":{"Line":7}},{"line":378,"address":[2940958,2942356],"length":1,"stats":{"Line":8}},{"line":379,"address":[3228006,3227927],"length":1,"stats":{"Line":7}},{"line":381,"address":[2462889],"length":1,"stats":{"Line":2}},{"line":383,"address":[3229820,3228186,3228120],"length":1,"stats":{"Line":18}},{"line":385,"address":[2942752,2942696],"length":1,"stats":{"Line":12}},{"line":386,"address":[2942737,2942757,2942969],"length":1,"stats":{"Line":22}},{"line":388,"address":[2954008],"length":1,"stats":{"Line":1}},{"line":390,"address":[2943034,2942947,2944167],"length":1,"stats":{"Line":24}},{"line":392,"address":[2463702,2463758],"length":1,"stats":{"Line":13}},{"line":393,"address":[3229113,3228901,3228881],"length":1,"stats":{"Line":24}},{"line":395,"address":[2943240],"length":1,"stats":{"Line":1}},{"line":397,"address":[2944165,2943443,2943533],"length":1,"stats":{"Line":24}},{"line":398,"address":[2954955],"length":1,"stats":{"Line":12}},{"line":400,"address":[2944141,2943711],"length":1,"stats":{"Line":12}},{"line":402,"address":[3229642],"length":1,"stats":{"Line":8}},{"line":403,"address":[2955188],"length":1,"stats":{"Line":6}},{"line":404,"address":[3229585],"length":1,"stats":{"Line":8}},{"line":405,"address":[2464437],"length":1,"stats":{"Line":8}},{"line":411,"address":[2474160,2475485,2475497],"length":1,"stats":{"Line":2}},{"line":412,"address":[2954000],"length":1,"stats":{"Line":2}},{"line":413,"address":[3239658],"length":1,"stats":{"Line":2}},{"line":414,"address":[2474399],"length":1,"stats":{"Line":2}},{"line":415,"address":[3240970,3239882],"length":1,"stats":{"Line":2}},{"line":416,"address":[3240062,3240968],"length":1,"stats":{"Line":2}},{"line":417,"address":[2475491,2474800],"length":1,"stats":{"Line":2}},{"line":418,"address":[2966240,2966174],"length":1,"stats":{"Line":4}},{"line":420,"address":[2955168],"length":1,"stats":{"Line":2}},{"line":421,"address":[2475307],"length":1,"stats":{"Line":2}},{"line":422,"address":[2966402],"length":1,"stats":{"Line":2}},{"line":427,"address":[2961174,2960000,2961180],"length":1,"stats":{"Line":13}},{"line":428,"address":[2948792],"length":1,"stats":{"Line":17}},{"line":431,"address":[2948811,2948901,2948867],"length":1,"stats":{"Line":42}},{"line":432,"address":[2949549,2949008],"length":1,"stats":{"Line":13}},{"line":433,"address":[3234886],"length":1,"stats":{"Line":6}},{"line":434,"address":[3234930],"length":1,"stats":{"Line":4}},{"line":439,"address":[2949551,2948886,2949905],"length":1,"stats":{"Line":9}},{"line":441,"address":[2470080],"length":1,"stats":{"Line":3}},{"line":442,"address":[2949714],"length":1,"stats":{"Line":6}},{"line":448,"address":[2963824,2965017,2965023],"length":1,"stats":{"Line":3}},{"line":449,"address":[2472872],"length":1,"stats":{"Line":3}},{"line":450,"address":[2964148,2964208],"length":1,"stats":{"Line":6}},{"line":452,"address":[2473256,2473197],"length":1,"stats":{"Line":6}},{"line":453,"address":[2473295,2473733],"length":1,"stats":{"Line":6}},{"line":456,"address":[2473697,2473275,2473321],"length":1,"stats":{"Line":6}},{"line":458,"address":[2473531],"length":1,"stats":{"Line":3}},{"line":459,"address":[2473460],"length":1,"stats":{"Line":3}},{"line":460,"address":[2964513],"length":1,"stats":{"Line":3}},{"line":466,"address":[2938992],"length":1,"stats":{"Line":16}},{"line":469,"address":[2448577],"length":1,"stats":{"Line":13}},{"line":472,"address":[3231860,3229840,3231993],"length":1,"stats":{"Line":16}},{"line":473,"address":[2955486],"length":1,"stats":{"Line":13}},{"line":475,"address":[2955800,2955863],"length":1,"stats":{"Line":14}},{"line":476,"address":[3230367,3230322],"length":1,"stats":{"Line":4}},{"line":477,"address":[2946317,2944759],"length":1,"stats":{"Line":2}},{"line":478,"address":[3231902,3230723,3230786],"length":1,"stats":{"Line":4}},{"line":479,"address":[3230952,3231888],"length":1,"stats":{"Line":2}},{"line":480,"address":[2957384],"length":1,"stats":{"Line":2}},{"line":481,"address":[3231263,3231415],"length":1,"stats":{"Line":4}},{"line":482,"address":[3231584,3231423],"length":1,"stats":{"Line":4}},{"line":483,"address":[2957208],"length":1,"stats":{"Line":2}},{"line":488,"address":[2955869],"length":1,"stats":{"Line":8}},{"line":491,"address":[2447201,2446032,2447256],"length":1,"stats":{"Line":16}},{"line":492,"address":[3210846],"length":1,"stats":{"Line":13}},{"line":494,"address":[2446261,2446324,2447196],"length":1,"stats":{"Line":14}},{"line":495,"address":[2936846,2936801],"length":1,"stats":{"Line":0}},{"line":496,"address":[3211270],"length":1,"stats":{"Line":0}},{"line":497,"address":[3211907],"length":1,"stats":{"Line":0}},{"line":498,"address":[2446787,2446932],"length":1,"stats":{"Line":0}},{"line":500,"address":[2446940],"length":1,"stats":{"Line":0}},{"line":505,"address":[2446330],"length":1,"stats":{"Line":6}},{"line":508,"address":[2938963,2938903,2937712],"length":1,"stats":{"Line":16}},{"line":509,"address":[2447326],"length":1,"stats":{"Line":13}},{"line":511,"address":[3212390,3213282,3212327],"length":1,"stats":{"Line":13}},{"line":512,"address":[2926817,2926862],"length":1,"stats":{"Line":2}},{"line":513,"address":[3212550],"length":1,"stats":{"Line":1}},{"line":514,"address":[2927539],"length":1,"stats":{"Line":1}},{"line":515,"address":[2448051,2448196],"length":1,"stats":{"Line":2}},{"line":517,"address":[2927370],"length":1,"stats":{"Line":1}},{"line":522,"address":[2926748],"length":1,"stats":{"Line":6}},{"line":525,"address":[3210781,3209520,3210747],"length":1,"stats":{"Line":16}},{"line":526,"address":[2923902],"length":1,"stats":{"Line":13}},{"line":528,"address":[2924197,2924260],"length":1,"stats":{"Line":12}},{"line":529,"address":[2445213,2445258],"length":1,"stats":{"Line":0}},{"line":530,"address":[2445971,2445298],"length":1,"stats":{"Line":0}},{"line":531,"address":[2924949],"length":1,"stats":{"Line":0}},{"line":532,"address":[3210342,3210286],"length":1,"stats":{"Line":0}},{"line":533,"address":[3210549],"length":1,"stats":{"Line":0}},{"line":538,"address":[3209914],"length":1,"stats":{"Line":6}},{"line":541,"address":[3221280,3222640,3223469],"length":1,"stats":{"Line":16}},{"line":542,"address":[2946926],"length":1,"stats":{"Line":13}},{"line":544,"address":[3221627,3221700],"length":1,"stats":{"Line":12}},{"line":545,"address":[2936084],"length":1,"stats":{"Line":6}},{"line":546,"address":[2936148,2937041,2937793],"length":1,"stats":{"Line":0}},{"line":547,"address":[2458326],"length":1,"stats":{"Line":0}},{"line":548,"address":[2458150,2457999],"length":1,"stats":{"Line":0}},{"line":549,"address":[2948772],"length":1,"stats":{"Line":0}},{"line":555,"address":[2936117,2936162],"length":1,"stats":{"Line":12}},{"line":556,"address":[2948284,2947529,2947509],"length":1,"stats":{"Line":0}},{"line":557,"address":[3222556],"length":1,"stats":{"Line":0}},{"line":558,"address":[2457398,2457247],"length":1,"stats":{"Line":0}},{"line":559,"address":[2947996],"length":1,"stats":{"Line":0}},{"line":565,"address":[2456854],"length":1,"stats":{"Line":6}},{"line":568,"address":[2952459,2952519,2951056],"length":1,"stats":{"Line":16}},{"line":569,"address":[2962350],"length":1,"stats":{"Line":13}},{"line":573,"address":[2472720],"length":1,"stats":{"Line":1}},{"line":574,"address":[2471573,2471646],"length":1,"stats":{"Line":12}},{"line":575,"address":[2951392,2951451],"length":1,"stats":{"Line":6}},{"line":576,"address":[2471729],"length":1,"stats":{"Line":1}},{"line":577,"address":[2471711,2471783,2471746],"length":1,"stats":{"Line":12}},{"line":578,"address":[3237137],"length":1,"stats":{"Line":0}},{"line":579,"address":[3237154,3237191,3237119],"length":1,"stats":{"Line":13}},{"line":580,"address":[2962799],"length":1,"stats":{"Line":1}},{"line":581,"address":[3237237,3237165,3237200,3237321],"length":1,"stats":{"Line":14}},{"line":582,"address":[2951581],"length":1,"stats":{"Line":3}},{"line":583,"address":[2951595,2951563],"length":1,"stats":{"Line":12}},{"line":584,"address":[2471951],"length":1,"stats":{"Line":0}},{"line":590,"address":[2951701],"length":1,"stats":{"Line":1}},{"line":591,"address":[2952359],"length":1,"stats":{"Line":1}},{"line":592,"address":[3237660,3237812],"length":1,"stats":{"Line":2}},{"line":593,"address":[2963436],"length":1,"stats":{"Line":1}},{"line":594,"address":[2952183],"length":1,"stats":{"Line":1}},{"line":599,"address":[2471887],"length":1,"stats":{"Line":7}},{"line":602,"address":[2959104],"length":1,"stats":{"Line":3}},{"line":603,"address":[2947876,2948727],"length":1,"stats":{"Line":8}},{"line":604,"address":[3234203,3233566],"length":1,"stats":{"Line":2}},{"line":605,"address":[2468998],"length":1,"stats":{"Line":2}},{"line":606,"address":[2948550,2947896],"length":1,"stats":{"Line":5}},{"line":607,"address":[3234020,3233651],"length":1,"stats":{"Line":2}},{"line":608,"address":[3234107],"length":1,"stats":{"Line":2}},{"line":609,"address":[2959373,2959245,2959631],"length":1,"stats":{"Line":14}},{"line":610,"address":[2948115,2948192],"length":1,"stats":{"Line":2}},{"line":611,"address":[2468640],"length":1,"stats":{"Line":2}},{"line":613,"address":[2468445],"length":1,"stats":{"Line":3}},{"line":618,"address":[3220656],"length":1,"stats":{"Line":21}},{"line":619,"address":[2935025],"length":1,"stats":{"Line":21}},{"line":622,"address":[2454083,2452480,2454144],"length":1,"stats":{"Line":21}},{"line":623,"address":[2931758],"length":1,"stats":{"Line":21}},{"line":626,"address":[2943401,2943328],"length":1,"stats":{"Line":104}},{"line":627,"address":[2943433,2943492],"length":1,"stats":{"Line":60}},{"line":628,"address":[2452970],"length":1,"stats":{"Line":21}},{"line":629,"address":[2943466,2943501,2943538],"length":1,"stats":{"Line":73}},{"line":630,"address":[3217914],"length":1,"stats":{"Line":3}},{"line":631,"address":[3217896,3217931,3217968],"length":1,"stats":{"Line":71}},{"line":632,"address":[2932312],"length":1,"stats":{"Line":3}},{"line":633,"address":[2943593,2943558,2943630],"length":1,"stats":{"Line":107}},{"line":634,"address":[2943622],"length":1,"stats":{"Line":3}},{"line":635,"address":[2453122,2453159,2453090],"length":1,"stats":{"Line":107}},{"line":636,"address":[3218049],"length":1,"stats":{"Line":2}},{"line":637,"address":[2943716,2943679,2943647],"length":1,"stats":{"Line":107}},{"line":638,"address":[2943708],"length":1,"stats":{"Line":2}},{"line":639,"address":[2932472,2932458,2932426],"length":1,"stats":{"Line":154}},{"line":640,"address":[2932474],"length":1,"stats":{"Line":2}},{"line":642,"address":[3218112],"length":1,"stats":{"Line":58}},{"line":645,"address":[2453232],"length":1,"stats":{"Line":21}},{"line":646,"address":[2944645,2943804,2943878],"length":1,"stats":{"Line":27}},{"line":647,"address":[2933259],"length":1,"stats":{"Line":14}},{"line":648,"address":[2944334,2944182],"length":1,"stats":{"Line":34}},{"line":650,"address":[3218726],"length":1,"stats":{"Line":20}},{"line":655,"address":[2453297],"length":1,"stats":{"Line":58}},{"line":658,"address":[2929616,2931769,2931636],"length":1,"stats":{"Line":22}},{"line":659,"address":[2918382],"length":1,"stats":{"Line":22}},{"line":661,"address":[2439702,2439765],"length":1,"stats":{"Line":105}},{"line":662,"address":[2930143,2930098],"length":1,"stats":{"Line":6}},{"line":663,"address":[2920477,2918919],"length":1,"stats":{"Line":3}},{"line":664,"address":[2920414,2919298,2919235],"length":1,"stats":{"Line":6}},{"line":665,"address":[2930728,2931664],"length":1,"stats":{"Line":3}},{"line":666,"address":[2441242],"length":1,"stats":{"Line":3}},{"line":667,"address":[2919927,2919775],"length":1,"stats":{"Line":6}},{"line":668,"address":[3205744,3205583],"length":1,"stats":{"Line":6}},{"line":669,"address":[2931368],"length":1,"stats":{"Line":3}},{"line":674,"address":[2930029],"length":1,"stats":{"Line":57}},{"line":677,"address":[3245127,3243936,3245187],"length":1,"stats":{"Line":24}},{"line":678,"address":[3243966],"length":1,"stats":{"Line":24}},{"line":680,"address":[3245122,3244167,3244230],"length":1,"stats":{"Line":108}},{"line":681,"address":[2969921,2969966],"length":1,"stats":{"Line":4}},{"line":682,"address":[2970006],"length":1,"stats":{"Line":2}},{"line":683,"address":[2479485],"length":1,"stats":{"Line":2}},{"line":684,"address":[3244701,3244850],"length":1,"stats":{"Line":4}},{"line":686,"address":[2959210],"length":1,"stats":{"Line":2}},{"line":691,"address":[2478714],"length":1,"stats":{"Line":48}},{"line":694,"address":[2959664,2960915,2960855],"length":1,"stats":{"Line":24}},{"line":695,"address":[2959694],"length":1,"stats":{"Line":24}},{"line":697,"address":[3245543,3246498,3245606],"length":1,"stats":{"Line":108}},{"line":698,"address":[2971297,2971342],"length":1,"stats":{"Line":4}},{"line":699,"address":[2971382],"length":1,"stats":{"Line":2}},{"line":700,"address":[3246403],"length":1,"stats":{"Line":2}},{"line":701,"address":[2480531,2480676],"length":1,"stats":{"Line":4}},{"line":703,"address":[3246234],"length":1,"stats":{"Line":2}},{"line":708,"address":[2480074],"length":1,"stats":{"Line":57}},{"line":711,"address":[2956992,2958219,2958253],"length":1,"stats":{"Line":24}},{"line":712,"address":[3242670],"length":1,"stats":{"Line":24}},{"line":716,"address":[2968644,2968581],"length":1,"stats":{"Line":101}},{"line":717,"address":[2957500,2957455],"length":1,"stats":{"Line":4}},{"line":718,"address":[2477682,2478355],"length":1,"stats":{"Line":2}},{"line":719,"address":[3243717],"length":1,"stats":{"Line":2}},{"line":720,"address":[2477892,2477948],"length":1,"stats":{"Line":4}},{"line":721,"address":[2958021],"length":1,"stats":{"Line":2}},{"line":726,"address":[2477528],"length":1,"stats":{"Line":48}},{"line":730,"address":[2461035,2459984,2461223],"length":1,"stats":{"Line":38}},{"line":731,"address":[2460014],"length":1,"stats":{"Line":27}},{"line":734,"address":[2460519,2460310,2460373],"length":1,"stats":{"Line":101}},{"line":736,"address":[2460448],"length":1,"stats":{"Line":2}},{"line":737,"address":[2939875],"length":1,"stats":{"Line":3}},{"line":739,"address":[2951151],"length":1,"stats":{"Line":2}},{"line":740,"address":[2460529,2460574],"length":1,"stats":{"Line":5}},{"line":741,"address":[2951280],"length":1,"stats":{"Line":3}},{"line":744,"address":[3225764,3225676],"length":1,"stats":{"Line":3}},{"line":745,"address":[2940141],"length":1,"stats":{"Line":2}},{"line":746,"address":[2951429],"length":1,"stats":{"Line":2}},{"line":747,"address":[3225864],"length":1,"stats":{"Line":2}},{"line":749,"address":[2940098],"length":1,"stats":{"Line":1}},{"line":752,"address":[2940518],"length":1,"stats":{"Line":2}},{"line":753,"address":[2940312],"length":1,"stats":{"Line":2}},{"line":754,"address":[2460934],"length":1,"stats":{"Line":3}},{"line":759,"address":[2951189],"length":1,"stats":{"Line":0}},{"line":763,"address":[3225437],"length":1,"stats":{"Line":56}},{"line":766,"address":[2911696,2913885,2913056],"length":1,"stats":{"Line":38}},{"line":767,"address":[3186110],"length":1,"stats":{"Line":27}},{"line":769,"address":[3186500,3186427],"length":1,"stats":{"Line":98}},{"line":770,"address":[2912148],"length":1,"stats":{"Line":56}},{"line":771,"address":[2913105,2912212,2913857],"length":1,"stats":{"Line":8}},{"line":772,"address":[2913748],"length":1,"stats":{"Line":4}},{"line":773,"address":[2913409,2913564],"length":1,"stats":{"Line":8}},{"line":774,"address":[2913572],"length":1,"stats":{"Line":4}},{"line":780,"address":[2900962,2900917],"length":1,"stats":{"Line":100}},{"line":781,"address":[2422471,2423186,2422435],"length":1,"stats":{"Line":4}},{"line":782,"address":[2912972],"length":1,"stats":{"Line":1}},{"line":783,"address":[2912633,2912788],"length":1,"stats":{"Line":4}},{"line":784,"address":[3187180],"length":1,"stats":{"Line":1}},{"line":790,"address":[2900968],"length":1,"stats":{"Line":44}},{"line":793,"address":[2455658,2454176,2455603],"length":1,"stats":{"Line":38}},{"line":794,"address":[2933486],"length":1,"stats":{"Line":27}},{"line":796,"address":[2934900],"length":1,"stats":{"Line":6}},{"line":797,"address":[3219408,3219335],"length":1,"stats":{"Line":94}},{"line":798,"address":[2945056,2945115],"length":1,"stats":{"Line":61}},{"line":799,"address":[2933843],"length":1,"stats":{"Line":3}},{"line":800,"address":[2945124,2945089,2945161],"length":1,"stats":{"Line":100}},{"line":801,"address":[2933889],"length":1,"stats":{"Line":8}},{"line":802,"address":[2945170,2945135,2945207],"length":1,"stats":{"Line":95}},{"line":803,"address":[2945199],"length":1,"stats":{"Line":3}},{"line":804,"address":[3219565,3219600,3219637],"length":1,"stats":{"Line":92}},{"line":805,"address":[2945245],"length":1,"stats":{"Line":2}},{"line":806,"address":[2454753,2454716,2454837,2454681],"length":1,"stats":{"Line":99}},{"line":807,"address":[2945291],"length":1,"stats":{"Line":4}},{"line":808,"address":[2934009,2934041],"length":1,"stats":{"Line":94}},{"line":809,"address":[2945375],"length":1,"stats":{"Line":2}},{"line":814,"address":[2454865],"length":1,"stats":{"Line":3}},{"line":815,"address":[2934805],"length":1,"stats":{"Line":5}},{"line":816,"address":[2945722,2945874],"length":1,"stats":{"Line":7}},{"line":817,"address":[2934618],"length":1,"stats":{"Line":4}},{"line":818,"address":[2455335],"length":1,"stats":{"Line":4}},{"line":823,"address":[2934047],"length":1,"stats":{"Line":42}},{"line":826,"address":[3193940,3194000,3192752],"length":1,"stats":{"Line":18}},{"line":827,"address":[2918398],"length":1,"stats":{"Line":16}},{"line":831,"address":[2918599,2918655,2919551],"length":1,"stats":{"Line":105}},{"line":832,"address":[2918758,2918738],"length":1,"stats":{"Line":4}},{"line":833,"address":[2919062,2919139],"length":1,"stats":{"Line":4}},{"line":834,"address":[2908192],"length":1,"stats":{"Line":2}},{"line":835,"address":[2429157],"length":1,"stats":{"Line":2}},{"line":837,"address":[3193671],"length":1,"stats":{"Line":2}},{"line":842,"address":[2918661],"length":1,"stats":{"Line":41}},{"line":845,"address":[3239424],"length":1,"stats":{"Line":40}},{"line":846,"address":[2953905,2953785],"length":1,"stats":{"Line":37}},{"line":847,"address":[2965171,2965104],"length":1,"stats":{"Line":77}},{"line":848,"address":[3239481],"length":1,"stats":{"Line":40}},{"line":859,"address":[2474124],"length":1,"stats":{"Line":0}},{"line":863,"address":[2920592,2921857,2921917],"length":1,"stats":{"Line":18}},{"line":864,"address":[2441566],"length":1,"stats":{"Line":16}},{"line":866,"address":[2442774],"length":1,"stats":{"Line":3}},{"line":867,"address":[3206471,3206544],"length":1,"stats":{"Line":58}},{"line":868,"address":[2442013,2441929,2441870],"length":1,"stats":{"Line":55}},{"line":869,"address":[2441921],"length":1,"stats":{"Line":3}},{"line":870,"address":[2920993,2920961],"length":1,"stats":{"Line":87}},{"line":871,"address":[2442005],"length":1,"stats":{"Line":4}},{"line":876,"address":[3206747],"length":1,"stats":{"Line":3}},{"line":877,"address":[2933021],"length":1,"stats":{"Line":3}},{"line":878,"address":[2932674,2932826],"length":1,"stats":{"Line":6}},{"line":879,"address":[3207218],"length":1,"stats":{"Line":3}},{"line":880,"address":[2442511],"length":1,"stats":{"Line":3}},{"line":885,"address":[2441941],"length":1,"stats":{"Line":38}},{"line":888,"address":[3232080,3233391,3233451],"length":1,"stats":{"Line":18}},{"line":889,"address":[3232110],"length":1,"stats":{"Line":16}},{"line":891,"address":[3233386],"length":1,"stats":{"Line":4}},{"line":892,"address":[2957927,2958000],"length":1,"stats":{"Line":51}},{"line":893,"address":[2946827,2946768],"length":1,"stats":{"Line":43}},{"line":894,"address":[2958083],"length":1,"stats":{"Line":3}},{"line":895,"address":[2467199,2467355,2467271,2467234],"length":1,"stats":{"Line":55}},{"line":896,"address":[3232513],"length":1,"stats":{"Line":2}},{"line":897,"address":[2467245,2467277],"length":1,"stats":{"Line":57}},{"line":898,"address":[2467347],"length":1,"stats":{"Line":2}},{"line":903,"address":[2958249],"length":1,"stats":{"Line":3}},{"line":904,"address":[2958907],"length":1,"stats":{"Line":4}},{"line":905,"address":[2467834,2467686],"length":1,"stats":{"Line":6}},{"line":906,"address":[3233104],"length":1,"stats":{"Line":3}},{"line":907,"address":[2947467],"length":1,"stats":{"Line":3}},{"line":912,"address":[3232533],"length":1,"stats":{"Line":10}},{"line":915,"address":[2915212,2915268,2913920],"length":1,"stats":{"Line":18}},{"line":916,"address":[3188334],"length":1,"stats":{"Line":16}},{"line":919,"address":[2902989,2903052],"length":1,"stats":{"Line":47}},{"line":920,"address":[2903127,2903172],"length":1,"stats":{"Line":8}},{"line":921,"address":[2915240,2914476],"length":1,"stats":{"Line":4}},{"line":922,"address":[2915118],"length":1,"stats":{"Line":4}},{"line":923,"address":[2903672,2903523],"length":1,"stats":{"Line":8}},{"line":925,"address":[3189328],"length":1,"stats":{"Line":4}},{"line":930,"address":[2914322],"length":1,"stats":{"Line":9}},{"line":933,"address":[3189696,3190811,3190779],"length":1,"stats":{"Line":18}},{"line":934,"address":[2915350],"length":1,"stats":{"Line":17}},{"line":936,"address":[2915426],"length":1,"stats":{"Line":18}},{"line":937,"address":[2427905,2425518],"length":1,"stats":{"Line":2}},{"line":938,"address":[2428278],"length":1,"stats":{"Line":2}},{"line":940,"address":[2428124],"length":1,"stats":{"Line":2}},{"line":945,"address":[2904183],"length":1,"stats":{"Line":17}},{"line":946,"address":[2917407,2915569],"length":1,"stats":{"Line":3}},{"line":947,"address":[2906541],"length":1,"stats":{"Line":3}},{"line":949,"address":[2917636],"length":1,"stats":{"Line":3}},{"line":954,"address":[3189930],"length":1,"stats":{"Line":18}},{"line":955,"address":[3191300,3190052],"length":1,"stats":{"Line":2}},{"line":956,"address":[3191698],"length":1,"stats":{"Line":2}},{"line":958,"address":[3191529],"length":1,"stats":{"Line":2}},{"line":963,"address":[3190029],"length":1,"stats":{"Line":40}},{"line":964,"address":[2905169,2904503],"length":1,"stats":{"Line":3}},{"line":965,"address":[3191046,3191215],"length":1,"stats":{"Line":6}},{"line":968,"address":[2425789],"length":1,"stats":{"Line":21}},{"line":969,"address":[2904596,2904673],"length":1,"stats":{"Line":2}},{"line":970,"address":[3190550,3190716],"length":1,"stats":{"Line":4}},{"line":973,"address":[2915848],"length":1,"stats":{"Line":40}},{"line":976,"address":[2924990,2924606,2922224],"length":1,"stats":{"Line":21}},{"line":977,"address":[3196638],"length":1,"stats":{"Line":40}},{"line":980,"address":[2911215,2911288],"length":1,"stats":{"Line":7}},{"line":982,"address":[2922584,2924985],"length":1,"stats":{"Line":12}},{"line":983,"address":[2913650,2911371],"length":1,"stats":{"Line":6}},{"line":984,"address":[2432519,2434727,2434062,2432657],"length":1,"stats":{"Line":55}},{"line":985,"address":[3197172,3199207],"length":1,"stats":{"Line":4}},{"line":986,"address":[2432806,2432668],"length":1,"stats":{"Line":36}},{"line":988,"address":[2922998,2923024],"length":1,"stats":{"Line":36}},{"line":989,"address":[2923189,2923082,2924612,2924695],"length":1,"stats":{"Line":36}},{"line":990,"address":[2912407,2912344],"length":1,"stats":{"Line":36}},{"line":991,"address":[2433591,2434181],"length":1,"stats":{"Line":4}},{"line":993,"address":[2434145,2433617,2433556],"length":1,"stats":{"Line":34}},{"line":994,"address":[2924002,2924217,2924201],"length":1,"stats":{"Line":19}},{"line":995,"address":[2433756],"length":1,"stats":{"Line":19}},{"line":996,"address":[2433812],"length":1,"stats":{"Line":17}},{"line":1000,"address":[2924732,2923104],"length":1,"stats":{"Line":0}},{"line":1007,"address":[3197302],"length":1,"stats":{"Line":26}},{"line":1010,"address":[2911676,2911024,2911647],"length":1,"stats":{"Line":26}},{"line":1011,"address":[2911062],"length":1,"stats":{"Line":42}},{"line":1012,"address":[2899844],"length":1,"stats":{"Line":4}},{"line":1013,"address":[2911144,2911221],"length":1,"stats":{"Line":4}},{"line":1014,"address":[2911435,2911584],"length":1,"stats":{"Line":8}},{"line":1017,"address":[3185480],"length":1,"stats":{"Line":36}},{"line":1020,"address":[3199456,3200108,3200114],"length":1,"stats":{"Line":39}},{"line":1021,"address":[3199494],"length":1,"stats":{"Line":36}},{"line":1024,"address":[2435110,2435002],"length":1,"stats":{"Line":45}},{"line":1025,"address":[2914042],"length":1,"stats":{"Line":6}},{"line":1026,"address":[3199710],"length":1,"stats":{"Line":6}},{"line":1027,"address":[3199736],"length":1,"stats":{"Line":6}},{"line":1031,"address":[3199857,3199785,3199616],"length":1,"stats":{"Line":108}},{"line":1032,"address":[2925493],"length":1,"stats":{"Line":6}},{"line":1033,"address":[2914251],"length":1,"stats":{"Line":6}},{"line":1034,"address":[2925581],"length":1,"stats":{"Line":6}},{"line":1038,"address":[2435244,2435567,2435639],"length":1,"stats":{"Line":96}},{"line":1039,"address":[2435659],"length":1,"stats":{"Line":2}},{"line":1040,"address":[2925857],"length":1,"stats":{"Line":3}},{"line":1041,"address":[3200307],"length":1,"stats":{"Line":3}},{"line":1045,"address":[2926066,2925762,2926110],"length":1,"stats":{"Line":148}},{"line":1046,"address":[2926130],"length":1,"stats":{"Line":29}},{"line":1047,"address":[3200544],"length":1,"stats":{"Line":55}},{"line":1050,"address":[2436037],"length":1,"stats":{"Line":32}},{"line":1051,"address":[2926408],"length":1,"stats":{"Line":16}},{"line":1052,"address":[2436341,2436271],"length":1,"stats":{"Line":32}},{"line":1053,"address":[2915317,2915884,2915280],"length":1,"stats":{"Line":33}},{"line":1054,"address":[2915567],"length":1,"stats":{"Line":18}},{"line":1055,"address":[2915611],"length":1,"stats":{"Line":12}},{"line":1058,"address":[2926556,2927150,2927573],"length":1,"stats":{"Line":27}},{"line":1059,"address":[2916166],"length":1,"stats":{"Line":19}},{"line":1060,"address":[2927318],"length":1,"stats":{"Line":19}},{"line":1061,"address":[3201758],"length":1,"stats":{"Line":20}},{"line":1066,"address":[2436084],"length":1,"stats":{"Line":42}},{"line":1070,"address":[2435909],"length":1,"stats":{"Line":6}},{"line":1071,"address":[2437473,2438541,2438501],"length":1,"stats":{"Line":6}},{"line":1072,"address":[2928807],"length":1,"stats":{"Line":2}},{"line":1073,"address":[3203213],"length":1,"stats":{"Line":2}},{"line":1074,"address":[2438639],"length":1,"stats":{"Line":2}},{"line":1076,"address":[2917492],"length":1,"stats":{"Line":1}},{"line":1079,"address":[3203945,3203439,3203373,3203457],"length":1,"stats":{"Line":8}},{"line":1080,"address":[2929296,2929578,2929088],"length":1,"stats":{"Line":5}},{"line":1082,"address":[2929061],"length":1,"stats":{"Line":1}},{"line":1085,"address":[2929185],"length":1,"stats":{"Line":3}},{"line":1086,"address":[2929113],"length":1,"stats":{"Line":3}},{"line":1087,"address":[2438924],"length":1,"stats":{"Line":2}},{"line":1093,"address":[2437446],"length":1,"stats":{"Line":6}},{"line":1094,"address":[2916719],"length":1,"stats":{"Line":6}},{"line":1095,"address":[2928689,2928279,2928342],"length":1,"stats":{"Line":8}},{"line":1096,"address":[2917231],"length":1,"stats":{"Line":4}},{"line":1099,"address":[2437695],"length":1,"stats":{"Line":0}},{"line":1100,"address":[3202135],"length":1,"stats":{"Line":0}},{"line":1108,"address":[2960944],"length":1,"stats":{"Line":47}},{"line":1109,"address":[2207376,2207384],"length":1,"stats":{"Line":105}},{"line":1112,"address":[2931616],"length":1,"stats":{"Line":31}},{"line":1113,"address":[2942894],"length":1,"stats":{"Line":48}},{"line":1114,"address":[2942914],"length":1,"stats":{"Line":31}},{"line":1115,"address":[2931666],"length":1,"stats":{"Line":129}},{"line":1116,"address":[2452445],"length":1,"stats":{"Line":31}},{"line":1119,"address":[2959568],"length":1,"stats":{"Line":48}},{"line":1120,"address":[2479689],"length":1,"stats":{"Line":30}},{"line":1123,"address":[2955392],"length":1,"stats":{"Line":38}},{"line":1124,"address":[2884480,2884512],"length":1,"stats":{"Line":106}},{"line":1127,"address":[2968080],"length":1,"stats":{"Line":15}},{"line":1128,"address":[2956830,2956934],"length":1,"stats":{"Line":40}},{"line":1129,"address":[2968200,2968108,2968194],"length":1,"stats":{"Line":40}},{"line":1131,"address":[3242612,3242623,3242520],"length":1,"stats":{"Line":41}},{"line":1134,"address":[2420176],"length":1,"stats":{"Line":34}},{"line":1135,"address":[2898769,2898755],"length":1,"stats":{"Line":58}},{"line":1136,"address":[2420216],"length":1,"stats":{"Line":6}},{"line":1137,"address":[2420221],"length":1,"stats":{"Line":6}},{"line":1139,"address":[2910028],"length":1,"stats":{"Line":47}},{"line":1143,"address":[2956384],"length":1,"stats":{"Line":3}},{"line":1144,"address":[2956748,2956427],"length":1,"stats":{"Line":30}},{"line":1145,"address":[2476896],"length":1,"stats":{"Line":26}},{"line":1147,"address":[2476594],"length":1,"stats":{"Line":0}},{"line":1148,"address":[2967976],"length":1,"stats":{"Line":0}},{"line":1149,"address":[3242134],"length":1,"stats":{"Line":0}},{"line":1156,"address":[3220752,3221262,3221256],"length":1,"stats":{"Line":4}},{"line":1157,"address":[2946704,2946406],"length":1,"stats":{"Line":4}},{"line":1158,"address":[2935462],"length":1,"stats":{"Line":4}},{"line":1159,"address":[2456167],"length":1,"stats":{"Line":4}},{"line":1160,"address":[2946795],"length":1,"stats":{"Line":5}},{"line":1162,"address":[3220848],"length":1,"stats":{"Line":0}},{"line":1163,"address":[2456088],"length":1,"stats":{"Line":0}},{"line":1164,"address":[3220884],"length":1,"stats":{"Line":0}},{"line":1171,"address":[2441488],"length":1,"stats":{"Line":34}},{"line":1172,"address":[2441507],"length":1,"stats":{"Line":28}},{"line":1175,"address":[2935040],"length":1,"stats":{"Line":3}},{"line":1176,"address":[2946323],"length":1,"stats":{"Line":6}},{"line":1179,"address":[2466784],"length":1,"stats":{"Line":17}},{"line":1180,"address":[2873184,2873193],"length":1,"stats":{"Line":43}}],"covered":582,"coverable":619},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","src","value.rs"],"content":"use std::borrow::Cow;\nuse std::cmp::Ordering;\nuse std::fmt;\n\n/// AWK value type with dynamic typing and automatic coercion\n///\n/// AWK has a unique type system where values can be strings, numbers, or\n/// \"numeric strings\" (strings that look like numbers). This enum captures\n/// all three cases.\n///\n/// # Examples\n///\n/// ```\n/// use rawk::Value;\n///\n/// // Numbers\n/// let num = Value::Number(42.0);\n/// assert_eq!(num.to_number(), 42.0);\n/// assert_eq!(num.to_string_val(), \"42\");\n///\n/// // Strings\n/// let s = Value::from_string(\"hello\".to_string());\n/// assert_eq!(s.to_string_val(), \"hello\");\n/// assert_eq!(s.to_number(), 0.0);  // Non-numeric string coerces to 0\n///\n/// // Numeric strings\n/// let ns = Value::from_string(\"123\".to_string());\n/// assert_eq!(ns.to_number(), 123.0);\n/// assert_eq!(ns.to_string_val(), \"123\");\n///\n/// // Truthiness\n/// assert!(Value::Number(1.0).is_truthy());\n/// assert!(!Value::Number(0.0).is_truthy());\n/// assert!(Value::from_string(\"hello\".to_string()).is_truthy());\n/// assert!(!Value::from_string(\"\".to_string()).is_truthy());\n/// ```\n#[derive(Debug, Clone)]\npub enum Value {\n    /// Uninitialized value - coerces to \"\" or 0 depending on context\n    Uninitialized,\n    /// Numeric value\n    Number(f64),\n    /// String value\n    String(String),\n    /// Numeric string - a string that looks like a number\n    /// (used for comparison semantics)\n    NumericString(String, f64),\n}\n\nimpl Default for Value {\n    fn default() -\u003e Self {\n        Value::Uninitialized\n    }\n}\n\nimpl Value {\n    /// Create a new string value, detecting if it's a numeric string\n    #[inline]\n    pub fn from_string(s: String) -\u003e Self {\n        if let Some(num) = parse_numeric_string(\u0026s) {\n            Value::NumericString(s, num)\n        } else {\n            Value::String(s)\n        }\n    }\n\n    /// Create a numeric value\n    #[inline]\n    pub fn from_number(n: f64) -\u003e Self {\n        Value::Number(n)\n    }\n\n    /// Check if this value is \"true\" in boolean context\n    /// - Uninitialized is false\n    /// - Number 0 is false\n    /// - Empty string is false\n    /// - Everything else is true\n    #[inline]\n    pub fn is_truthy(\u0026self) -\u003e bool {\n        match self {\n            Value::Uninitialized =\u003e false,\n            Value::Number(n) =\u003e *n != 0.0,\n            Value::String(s) =\u003e !s.is_empty(),\n            Value::NumericString(s, _) =\u003e !s.is_empty(),\n        }\n    }\n\n    /// Coerce to numeric value\n    #[inline]\n    pub fn to_number(\u0026self) -\u003e f64 {\n        match self {\n            Value::Uninitialized =\u003e 0.0,\n            Value::Number(n) =\u003e *n,\n            Value::String(s) =\u003e parse_leading_number(s),\n            Value::NumericString(_, n) =\u003e *n,\n        }\n    }\n\n    /// Coerce to string value\n    #[inline]\n    pub fn to_string_val(\u0026self) -\u003e String {\n        self.to_string_with_format(\"%.6g\")\n    }\n\n    /// Get string as Cow to avoid allocation when possible\n    #[inline]\n    pub fn as_str(\u0026self) -\u003e Cow\u003c'_, str\u003e {\n        match self {\n            Value::Uninitialized =\u003e Cow::Borrowed(\"\"),\n            Value::Number(n) =\u003e Cow::Owned(format_number(*n, \"%.6g\")),\n            Value::String(s) =\u003e Cow::Borrowed(s),\n            Value::NumericString(s, _) =\u003e Cow::Borrowed(s),\n        }\n    }\n\n    /// Coerce to string with specific format (for OFMT/CONVFMT)\n    pub fn to_string_with_format(\u0026self, format: \u0026str) -\u003e String {\n        match self {\n            Value::Uninitialized =\u003e String::new(),\n            Value::Number(n) =\u003e format_number(*n, format),\n            Value::String(s) =\u003e s.clone(),\n            Value::NumericString(s, _) =\u003e s.clone(),\n        }\n    }\n\n    /// Check if this value is definitely numeric\n    #[inline]\n    pub fn is_numeric(\u0026self) -\u003e bool {\n        matches!(self, Value::Number(_))\n    }\n\n    /// Check if this value is a numeric string\n    #[inline]\n    pub fn is_numeric_string(\u0026self) -\u003e bool {\n        matches!(self, Value::NumericString(_, _))\n    }\n\n    /// Check if this value should compare as a number\n    #[inline]\n    pub fn compares_as_number(\u0026self) -\u003e bool {\n        matches!(self, Value::Number(_) | Value::NumericString(_, _) | Value::Uninitialized)\n    }\n}\n\nimpl fmt::Display for Value {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Value::Uninitialized =\u003e Ok(()),\n            Value::Number(n) =\u003e write!(f, \"{}\", format_number(*n, \"%.6g\")),\n            Value::String(s) =\u003e write!(f, \"{}\", s),\n            Value::NumericString(s, _) =\u003e write!(f, \"{}\", s),\n        }\n    }\n}\n\n/// Compare two AWK values according to AWK comparison rules\n#[inline]\npub fn compare_values(left: \u0026Value, right: \u0026Value) -\u003e Ordering {\n    // If both are numeric or numeric strings, compare numerically\n    if left.compares_as_number() \u0026\u0026 right.compares_as_number() {\n        let l = left.to_number();\n        let r = right.to_number();\n        l.partial_cmp(\u0026r).unwrap_or(Ordering::Equal)\n    } else {\n        // Otherwise compare as strings - use as_str to avoid allocation\n        left.as_str().cmp(\u0026right.as_str())\n    }\n}\n\n/// Parse the leading numeric portion of a string using optimized byte-based parsing\n/// \"42abc\" -\u003e 42.0\n/// \"  3.14  \" -\u003e 3.14\n/// \"abc\" -\u003e 0.0\n#[inline]\npub fn parse_leading_number(s: \u0026str) -\u003e f64 {\n    let bytes = s.as_bytes();\n    let mut i = 0;\n\n    // Skip leading whitespace\n    while i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_whitespace() {\n        i += 1;\n    }\n\n    if i \u003e= bytes.len() {\n        return 0.0;\n    }\n\n    let start = i;\n\n    // Optional sign\n    if i \u003c bytes.len() \u0026\u0026 (bytes[i] == b'+' || bytes[i] == b'-') {\n        i += 1;\n    }\n\n    let mut has_digits = false;\n\n    // Digits before decimal\n    while i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_digit() {\n        i += 1;\n        has_digits = true;\n    }\n\n    // Decimal point and digits after\n    if i \u003c bytes.len() \u0026\u0026 bytes[i] == b'.' {\n        i += 1;\n        while i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_digit() {\n            i += 1;\n            has_digits = true;\n        }\n    }\n\n    // Exponent\n    if i \u003c bytes.len() \u0026\u0026 (bytes[i] == b'e' || bytes[i] == b'E') {\n        let exp_start = i;\n        i += 1;\n        if i \u003c bytes.len() \u0026\u0026 (bytes[i] == b'+' || bytes[i] == b'-') {\n            i += 1;\n        }\n        if i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_digit() {\n            while i \u003c bytes.len() \u0026\u0026 bytes[i].is_ascii_digit() {\n                i += 1;\n            }\n        } else {\n            // Invalid exponent, back up\n            i = exp_start;\n        }\n    }\n\n    if !has_digits {\n        return 0.0;\n    }\n\n    // Fast path for common integer case\n    let num_str = \u0026s[start..i];\n    if !num_str.contains('.') \u0026\u0026 !num_str.contains('e') \u0026\u0026 !num_str.contains('E') {\n        if let Ok(n) = num_str.parse::\u003ci64\u003e() {\n            return n as f64;\n        }\n    }\n\n    num_str.parse().unwrap_or(0.0)\n}\n\n/// Check if a string is a numeric string (looks entirely like a number)\n#[inline]\nfn parse_numeric_string(s: \u0026str) -\u003e Option\u003cf64\u003e {\n    let trimmed = s.trim();\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    // Fast path: check if it's a simple integer\n    if trimmed.bytes().all(|b| b.is_ascii_digit()) {\n        return trimmed.parse().ok();\n    }\n\n    // Check for leading sign\n    let check = if trimmed.starts_with('-') || trimmed.starts_with('+') {\n        \u0026trimmed[1..]\n    } else {\n        trimmed\n    };\n\n    // Simple float pattern check\n    let mut has_dot = false;\n    let mut has_e = false;\n    for (i, b) in check.bytes().enumerate() {\n        match b {\n            b'0'..=b'9' =\u003e continue,\n            b'.' if !has_dot \u0026\u0026 !has_e =\u003e has_dot = true,\n            b'e' | b'E' if !has_e \u0026\u0026 i \u003e 0 =\u003e {\n                has_e = true;\n                // Check for sign after e\n                if i + 1 \u003c check.len() {\n                    let next = check.as_bytes()[i + 1];\n                    if next == b'+' || next == b'-' {\n                        continue;\n                    }\n                }\n            }\n            b'+' | b'-' if has_e =\u003e continue,\n            _ =\u003e return None,\n        }\n    }\n\n    trimmed.parse().ok()\n}\n\n/// Format a number according to printf-style format\npub fn format_number(n: f64, format: \u0026str) -\u003e String {\n    if n.is_nan() {\n        return \"nan\".to_string();\n    }\n    if n.is_infinite() {\n        return if n \u003e 0.0 { \"inf\" } else { \"-inf\" }.to_string();\n    }\n\n    // Handle %.6g (default OFMT) - optimized path\n    if format == \"%.6g\" {\n        // If it's an integer, print without decimal\n        if n.fract() == 0.0 \u0026\u0026 n.abs() \u003c 1e15 {\n            return itoa_fast(n as i64);\n        }\n        // Otherwise use default formatting with reasonable precision\n        let s = format!(\"{:.6}\", n);\n        // Trim trailing zeros after decimal point\n        if s.contains('.') {\n            let trimmed = s.trim_end_matches('0');\n            if trimmed.ends_with('.') {\n                return trimmed[..trimmed.len()-1].to_string();\n            }\n            return trimmed.to_string();\n        }\n        return s;\n    }\n\n    // Fallback\n    format!(\"{}\", n)\n}\n\n/// Fast integer to string conversion\n#[inline]\nfn itoa_fast(n: i64) -\u003e String {\n    if n == 0 {\n        return \"0\".to_string();\n    }\n\n    let mut result = String::with_capacity(20);\n    let mut num = n;\n    let negative = num \u003c 0;\n    if negative {\n        num = -num;\n    }\n\n    while num \u003e 0 {\n        result.push((b'0' + (num % 10) as u8) as char);\n        num /= 10;\n    }\n\n    if negative {\n        result.push('-');\n    }\n\n    result.chars().rev().collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_uninitialized() {\n        let v = Value::Uninitialized;\n        assert_eq!(v.to_number(), 0.0);\n        assert_eq!(v.to_string_val(), \"\");\n        assert!(!v.is_truthy());\n    }\n\n    #[test]\n    fn test_number() {\n        let v = Value::Number(42.0);\n        assert_eq!(v.to_number(), 42.0);\n        assert_eq!(v.to_string_val(), \"42\");\n        assert!(v.is_truthy());\n\n        let zero = Value::Number(0.0);\n        assert!(!zero.is_truthy());\n    }\n\n    #[test]\n    fn test_string() {\n        let v = Value::from_string(\"hello\".to_string());\n        assert_eq!(v.to_number(), 0.0);\n        assert_eq!(v.to_string_val(), \"hello\");\n        assert!(v.is_truthy());\n\n        let empty = Value::from_string(\"\".to_string());\n        assert!(!empty.is_truthy());\n    }\n\n    #[test]\n    fn test_numeric_string() {\n        let v = Value::from_string(\"42\".to_string());\n        assert!(v.is_numeric_string());\n        assert_eq!(v.to_number(), 42.0);\n        assert_eq!(v.to_string_val(), \"42\");\n    }\n\n    #[test]\n    fn test_leading_number() {\n        assert_eq!(parse_leading_number(\"42abc\"), 42.0);\n        assert_eq!(parse_leading_number(\"  3.14  \"), 3.14);\n        assert_eq!(parse_leading_number(\"abc\"), 0.0);\n        assert_eq!(parse_leading_number(\"-5.5\"), -5.5);\n        assert_eq!(parse_leading_number(\"1e10\"), 1e10);\n    }\n\n    #[test]\n    fn test_comparison() {\n        let n1 = Value::Number(10.0);\n        let n2 = Value::Number(2.0);\n        assert_eq!(compare_values(\u0026n1, \u0026n2), Ordering::Greater);\n\n        let s1 = Value::from_string(\"10\".to_string());\n        let s2 = Value::from_string(\"2\".to_string());\n        // Both numeric strings -\u003e compare numerically\n        assert_eq!(compare_values(\u0026s1, \u0026s2), Ordering::Greater);\n\n        let s3 = Value::from_string(\"abc\".to_string());\n        let s4 = Value::from_string(\"def\".to_string());\n        // Both pure strings -\u003e compare lexically\n        assert_eq!(compare_values(\u0026s3, \u0026s4), Ordering::Less);\n    }\n\n    #[test]\n    fn test_itoa_fast() {\n        assert_eq!(itoa_fast(0), \"0\");\n        assert_eq!(itoa_fast(42), \"42\");\n        assert_eq!(itoa_fast(-123), \"-123\");\n        assert_eq!(itoa_fast(1000000), \"1000000\");\n    }\n\n    #[test]\n    fn test_format_number_nan() {\n        assert_eq!(format_number(f64::NAN, \"%.6g\"), \"nan\");\n    }\n\n    #[test]\n    fn test_format_number_inf() {\n        assert_eq!(format_number(f64::INFINITY, \"%.6g\"), \"inf\");\n        assert_eq!(format_number(f64::NEG_INFINITY, \"%.6g\"), \"-inf\");\n    }\n\n    #[test]\n    fn test_format_number_integer() {\n        assert_eq!(format_number(42.0, \"%.6g\"), \"42\");\n        assert_eq!(format_number(-100.0, \"%.6g\"), \"-100\");\n    }\n\n    #[test]\n    fn test_format_number_float() {\n        assert_eq!(format_number(3.14, \"%.6g\"), \"3.14\");\n    }\n\n    #[test]\n    fn test_from_number() {\n        let v = Value::from_number(3.14);\n        assert_eq!(v.to_number(), 3.14);\n    }\n\n    #[test]\n    fn test_is_truthy_numeric_string() {\n        let v = Value::NumericString(\"42\".to_string(), 42.0);\n        assert!(v.is_truthy());\n        \n        let empty = Value::NumericString(\"\".to_string(), 0.0);\n        assert!(!empty.is_truthy());\n    }\n\n    #[test]\n    fn test_comparison_number_vs_string() {\n        let n = Value::Number(10.0);\n        let s = Value::from_string(\"hello\".to_string());\n        // Number vs non-numeric string\n        assert!(compare_values(\u0026n, \u0026s) != Ordering::Equal);\n    }\n\n    #[test]\n    fn test_comparison_uninitialized() {\n        let u = Value::Uninitialized;\n        let n = Value::Number(1.0);\n        // Uninitialized (0) vs 1 should be Less\n        assert_eq!(compare_values(\u0026u, \u0026n), Ordering::Less);\n    }\n\n    #[test]\n    fn test_parse_leading_with_sign() {\n        assert_eq!(parse_leading_number(\"+42\"), 42.0);\n        assert_eq!(parse_leading_number(\"  +3.14\"), 3.14);\n    }\n\n    #[test]\n    fn test_parse_leading_exponent() {\n        assert_eq!(parse_leading_number(\"1e-5\"), 1e-5);\n        assert_eq!(parse_leading_number(\"2E+3\"), 2000.0);\n    }\n\n    #[test]\n    fn test_numeric_string_with_exponent() {\n        let v = Value::from_string(\"1e5\".to_string());\n        assert!(v.is_numeric_string());\n        assert_eq!(v.to_number(), 1e5);\n    }\n\n    #[test]\n    fn test_numeric_string_with_sign() {\n        let v = Value::from_string(\"-42.5\".to_string());\n        assert!(v.is_numeric_string());\n        assert_eq!(v.to_number(), -42.5);\n    }\n\n    #[test]\n    fn test_numeric_string_whitespace() {\n        let v = Value::from_string(\"  123  \".to_string());\n        assert!(v.is_numeric_string());\n        assert_eq!(v.to_number(), 123.0);\n    }\n\n    #[test]\n    fn test_to_string_val_uninitialized() {\n        let v = Value::Uninitialized;\n        assert_eq!(v.to_string_val(), \"\");\n    }\n\n    #[test]\n    fn test_to_number_uninitialized() {\n        let v = Value::Uninitialized;\n        assert_eq!(v.to_number(), 0.0);\n    }\n}\n","traces":[{"line":51,"address":[3181344],"length":1,"stats":{"Line":0}},{"line":52,"address":[2548611],"length":1,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[2189927,2189726,2189794],"length":1,"stats":{"Line":32}},{"line":61,"address":[2545390],"length":1,"stats":{"Line":5}},{"line":63,"address":[2159043],"length":1,"stats":{"Line":20}},{"line":69,"address":[2892256],"length":1,"stats":{"Line":1}},{"line":70,"address":[2903529],"length":1,"stats":{"Line":1}},{"line":79,"address":[2904640],"length":1,"stats":{"Line":11}},{"line":80,"address":[2904653],"length":1,"stats":{"Line":13}},{"line":81,"address":[2159672],"length":1,"stats":{"Line":1}},{"line":82,"address":[2159683],"length":1,"stats":{"Line":12}},{"line":83,"address":[2159727],"length":1,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[2893568],"length":1,"stats":{"Line":6}},{"line":91,"address":[3179229],"length":1,"stats":{"Line":6}},{"line":92,"address":[2308760],"length":1,"stats":{"Line":4}},{"line":93,"address":[3179303],"length":1,"stats":{"Line":6}},{"line":94,"address":[2159908],"length":1,"stats":{"Line":2}},{"line":95,"address":[2546649],"length":1,"stats":{"Line":5}},{"line":101,"address":[2545568],"length":1,"stats":{"Line":8}},{"line":102,"address":[2159169],"length":1,"stats":{"Line":13}},{"line":107,"address":[2190192],"length":1,"stats":{"Line":3}},{"line":108,"address":[2893095],"length":1,"stats":{"Line":3}},{"line":109,"address":[2893159],"length":1,"stats":{"Line":0}},{"line":110,"address":[2904462],"length":1,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[3178972],"length":1,"stats":{"Line":0}},{"line":117,"address":[2545776],"length":1,"stats":{"Line":9}},{"line":118,"address":[2545820],"length":1,"stats":{"Line":5}},{"line":119,"address":[2892956],"length":1,"stats":{"Line":2}},{"line":120,"address":[2904247],"length":1,"stats":{"Line":5}},{"line":121,"address":[2893018],"length":1,"stats":{"Line":9}},{"line":122,"address":[2893045],"length":1,"stats":{"Line":3}},{"line":128,"address":[3177840],"length":1,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[3178341],"length":1,"stats":{"Line":2}},{"line":140,"address":[2308096,2308160],"length":1,"stats":{"Line":8}},{"line":141,"address":[],"length":0,"stats":{"Line":13}},{"line":146,"address":[2548584,2548590,2547968],"length":1,"stats":{"Line":0}},{"line":147,"address":[2548001],"length":1,"stats":{"Line":0}},{"line":148,"address":[2895148],"length":1,"stats":{"Line":0}},{"line":149,"address":[2895163,2895544],"length":1,"stats":{"Line":0}},{"line":150,"address":[2906518],"length":1,"stats":{"Line":0}},{"line":151,"address":[3181047],"length":1,"stats":{"Line":0}},{"line":158,"address":[2541664,2541961,2541955],"length":1,"stats":{"Line":6}},{"line":160,"address":[2541691,2541737],"length":1,"stats":{"Line":14}},{"line":161,"address":[2304297],"length":1,"stats":{"Line":6}},{"line":162,"address":[2888809],"length":1,"stats":{"Line":7}},{"line":163,"address":[2186324],"length":1,"stats":{"Line":7}},{"line":166,"address":[2541710,2541814],"length":1,"stats":{"Line":2}},{"line":175,"address":[2304528],"length":1,"stats":{"Line":4}},{"line":176,"address":[2155671],"length":1,"stats":{"Line":4}},{"line":177,"address":[2889100],"length":1,"stats":{"Line":4}},{"line":180,"address":[3174768,3174810,3176848],"length":1,"stats":{"Line":7}},{"line":181,"address":[2306709,2304746,2306696],"length":1,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[3174971],"length":1,"stats":{"Line":0}},{"line":188,"address":[2542247],"length":1,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":8}},{"line":192,"address":[2305062,2305075,2304939],"length":1,"stats":{"Line":2}},{"line":195,"address":[2186844],"length":1,"stats":{"Line":3}},{"line":198,"address":[2889592,2889634,2889348,2891166],"length":1,"stats":{"Line":10}},{"line":199,"address":[2900978,2902435,2902414],"length":1,"stats":{"Line":5}},{"line":200,"address":[2902422],"length":1,"stats":{"Line":2}},{"line":204,"address":[2305290,2305114],"length":1,"stats":{"Line":4}},{"line":205,"address":[2889860,2889900],"length":1,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":207,"address":[2156625,2156676],"length":1,"stats":{"Line":1}},{"line":208,"address":[2901319],"length":1,"stats":{"Line":1}},{"line":213,"address":[2187263,2187612,2187733],"length":1,"stats":{"Line":8}},{"line":214,"address":[2156781],"length":1,"stats":{"Line":1}},{"line":215,"address":[2901574,2901594,2901458],"length":1,"stats":{"Line":2}},{"line":216,"address":[3176207,3175966,3176026,3176126],"length":1,"stats":{"Line":4}},{"line":217,"address":[2157172,2157051,2157159],"length":1,"stats":{"Line":2}},{"line":219,"address":[2157198,2156959],"length":1,"stats":{"Line":1}},{"line":220,"address":[2890682,2890816],"length":1,"stats":{"Line":2}},{"line":221,"address":[2188325,2188282],"length":1,"stats":{"Line":1}},{"line":225,"address":[2890582],"length":1,"stats":{"Line":0}},{"line":229,"address":[2305585],"length":1,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[2902136],"length":1,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[2902260],"length":1,"stats":{"Line":1}},{"line":246,"address":[2902496],"length":1,"stats":{"Line":16}},{"line":247,"address":[2891255],"length":1,"stats":{"Line":12}},{"line":248,"address":[2157900],"length":1,"stats":{"Line":19}},{"line":249,"address":[2544286],"length":1,"stats":{"Line":3}},{"line":253,"address":[2157919],"length":1,"stats":{"Line":31}},{"line":254,"address":[],"length":0,"stats":{"Line":5}},{"line":258,"address":[2188946,2188871,2189001],"length":1,"stats":{"Line":35}},{"line":259,"address":[2306973],"length":1,"stats":{"Line":2}},{"line":261,"address":[3177157],"length":1,"stats":{"Line":19}},{"line":265,"address":[3177167],"length":1,"stats":{"Line":14}},{"line":266,"address":[2189031],"length":1,"stats":{"Line":22}},{"line":267,"address":[2544474,2544574],"length":1,"stats":{"Line":39}},{"line":268,"address":[],"length":0,"stats":{"Line":16}},{"line":269,"address":[3177360,3177490],"length":1,"stats":{"Line":38}},{"line":270,"address":[2903195,2903127],"length":1,"stats":{"Line":6}},{"line":271,"address":[2903223,2903266,2903139,2903151],"length":1,"stats":{"Line":12}},{"line":272,"address":[2189474],"length":1,"stats":{"Line":2}},{"line":274,"address":[2544947,2544912],"length":1,"stats":{"Line":4}},{"line":275,"address":[2892169,2892059],"length":1,"stats":{"Line":3}},{"line":276,"address":[2189658],"length":1,"stats":{"Line":3}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[2903179,2903163],"length":1,"stats":{"Line":1}},{"line":282,"address":[2544786],"length":1,"stats":{"Line":21}},{"line":286,"address":[2307234],"length":1,"stats":{"Line":3}},{"line":290,"address":[2888593,2888587,2887408],"length":1,"stats":{"Line":6}},{"line":291,"address":[3173104],"length":1,"stats":{"Line":6}},{"line":292,"address":[2887510],"length":1,"stats":{"Line":1}},{"line":294,"address":[2540458],"length":1,"stats":{"Line":6}},{"line":295,"address":[2899870,2898828],"length":1,"stats":{"Line":2}},{"line":299,"address":[2887533],"length":1,"stats":{"Line":7}},{"line":301,"address":[2887735,2887984],"length":1,"stats":{"Line":13}},{"line":302,"address":[2888027],"length":1,"stats":{"Line":6}},{"line":305,"address":[2540764],"length":1,"stats":{"Line":2}},{"line":307,"address":[3173606,3173795],"length":1,"stats":{"Line":4}},{"line":308,"address":[2888238,2888284],"length":1,"stats":{"Line":4}},{"line":309,"address":[3174000],"length":1,"stats":{"Line":2}},{"line":310,"address":[2888421,2888443],"length":1,"stats":{"Line":2}},{"line":312,"address":[2541400,2541367],"length":1,"stats":{"Line":4}},{"line":314,"address":[2888185],"length":1,"stats":{"Line":0}},{"line":318,"address":[2887591],"length":1,"stats":{"Line":0}},{"line":323,"address":[3180033,3180039,3179408],"length":1,"stats":{"Line":7}},{"line":324,"address":[2893790],"length":1,"stats":{"Line":6}},{"line":325,"address":[3179449],"length":1,"stats":{"Line":3}},{"line":328,"address":[2905085],"length":1,"stats":{"Line":7}},{"line":329,"address":[],"length":0,"stats":{"Line":6}},{"line":330,"address":[2546777],"length":1,"stats":{"Line":7}},{"line":331,"address":[2546805,2546883],"length":1,"stats":{"Line":9}},{"line":332,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[2894359,2893896],"length":1,"stats":{"Line":12}},{"line":336,"address":[],"length":0,"stats":{"Line":12}},{"line":337,"address":[],"length":0,"stats":{"Line":8}},{"line":340,"address":[3179670],"length":1,"stats":{"Line":5}},{"line":341,"address":[2894078],"length":1,"stats":{"Line":3}},{"line":344,"address":[2894097,2894051],"length":1,"stats":{"Line":29}}],"covered":124,"coverable":141},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","tests","cli.rs"],"content":"//! CLI integration tests for rawk\n//!\n//! These tests run the rawk binary and verify command-line behavior.\n\nuse std::process::Command;\nuse std::io::Write;\nuse tempfile::NamedTempFile;\n\n/// Run rawk with the given arguments and input, returning stdout\nfn run_rawk(args: \u0026[\u0026str], input: Option\u003c\u0026str\u003e) -\u003e Result\u003cString, String\u003e {\n    let mut cmd = Command::new(\"cargo\");\n    cmd.args([\"run\", \"--quiet\", \"--\"]);\n    cmd.args(args);\n\n    if let Some(input_str) = input {\n        cmd.stdin(std::process::Stdio::piped());\n    }\n    cmd.stdout(std::process::Stdio::piped());\n    cmd.stderr(std::process::Stdio::piped());\n\n    let mut child = cmd.spawn().map_err(|e| e.to_string())?;\n\n    if let Some(input_str) = input {\n        if let Some(mut stdin) = child.stdin.take() {\n            stdin.write_all(input_str.as_bytes()).map_err(|e| e.to_string())?;\n        }\n    }\n\n    let output = child.wait_with_output().map_err(|e| e.to_string())?;\n\n    if output.status.success() {\n        String::from_utf8(output.stdout).map_err(|e| e.to_string())\n    } else {\n        Err(String::from_utf8_lossy(\u0026output.stderr).to_string())\n    }\n}\n\n#[test]\nfn test_cli_help() {\n    let output = run_rawk(\u0026[\"--help\"], None).unwrap();\n    assert!(output.contains(\"Usage:\"));\n    assert!(output.contains(\"rawk\"));\n}\n\n#[test]\nfn test_cli_version() {\n    let output = run_rawk(\u0026[\"--version\"], None).unwrap();\n    assert!(output.contains(\"rawk\"));\n}\n\n#[test]\nfn test_cli_simple_program() {\n    let output = run_rawk(\u0026[\"BEGIN { print \\\"hello\\\" }\"], None).unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_cli_with_input() {\n    let output = run_rawk(\u0026[\"{ print $1 }\"], Some(\"a b c\")).unwrap();\n    assert_eq!(output, \"a\\n\");\n}\n\n#[test]\nfn test_cli_field_separator() {\n    let output = run_rawk(\u0026[\"-F:\", \"{ print $1 }\"], Some(\"a:b:c\")).unwrap();\n    assert_eq!(output, \"a\\n\");\n}\n\n#[test]\nfn test_cli_field_separator_attached() {\n    let output = run_rawk(\u0026[\"-F,\", \"{ print $2 }\"], Some(\"a,b,c\")).unwrap();\n    assert_eq!(output, \"b\\n\");\n}\n\n#[test]\nfn test_cli_variable() {\n    let output = run_rawk(\u0026[\"-v\", \"x=5\", \"BEGIN { print x }\"], None).unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_cli_program_file() {\n    let mut file = NamedTempFile::new().unwrap();\n    writeln!(file, r#\"BEGIN {{ print \"from file\" }}\"#).unwrap();\n\n    let path = file.path().to_str().unwrap();\n    let output = run_rawk(\u0026[\"-f\", path], None).unwrap();\n    assert_eq!(output, \"from file\\n\");\n}\n\n#[test]\nfn test_cli_posix_mode() {\n    // In posix mode, FPAT should not work\n    let output = run_rawk(\u0026[\"--posix\", \"BEGIN { print \\\"posix\\\" }\"], None).unwrap();\n    assert_eq!(output, \"posix\\n\");\n}\n\n#[test]\nfn test_cli_traditional_mode() {\n    let output = run_rawk(\u0026[\"--traditional\", \"BEGIN { print \\\"trad\\\" }\"], None).unwrap();\n    assert_eq!(output, \"trad\\n\");\n}\n\n#[test]\nfn test_cli_separator_end_of_options() {\n    // -- marks end of options, program comes before it\n    let output = run_rawk(\u0026[\"BEGIN { print \\\"test\\\" }\", \"--\"], None).unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n#[test]\nfn test_cli_stdin_dash() {\n    let output = run_rawk(\u0026[\"{ print }\", \"-\"], Some(\"hello\")).unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_cli_multiple_inputs() {\n    let mut file1 = NamedTempFile::new().unwrap();\n    writeln!(file1, \"a\").unwrap();\n    let mut file2 = NamedTempFile::new().unwrap();\n    writeln!(file2, \"b\").unwrap();\n\n    let path1 = file1.path().to_str().unwrap();\n    let path2 = file2.path().to_str().unwrap();\n    let output = run_rawk(\u0026[\"{ print }\", path1, path2], None).unwrap();\n    assert!(output.contains(\"a\") \u0026\u0026 output.contains(\"b\"));\n}\n\n#[test]\nfn test_cli_error_no_program() {\n    let result = run_rawk(\u0026[], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_unknown_option() {\n    let result = run_rawk(\u0026[\"--unknown\"], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_missing_f_arg() {\n    let result = run_rawk(\u0026[\"-f\"], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_missing_v_arg() {\n    let result = run_rawk(\u0026[\"-v\"], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_invalid_v_arg() {\n    let result = run_rawk(\u0026[\"-v\", \"invalid\"], None);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cli_error_missing_F_arg() {\n    let result = run_rawk(\u0026[\"-F\"], None);\n    assert!(result.is_err());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","tests","e2e.rs"],"content":"//! End-to-end tests for rawk\n//!\n//! These tests run complete AWK programs and verify the output matches expected results.\n\nuse std::io::{BufReader, Cursor};\n\nuse rawk::{Interpreter, Lexer, Parser};\n\n/// Run an AWK program with the given input and return the output\nfn run_awk(program: \u0026str, input: \u0026str) -\u003e Result\u003cString, String\u003e {\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().map_err(|e| e.to_string())?;\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse().map_err(|e| e.to_string())?;\n\n    let mut interpreter = Interpreter::new(\u0026ast);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        interpreter.run(inputs, \u0026mut output).map_err(|e| e.to_string())?;\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        interpreter.run(inputs, \u0026mut output).map_err(|e| e.to_string())?;\n    }\n\n    String::from_utf8(output).map_err(|e| e.to_string())\n}\n\n/// Run an AWK program with a custom field separator\nfn run_awk_with_fs(program: \u0026str, input: \u0026str, fs: \u0026str) -\u003e Result\u003cString, String\u003e {\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().map_err(|e| e.to_string())?;\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse().map_err(|e| e.to_string())?;\n\n    let mut interpreter = Interpreter::new(\u0026ast);\n    interpreter.set_fs(fs);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        interpreter.run(inputs, \u0026mut output).map_err(|e| e.to_string())?;\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        interpreter.run(inputs, \u0026mut output).map_err(|e| e.to_string())?;\n    }\n\n    String::from_utf8(output).map_err(|e| e.to_string())\n}\n\n// ============================================================================\n// Basic Output Tests\n// ============================================================================\n\n#[test]\nfn test_hello_world() {\n    let output = run_awk(r#\"BEGIN { print \"Hello, World!\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"Hello, World!\\n\");\n}\n\n#[test]\nfn test_print_number() {\n    let output = run_awk(\"BEGIN { print 42 }\", \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_print_float() {\n    let output = run_awk(\"BEGIN { print 3.14159 }\", \"\").unwrap();\n    assert_eq!(output, \"3.14159\\n\");\n}\n\n#[test]\nfn test_print_multiple_values() {\n    let output = run_awk(r#\"BEGIN { print \"a\", \"b\", \"c\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"a b c\\n\");\n}\n\n#[test]\nfn test_print_concatenation() {\n    let output = run_awk(r#\"BEGIN { print \"hello\" \"world\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"helloworld\\n\");\n}\n\n// ============================================================================\n// Field Access Tests\n// ============================================================================\n\n#[test]\nfn test_print_record() {\n    let output = run_awk(\"{ print $0 }\", \"hello world\").unwrap();\n    assert_eq!(output, \"hello world\\n\");\n}\n\n#[test]\nfn test_print_first_field() {\n    let output = run_awk(\"{ print $1 }\", \"one two three\").unwrap();\n    assert_eq!(output, \"one\\n\");\n}\n\n#[test]\nfn test_print_multiple_fields() {\n    let output = run_awk(\"{ print $1, $3 }\", \"one two three\").unwrap();\n    assert_eq!(output, \"one three\\n\");\n}\n\n#[test]\nfn test_print_nf() {\n    let output = run_awk(\"{ print NF }\", \"one two three four\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_print_last_field() {\n    let output = run_awk(\"{ print $NF }\", \"one two three four\").unwrap();\n    assert_eq!(output, \"four\\n\");\n}\n\n#[test]\nfn test_field_separator_colon() {\n    let output = run_awk_with_fs(\"{ print $1 }\", \"root:x:0:0:root:/root:/bin/bash\", \":\").unwrap();\n    assert_eq!(output, \"root\\n\");\n}\n\n#[test]\nfn test_field_separator_in_begin() {\n    let output = run_awk(\n        r#\"BEGIN { FS = \":\" } { print $1, $3 }\"#,\n        \"root:x:0:0:root:/root:/bin/bash\",\n    )\n    .unwrap();\n    assert_eq!(output, \"root 0\\n\");\n}\n\n#[test]\nfn test_multiple_lines() {\n    let output = run_awk(\"{ print $1 }\", \"one two\\nthree four\\nfive six\").unwrap();\n    assert_eq!(output, \"one\\nthree\\nfive\\n\");\n}\n\n// ============================================================================\n// Arithmetic Tests\n// ============================================================================\n\n#[test]\nfn test_addition() {\n    let output = run_awk(\"BEGIN { print 1 + 2 }\", \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_subtraction() {\n    let output = run_awk(\"BEGIN { print 10 - 3 }\", \"\").unwrap();\n    assert_eq!(output, \"7\\n\");\n}\n\n#[test]\nfn test_multiplication() {\n    let output = run_awk(\"BEGIN { print 6 * 7 }\", \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_division() {\n    let output = run_awk(\"BEGIN { print 15 / 3 }\", \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_modulo() {\n    let output = run_awk(\"BEGIN { print 17 % 5 }\", \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_exponentiation() {\n    let output = run_awk(\"BEGIN { print 2 ^ 10 }\", \"\").unwrap();\n    assert_eq!(output, \"1024\\n\");\n}\n\n#[test]\nfn test_operator_precedence() {\n    let output = run_awk(\"BEGIN { print 2 + 3 * 4 }\", \"\").unwrap();\n    assert_eq!(output, \"14\\n\");\n}\n\n#[test]\nfn test_parentheses() {\n    let output = run_awk(\"BEGIN { print (2 + 3) * 4 }\", \"\").unwrap();\n    assert_eq!(output, \"20\\n\");\n}\n\n#[test]\nfn test_unary_minus() {\n    let output = run_awk(\"BEGIN { print -5 }\", \"\").unwrap();\n    assert_eq!(output, \"-5\\n\");\n}\n\n#[test]\nfn test_unary_plus() {\n    let output = run_awk(\"BEGIN { x = -3; print +x }\", \"\").unwrap();\n    assert_eq!(output, \"-3\\n\");\n}\n\n// ============================================================================\n// Variable Tests\n// ============================================================================\n\n#[test]\nfn test_variable_assignment() {\n    let output = run_awk(\"BEGIN { x = 42; print x }\", \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_uninitialized_variable_numeric() {\n    let output = run_awk(\"BEGIN { print x + 1 }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_uninitialized_variable_string() {\n    let output = run_awk(r#\"BEGIN { print x \"\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_increment_prefix() {\n    let output = run_awk(\"BEGIN { x = 5; print ++x }\", \"\").unwrap();\n    assert_eq!(output, \"6\\n\");\n}\n\n#[test]\nfn test_increment_postfix() {\n    let output = run_awk(\"BEGIN { x = 5; print x++ }\", \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_decrement() {\n    let output = run_awk(\"BEGIN { x = 5; print --x, x-- }\", \"\").unwrap();\n    assert_eq!(output, \"4 4\\n\");\n}\n\n#[test]\nfn test_compound_assignment() {\n    let output = run_awk(\"BEGIN { x = 10; x += 5; x -= 3; x *= 2; print x }\", \"\").unwrap();\n    assert_eq!(output, \"24\\n\");\n}\n\n// ============================================================================\n// Comparison Tests\n// ============================================================================\n\n#[test]\nfn test_numeric_comparison() {\n    let output = run_awk(\"BEGIN { print (5 \u003e 3), (5 \u003c 3), (5 == 5) }\", \"\").unwrap();\n    assert_eq!(output, \"1 0 1\\n\");\n}\n\n#[test]\nfn test_string_comparison() {\n    let output = run_awk(r#\"BEGIN { print (\"abc\" \u003c \"def\"), (\"abc\" == \"abc\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 1\\n\");\n}\n\n#[test]\nfn test_numeric_string_comparison() {\n    // Both are numeric strings, should compare numerically\n    let output = run_awk(r#\"BEGIN { print (\"10\" \u003e \"9\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// ============================================================================\n// Control Flow Tests\n// ============================================================================\n\n#[test]\nfn test_if_true() {\n    let output = run_awk(r#\"BEGIN { if (1) print \"yes\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_if_false() {\n    let output = run_awk(r#\"BEGIN { if (0) print \"yes\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_if_else() {\n    // Use block syntax instead of semicolon before else\n    let output = run_awk(r#\"BEGIN { if (0) { print \"yes\" } else { print \"no\" } }\"#, \"\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n#[test]\nfn test_if_else_chain() {\n    // Use block syntax for if-else chain\n    let output = run_awk(\n        r#\"BEGIN { x = 2; if (x == 1) { print \"one\" } else if (x == 2) { print \"two\" } else { print \"other\" } }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"two\\n\");\n}\n\n#[test]\nfn test_while_loop() {\n    let output = run_awk(\"BEGIN { i = 0; while (i \u003c 3) { print i; i++ } }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n1\\n2\\n\");\n}\n\n#[test]\nfn test_for_loop() {\n    let output = run_awk(\"BEGIN { for (i = 1; i \u003c= 3; i++) print i }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n2\\n3\\n\");\n}\n\n#[test]\nfn test_do_while() {\n    let output = run_awk(\"BEGIN { i = 0; do { print i; i++ } while (i \u003c 3) }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n1\\n2\\n\");\n}\n\n#[test]\nfn test_break() {\n    let output = run_awk(\"BEGIN { for (i = 1; i \u003c= 10; i++) { if (i \u003e 3) break; print i } }\", \"\")\n        .unwrap();\n    assert_eq!(output, \"1\\n2\\n3\\n\");\n}\n\n#[test]\nfn test_continue() {\n    let output = run_awk(\n        \"BEGIN { for (i = 1; i \u003c= 5; i++) { if (i == 3) continue; print i } }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"1\\n2\\n4\\n5\\n\");\n}\n\n#[test]\nfn test_next() {\n    let output = run_awk(\"/skip/ { next } { print }\", \"line1\\nskip\\nline2\").unwrap();\n    assert_eq!(output, \"line1\\nline2\\n\");\n}\n\n// ============================================================================\n// Pattern Tests\n// ============================================================================\n\n#[test]\nfn test_begin_pattern() {\n    let output = run_awk(r#\"BEGIN { print \"start\" } { print \"line\" }\"#, \"a\\nb\").unwrap();\n    assert_eq!(output, \"start\\nline\\nline\\n\");\n}\n\n#[test]\nfn test_end_pattern() {\n    let output = run_awk(r#\"{ print \"line\" } END { print \"end\" }\"#, \"a\\nb\").unwrap();\n    assert_eq!(output, \"line\\nline\\nend\\n\");\n}\n\n#[test]\nfn test_regex_pattern() {\n    let output = run_awk(\"/error/ { print }\", \"info: ok\\nerror: fail\\ninfo: done\").unwrap();\n    assert_eq!(output, \"error: fail\\n\");\n}\n\n#[test]\nfn test_expression_pattern() {\n    let output = run_awk(\"$1 \u003e 5 { print }\", \"3 a\\n7 b\\n2 c\\n10 d\").unwrap();\n    assert_eq!(output, \"7 b\\n10 d\\n\");\n}\n\n#[test]\nfn test_negated_regex() {\n    let output = run_awk(\"!/skip/ { print }\", \"keep\\nskip\\nalso keep\").unwrap();\n    assert_eq!(output, \"keep\\nalso keep\\n\");\n}\n\n#[test]\nfn test_range_pattern() {\n    let output = run_awk(\"/start/,/end/ { print }\", \"before\\nstart\\nmiddle\\nend\\nafter\").unwrap();\n    assert_eq!(output, \"start\\nmiddle\\nend\\n\");\n}\n\n// ============================================================================\n// Array Tests\n// ============================================================================\n\n#[test]\nfn test_array_assignment() {\n    let output = run_awk(\"BEGIN { a[1] = 10; a[2] = 20; print a[1], a[2] }\", \"\").unwrap();\n    assert_eq!(output, \"10 20\\n\");\n}\n\n#[test]\nfn test_array_string_keys() {\n    let output =\n        run_awk(r#\"BEGIN { a[\"foo\"] = 1; a[\"bar\"] = 2; print a[\"foo\"], a[\"bar\"] }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 2\\n\");\n}\n\n#[test]\nfn test_array_in_operator() {\n    let output = run_awk(\n        r#\"BEGIN { a[1] = 1; print (1 in a), (2 in a) }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"1 0\\n\");\n}\n\n#[test]\nfn test_for_in_loop() {\n    let output = run_awk(\n        \"BEGIN { a[1]=1; a[2]=2; a[3]=3; sum=0; for (k in a) sum += a[k]; print sum }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"6\\n\");\n}\n\n#[test]\nfn test_delete_array_element() {\n    let output = run_awk(\n        \"BEGIN { a[1]=1; a[2]=2; delete a[1]; print (1 in a), (2 in a) }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"0 1\\n\");\n}\n\n#[test]\nfn test_word_count() {\n    let output = run_awk(\n        \"{ for (i=1; i\u003c=NF; i++) count[$i]++ } END { for (w in count) print w, count[w] }\",\n        \"a b a c b a\",\n    )\n    .unwrap();\n    // Order may vary, so check that we have the right counts\n    assert!(output.contains(\"a 3\"));\n    assert!(output.contains(\"b 2\"));\n    assert!(output.contains(\"c 1\"));\n}\n\n// ============================================================================\n// Built-in Function Tests\n// ============================================================================\n\n#[test]\nfn test_length() {\n    let output = run_awk(r#\"BEGIN { print length(\"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_length_no_arg() {\n    let output = run_awk(\"{ print length() }\", \"hello world\").unwrap();\n    assert_eq!(output, \"11\\n\");\n}\n\n#[test]\nfn test_substr() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 2, 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"ell\\n\");\n}\n\n#[test]\nfn test_substr_to_end() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"llo\\n\");\n}\n\n#[test]\nfn test_index() {\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"ll\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_index_not_found() {\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"x\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_split_manual() {\n    // split() requires special lvalue handling for the array argument\n    // For now, test field splitting which uses similar logic\n    let output = run_awk_with_fs(\"{ print $1, $2, $3 }\", \"a:b:c\", \":\").unwrap();\n    assert_eq!(output, \"a b c\\n\");\n}\n\n#[test]\nfn test_tolower() {\n    let output = run_awk(r#\"BEGIN { print tolower(\"HeLLo\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_toupper() {\n    let output = run_awk(r#\"BEGIN { print toupper(\"HeLLo\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"HELLO\\n\");\n}\n\n#[test]\nfn test_gsub() {\n    // gsub on $0 (default target)\n    // Note: Use string pattern instead of regex literal for now\n    let output = run_awk(r#\"{ gsub(\"o\", \"0\"); print }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"hell0 w0rld\\n\");\n}\n\n#[test]\nfn test_sub() {\n    // sub on $0 (default target)\n    // Note: Use string pattern instead of regex literal for now\n    let output = run_awk(r#\"{ sub(\"o\", \"0\"); print }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"hell0 world\\n\");\n}\n\n#[test]\nfn test_match() {\n    // Note: Use string pattern instead of regex literal for now\n    let output = run_awk(\n        r#\"BEGIN { print match(\"hello world\", \"wor\"), RSTART, RLENGTH }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"7 7 3\\n\");\n}\n\n#[test]\nfn test_sprintf() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%05d\", 42) }\"#, \"\").unwrap();\n    assert_eq!(output, \"00042\\n\");\n}\n\n#[test]\nfn test_sqrt() {\n    let output = run_awk(\"BEGIN { print sqrt(16) }\", \"\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_int() {\n    let output = run_awk(\"BEGIN { print int(3.7), int(-3.7) }\", \"\").unwrap();\n    assert_eq!(output, \"3 -3\\n\");\n}\n\n#[test]\nfn test_sin_cos() {\n    let output = run_awk(\"BEGIN { print int(sin(0) * 100), int(cos(0) * 100) }\", \"\").unwrap();\n    assert_eq!(output, \"0 100\\n\");\n}\n\n#[test]\nfn test_exp_log() {\n    let output = run_awk(\"BEGIN { print int(log(exp(1)) * 1000) }\", \"\").unwrap();\n    assert_eq!(output, \"1000\\n\");\n}\n\n// ============================================================================\n// Printf Tests\n// ============================================================================\n\n#[test]\nfn test_printf_string() {\n    let output = run_awk(r#\"BEGIN { printf \"%s\\n\", \"hello\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_printf_integer() {\n    let output = run_awk(r#\"BEGIN { printf \"%d\\n\", 42 }\"#, \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_printf_float() {\n    let output = run_awk(r#\"BEGIN { printf \"%.2f\\n\", 3.14159 }\"#, \"\").unwrap();\n    assert_eq!(output, \"3.14\\n\");\n}\n\n#[test]\nfn test_printf_width() {\n    let output = run_awk(r#\"BEGIN { printf \"%10s|\\n\", \"hi\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"        hi|\\n\");\n}\n\n#[test]\nfn test_printf_left_align() {\n    let output = run_awk(r#\"BEGIN { printf \"%-10s|\\n\", \"hi\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"hi        |\\n\");\n}\n\n#[test]\nfn test_printf_zero_pad() {\n    let output = run_awk(r#\"BEGIN { printf \"%05d\\n\", 42 }\"#, \"\").unwrap();\n    assert_eq!(output, \"00042\\n\");\n}\n\n#[test]\nfn test_printf_hex() {\n    let output = run_awk(r#\"BEGIN { printf \"%x %X\\n\", 255, 255 }\"#, \"\").unwrap();\n    assert_eq!(output, \"ff FF\\n\");\n}\n\n#[test]\nfn test_printf_octal() {\n    let output = run_awk(r#\"BEGIN { printf \"%o\\n\", 8 }\"#, \"\").unwrap();\n    assert_eq!(output, \"10\\n\");\n}\n\n#[test]\nfn test_printf_char() {\n    let output = run_awk(r#\"BEGIN { printf \"%c%c%c\\n\", 65, 66, 67 }\"#, \"\").unwrap();\n    assert_eq!(output, \"ABC\\n\");\n}\n\n#[test]\nfn test_printf_percent() {\n    let output = run_awk(r#\"BEGIN { printf \"100%%\\n\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"100%\\n\");\n}\n\n// ============================================================================\n// User-Defined Function Tests\n// ============================================================================\n\n#[test]\nfn test_function_definition() {\n    let output = run_awk(\n        \"function double(x) { return x * 2 } BEGIN { print double(21) }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_function_with_side_effect() {\n    // Function that modifies a global variable\n    let output = run_awk(\n        r#\"function increment() { count++ } BEGIN { count = 0; increment(); increment(); print count }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_function_string_return() {\n    // Function that returns a formatted string\n    let output = run_awk(\n        r#\"function greet(name) { return \"Hello, \" name } BEGIN { print greet(\"World\") }\"#,\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"Hello, World\\n\");\n}\n\n#[test]\nfn test_function_recursion() {\n    let output = run_awk(\n        \"function fact(n) { if (n \u003c= 1) return 1; return n * fact(n-1) } BEGIN { print fact(5) }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"120\\n\");\n}\n\n#[test]\nfn test_function_fibonacci() {\n    let output = run_awk(\n        \"function fib(n) { if (n \u003c= 2) return 1; return fib(n-1) + fib(n-2) } BEGIN { print fib(10) }\",\n        \"\",\n    )\n    .unwrap();\n    assert_eq!(output, \"55\\n\");\n}\n\n// ============================================================================\n// NR/FNR Tests\n// ============================================================================\n\n#[test]\nfn test_nr() {\n    let output = run_awk(\"{ print NR, $0 }\", \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"1 a\\n2 b\\n3 c\\n\");\n}\n\n#[test]\nfn test_nr_in_end() {\n    let output = run_awk(\"END { print NR }\", \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n// ============================================================================\n// Regex Match Operator Tests\n// ============================================================================\n\n#[test]\nfn test_match_operator() {\n    let output = run_awk(r#\"BEGIN { print (\"hello\" ~ /ell/) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_not_match_operator() {\n    let output = run_awk(r#\"BEGIN { print (\"hello\" !~ /xyz/) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_match_in_pattern() {\n    let output = run_awk(\"$1 ~ /^[0-9]+$/ { print }\", \"123 num\\nabc text\\n456 num\").unwrap();\n    assert_eq!(output, \"123 num\\n456 num\\n\");\n}\n\n// ============================================================================\n// Ternary Operator Tests\n// ============================================================================\n\n#[test]\nfn test_ternary_true() {\n    let output = run_awk(r#\"BEGIN { print (1 ? \"yes\" : \"no\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_ternary_false() {\n    let output = run_awk(r#\"BEGIN { print (0 ? \"yes\" : \"no\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n#[test]\nfn test_ternary_expression() {\n    let output = run_awk(\"BEGIN { x = 5; print (x \u003e 3 ? x * 2 : x / 2) }\", \"\").unwrap();\n    assert_eq!(output, \"10\\n\");\n}\n\n// ============================================================================\n// Logical Operator Tests\n// ============================================================================\n\n#[test]\nfn test_logical_and() {\n    let output = run_awk(\"BEGIN { print (1 \u0026\u0026 1), (1 \u0026\u0026 0), (0 \u0026\u0026 1), (0 \u0026\u0026 0) }\", \"\").unwrap();\n    assert_eq!(output, \"1 0 0 0\\n\");\n}\n\n#[test]\nfn test_logical_or() {\n    let output = run_awk(\"BEGIN { print (1 || 1), (1 || 0), (0 || 1), (0 || 0) }\", \"\").unwrap();\n    assert_eq!(output, \"1 1 1 0\\n\");\n}\n\n#[test]\nfn test_logical_not() {\n    let output = run_awk(\"BEGIN { print !0, !1, !!1 }\", \"\").unwrap();\n    assert_eq!(output, \"1 0 1\\n\");\n}\n\n#[test]\nfn test_short_circuit_and() {\n    // Second expression should not be evaluated\n    let output = run_awk(\"BEGIN { x = 0; if (0 \u0026\u0026 (x = 1)) {}; print x }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_short_circuit_or() {\n    // Second expression should not be evaluated\n    let output = run_awk(\"BEGIN { x = 0; if (1 || (x = 1)) {}; print x }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n// ============================================================================\n// Special Variable Tests\n// ============================================================================\n\n#[test]\nfn test_ofs() {\n    let output = run_awk(r#\"BEGIN { OFS = \",\" } { print $1, $2 }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"a,b\\n\");\n}\n\n#[test]\nfn test_modify_field_rebuilds_record() {\n    let output = run_awk(r#\"BEGIN { OFS = \":\" } { $2 = \"X\"; print $0 }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"a:X:c\\n\");\n}\n\n// ============================================================================\n// Complex Program Tests\n// ============================================================================\n\n#[test]\nfn test_sum_column() {\n    let output = run_awk(\"{ sum += $1 } END { print sum }\", \"1\\n2\\n3\\n4\\n5\").unwrap();\n    assert_eq!(output, \"15\\n\");\n}\n\n#[test]\nfn test_average() {\n    let output =\n        run_awk(\"{ sum += $1; count++ } END { print sum / count }\", \"10\\n20\\n30\").unwrap();\n    assert_eq!(output, \"20\\n\");\n}\n\n#[test]\nfn test_max_value() {\n    let output = run_awk(\n        \"NR == 1 || $1 \u003e max { max = $1 } END { print max }\",\n        \"5\\n3\\n8\\n2\\n9\\n1\",\n    )\n    .unwrap();\n    assert_eq!(output, \"9\\n\");\n}\n\n#[test]\nfn test_line_count() {\n    let output = run_awk(\"END { print NR }\", \"a\\nb\\nc\\nd\\ne\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_field_sum_per_line() {\n    let output = run_awk(\n        \"{ sum = 0; for (i = 1; i \u003c= NF; i++) sum += $i; print sum }\",\n        \"1 2 3\\n4 5 6\",\n    )\n    .unwrap();\n    assert_eq!(output, \"6\\n15\\n\");\n}\n\n#[test]\nfn test_reverse_fields() {\n    let output = run_awk(\n        r#\"{ for (i = NF; i \u003e= 1; i--) printf \"%s \", $i; print \"\" }\"#,\n        \"a b c\",\n    )\n    .unwrap();\n    assert_eq!(output, \"c b a \\n\");\n}\n\n#[test]\nfn test_duplicate_lines() {\n    let output = run_awk(\"seen[$0]++ == 0 { print }\", \"a\\nb\\na\\nc\\nb\\na\").unwrap();\n    assert_eq!(output, \"a\\nb\\nc\\n\");\n}\n\n// ============================================================================\n// Edge Cases\n// ============================================================================\n\n#[test]\nfn test_empty_input() {\n    let output = run_awk(\"{ print }\", \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_empty_line() {\n    let output = run_awk(\"{ print NF }\", \"\\n\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_whitespace_only() {\n    let output = run_awk(\"{ print NF }\", \"   \\t  \").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_nonexistent_field() {\n    let output = run_awk(\"{ print $100 }\", \"a b c\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_zero_field() {\n    let output = run_awk(\"{ print $0 }\", \"hello\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_negative_field() {\n    // Negative field access via expression\n    let output = run_awk(\"{ x = -1; print $x }\", \"hello world\").unwrap();\n    // Most AWKs return empty for negative fields\n    assert!(output == \"\\n\" || output == \"hello world\\n\");\n}\n\n// ============================================================================\n// REGEX LITERALS IN FUNCTION CALLS\n// ============================================================================\n\n#[test]\nfn test_sub_with_regex_literal() {\n    let output = run_awk(\"BEGIN { s = \\\"hello\\\"; sub(/l/, \\\"L\\\", s); print s }\", \"\").unwrap();\n    assert_eq!(output, \"heLlo\\n\");\n}\n\n#[test]\nfn test_gsub_with_regex_literal() {\n    let output = run_awk(\"BEGIN { s = \\\"hello\\\"; gsub(/l/, \\\"L\\\", s); print s }\", \"\").unwrap();\n    assert_eq!(output, \"heLLo\\n\");\n}\n\n#[test]\nfn test_match_with_regex_literal() {\n    let output = run_awk(\"BEGIN { print match(\\\"hello\\\", /l+/) }\", \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_match_rstart_rlength() {\n    let output = run_awk(\"BEGIN { match(\\\"hello world\\\", /wor/); print RSTART, RLENGTH }\", \"\").unwrap();\n    assert_eq!(output, \"7 3\\n\");\n}\n\n#[test]\nfn test_split_with_regex_literal() {\n    let output = run_awk(\"BEGIN { n = split(\\\"a:b:c\\\", arr, /:/); print n, arr[1], arr[2], arr[3] }\", \"\").unwrap();\n    assert_eq!(output, \"3 a b c\\n\");\n}\n\n// ============================================================================\n// RANDOM NUMBER GENERATION\n// ============================================================================\n\n#[test]\nfn test_rand() {\n    let output = run_awk(\"BEGIN { x = rand(); print (x \u003e= 0 \u0026\u0026 x \u003c 1) ? \\\"ok\\\" : \\\"fail\\\" }\", \"\").unwrap();\n    assert_eq!(output, \"ok\\n\");\n}\n\n#[test]\nfn test_srand() {\n    // srand returns the previous seed and sets deterministic random state\n    // We use parentheses because print X \u003e Y is output redirection, not comparison\n    let output = run_awk(\"BEGIN { srand(42); print (rand() \u003e 0) }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// ============================================================================\n// ELSE AFTER SEMICOLON\n// ============================================================================\n\n#[test]\nfn test_else_after_semicolon() {\n    let output = run_awk(\"BEGIN { if (1) print \\\"yes\\\"; else print \\\"no\\\" }\", \"\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_else_after_semicolon_false() {\n    let output = run_awk(\"BEGIN { if (0) print \\\"yes\\\"; else print \\\"no\\\" }\", \"\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n// ============================================================================\n// DELETE ENTIRE ARRAY\n// ============================================================================\n\n#[test]\nfn test_delete_entire_array() {\n    let output = run_awk(\"BEGIN { a[1]=1; a[2]=2; delete a; print length(a) }\", \"\").unwrap();\n    // After deleting, iterating should find nothing\n    let output2 = run_awk(\"BEGIN { a[1]=1; a[2]=2; delete a; for(i in a) c++; print c+0 }\", \"\").unwrap();\n    assert!(output == \"0\\n\" || output2 == \"0\\n\");\n}\n\n// ============================================================================\n// FUNCTION OUTPUT\n// ============================================================================\n\n#[test]\nfn test_function_with_print() {\n    let output = run_awk(\"\n        function greet(name) { print \\\"Hello, \\\" name }\n        BEGIN { greet(\\\"World\\\") }\n    \", \"\").unwrap();\n    assert_eq!(output, \"Hello, World\\n\");\n}\n\n#[test]\nfn test_function_with_multiple_prints() {\n    let output = run_awk(\"\n        function count_to(n) { for (i=1; i\u003c=n; i++) print i }\n        BEGIN { count_to(3) }\n    \", \"\").unwrap();\n    assert_eq!(output, \"1\\n2\\n3\\n\");\n}\n\n// ============================================================================\n// SPECIAL ARRAYS (partial - ARGC/ARGV/ENVIRON need main.rs)\n// ============================================================================\n\n#[test]\nfn test_argc_zero() {\n    // When no files given, ARGC should be at least 1 (program name)\n    let output = run_awk(\"BEGIN { print (ARGC \u003e= 0) }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// ============================================================================\n// OUTPUT REDIRECTION TESTS (run via run_rawk_binary, not library)\n// These tests verify the parser handles \u003e properly for redirection\n// ============================================================================\n\n#[test]\nfn test_print_redirect_parsing() {\n    // Verify that print \"hello\" \u003e \"file\" parses correctly\n    // (doesn't treat \u003e as comparison)\n    let result = run_awk(r#\"BEGIN { print \"test\" \u003e \"/dev/null\" }\"#, \"\");\n    assert!(result.is_ok(), \"print with \u003e redirection should parse\");\n}\n\n#[test]\nfn test_print_append_parsing() {\n    // Verify that print \"hello\" \u003e\u003e \"file\" parses correctly\n    let result = run_awk(r#\"BEGIN { print \"test\" \u003e\u003e \"/dev/null\" }\"#, \"\");\n    assert!(result.is_ok(), \"print with \u003e\u003e append should parse\");\n}\n\n#[test]\nfn test_print_pipe_parsing() {\n    // Verify that print \"hello\" | \"cmd\" parses correctly\n    let result = run_awk(r#\"BEGIN { print \"test\" | \"cat \u003e /dev/null\" }\"#, \"\");\n    assert!(result.is_ok(), \"print with | pipe should parse\");\n}\n\n#[test]\nfn test_printf_redirect_parsing() {\n    // Verify printf with redirection parses\n    let result = run_awk(r#\"BEGIN { printf \"%s\\n\", \"test\" \u003e \"/dev/null\" }\"#, \"\");\n    assert!(result.is_ok(), \"printf with \u003e redirection should parse\");\n}\n\n#[test]\nfn test_comparison_in_print_with_parens() {\n    // If you want comparison in print, use parentheses\n    let output = run_awk(\"BEGIN { print (5 \u003e 3) }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_comparison_in_print_less_than() {\n    // \u003c doesn't need parens since it's not used for redirection in AWK\n    let output = run_awk(\"BEGIN { print 5 \u003c 3 }\", \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_comparison_ge_in_print() {\n    // \u003e= works without parens since it's unambiguous\n    let output = run_awk(\"BEGIN { print 5 \u003e= 3 }\", \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// === Hex and Octal Escape Sequences ===\n\n#[test]\nfn test_hex_escape_sequence() {\n    // \\x41 is 'A'\n    let output = run_awk(r#\"BEGIN { print \"\\x41\\x42\\x43\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"ABC\\n\");\n}\n\n#[test]\nfn test_hex_escape_lowercase() {\n    // \\x61 is 'a'\n    let output = run_awk(r#\"BEGIN { print \"\\x61\\x62\\x63\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"abc\\n\");\n}\n\n#[test]\nfn test_octal_escape_sequence() {\n    // \\101 is 'A' in octal\n    let output = run_awk(r#\"BEGIN { print \"\\101\\102\\103\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"ABC\\n\");\n}\n\n#[test]\nfn test_octal_escape_tab_newline() {\n    // \\011 is tab, \\012 is newline\n    let output = run_awk(r#\"BEGIN { print \"a\\011b\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"a\\tb\\n\");\n}\n\n#[test]\nfn test_mixed_escape_sequences() {\n    // Mix of hex and standard escapes\n    let output = run_awk(r#\"BEGIN { print \"\\x48ello\\n\\x57orld\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"Hello\\nWorld\\n\");\n}\n\n// === Paragraph Mode (RS = \"\") ===\n\n#[test]\nfn test_paragraph_mode_basic() {\n    let input = \"line1\\nline2\\n\\nline3\\nline4\\n\";\n    let output = run_awk(r#\"BEGIN { RS = \"\" } { print \"para:\", NR, $0 }\"#, input).unwrap();\n    // Should produce two paragraphs\n    assert!(output.contains(\"para: 1 line1\\nline2\"));\n    assert!(output.contains(\"para: 2 line3\\nline4\"));\n}\n\n#[test]\nfn test_paragraph_mode_multiple_blanks() {\n    // Multiple blank lines should count as one separator\n    let input = \"para1\\n\\n\\n\\npara2\\n\";\n    let output = run_awk(r#\"BEGIN { RS = \"\" } { print NR, $0 }\"#, input).unwrap();\n    let lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n    assert_eq!(lines.len(), 2);\n    assert!(output.contains(\"1 para1\"));\n    assert!(output.contains(\"2 para2\"));\n}\n\n#[test]\nfn test_paragraph_mode_nf() {\n    // In paragraph mode with default FS, fields are still whitespace-separated\n    let input = \"word1 word2\\nword3\\n\\nword4 word5\\n\";\n    let output = run_awk(r#\"BEGIN { RS = \"\" } { print NR, NF, $1, $NF }\"#, input).unwrap();\n    assert!(output.contains(\"1 3 word1 word3\"));\n    assert!(output.contains(\"2 2 word4 word5\"));\n}\n\n// === cmd | getline ===\n\n#[test]\nfn test_pipe_getline_basic() {\n    let output = run_awk(r#\"BEGIN { \"echo hello\" | getline x; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_pipe_getline_multiple() {\n    let output = run_awk(r#\"BEGIN {\n        while ((\"echo -e 'a\\nb\\nc'\" | getline line) \u003e 0) {\n            print \"got:\", line\n        }\n    }\"#, \"\").unwrap();\n    // The output depends on the shell's echo behavior\n    assert!(output.contains(\"got:\"));\n}\n\n#[test]\nfn test_pipe_getline_no_var() {\n    // Without var, getline sets $0\n    let output = run_awk(r#\"BEGIN { \"echo test\" | getline; print $0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n// === Array by Reference ===\n\n#[test]\nfn test_array_in_function() {\n    // Arrays should be passed by reference (modification visible outside)\n    let output = run_awk(r#\"\n        function modify(arr) { arr[1] = \"modified\" }\n        BEGIN {\n            a[1] = \"original\"\n            modify(a)\n            print a[1]\n        }\n    \"#, \"\").unwrap();\n    assert_eq!(output, \"modified\\n\");\n}\n\n// === FILENAME Variable ===\n\n#[test]\nfn test_filename_variable() {\n    // FILENAME should be set correctly\n    let output = run_awk(r#\"{ print FILENAME, $0 }\"#, \"test\").unwrap();\n    // When reading from stdin/input string, FILENAME may be empty\n    assert!(output.contains(\"test\"));\n}\n\n// === UTF-8 / Unicode Support ===\n\n#[test]\nfn test_utf8_length() {\n    // Length should count characters, not bytes\n    // \"hello\" is 5 chars, \"hllo\" is 5 chars, \"\" is 2 chars\n    let output = run_awk(r#\"BEGIN { print length(\"hello\"), length(\"hllo\"), length(\"\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"5 5 2\\n\");\n}\n\n#[test]\nfn test_utf8_substr() {\n    // Substr should use character positions\n    let output = run_awk(r#\"BEGIN { print substr(\"\", 2, 2) }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_utf8_index() {\n    // Index should return character position\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"6\\n\");\n}\n\n// === GAWK Extensions ===\n\n#[test]\nfn test_systime() {\n    // systime() should return a positive number (seconds since epoch)\n    let output = run_awk(r#\"BEGIN { print (systime() \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_strftime_basic() {\n    // strftime with explicit timestamp\n    let output = run_awk(r#\"BEGIN { print strftime(\"%Y-%m-%d\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1970-01-01\\n\");\n}\n\n#[test]\nfn test_strftime_time() {\n    // strftime for time\n    let output = run_awk(r#\"BEGIN { print strftime(\"%H:%M:%S\", 3661) }\"#, \"\").unwrap();\n    assert_eq!(output, \"01:01:01\\n\");\n}\n\n#[test]\nfn test_mktime() {\n    // mktime should parse date string to timestamp\n    let output = run_awk(r#\"BEGIN { print mktime(\"1970 1 1 0 0 0\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_mktime_date() {\n    // mktime with a specific date\n    let output = run_awk(r#\"BEGIN { print mktime(\"2000 1 1 0 0 0\") }\"#, \"\").unwrap();\n    // 2000-01-01 00:00:00 UTC = 946684800 seconds since epoch\n    assert_eq!(output, \"946684800\\n\");\n}\n\n#[test]\nfn test_gensub_global() {\n    // gensub with global replacement\n    let output = run_awk(r#\"BEGIN { print gensub(\"o\", \"0\", \"g\", \"hello world\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hell0 w0rld\\n\");\n}\n\n#[test]\nfn test_gensub_first() {\n    // gensub with first occurrence\n    let output = run_awk(r#\"BEGIN { print gensub(\"o\", \"0\", 1, \"hello world\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hell0 world\\n\");\n}\n\n#[test]\nfn test_gensub_nth() {\n    // gensub with nth occurrence\n    let output = run_awk(r#\"BEGIN { print gensub(\"o\", \"0\", 2, \"hello world\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello w0rld\\n\");\n}\n\n#[test]\nfn test_gensub_returns_original() {\n    // gensub returns result, doesn't modify original (unlike gsub)\n    let output = run_awk(r#\"BEGIN { x = \"hello\"; y = gensub(\"l\", \"L\", \"g\", x); print x, y }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello heLLo\\n\");\n}\n\n#[test]\nfn test_beginfile() {\n    // BEGINFILE is executed at start of each input\n    let output = run_awk(r#\"BEGINFILE { print \"start\" } { print $0 }\"#, \"a\\nb\\n\").unwrap();\n    assert!(output.starts_with(\"start\\n\"));\n    assert!(output.contains(\"a\\n\"));\n    assert!(output.contains(\"b\\n\"));\n}\n\n#[test]\nfn test_endfile() {\n    // ENDFILE is executed at end of each input\n    let output = run_awk(r#\"{ print $0 } ENDFILE { print \"done\" }\"#, \"x\\ny\\n\").unwrap();\n    assert!(output.ends_with(\"done\\n\"));\n}\n\n#[test]\nfn test_asort() {\n    // asort sorts array values\n    let output = run_awk(r#\"BEGIN {\n        a[1] = \"cherry\"\n        a[2] = \"apple\"\n        a[3] = \"banana\"\n        n = asort(a)\n        for (i = 1; i \u003c= n; i++) print a[i]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"apple\\nbanana\\ncherry\\n\");\n}\n\n#[test]\nfn test_asorti() {\n    // asorti sorts array indices\n    let output = run_awk(r#\"BEGIN {\n        a[\"cherry\"] = 1\n        a[\"apple\"] = 2\n        a[\"banana\"] = 3\n        n = asorti(a, b)\n        for (i = 1; i \u003c= n; i++) print b[i]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"apple\\nbanana\\ncherry\\n\");\n}\n\n#[test]\nfn test_patsplit() {\n    // patsplit extracts matching fields\n    let output = run_awk(r#\"BEGIN {\n        n = patsplit(\"the:quick:fox\", a, \"[a-z]+\")\n        for (i = 1; i \u003c= n; i++) print a[i]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"the\\nquick\\nfox\\n\");\n}\n\n// === FPAT and FIELDWIDTHS ===\n\n#[test]\nfn test_fpat_basic() {\n    // FPAT matches field content, not separators\n    let output = run_awk(r#\"BEGIN { FPAT = \"[^,]+\" } { print $1, $2 }\"#, \"hello,world\").unwrap();\n    assert_eq!(output, \"hello world\\n\");\n}\n\n#[test]\nfn test_fpat_word_pattern() {\n    // FPAT matches word characters\n    let output = run_awk(r#\"BEGIN { FPAT = \"[A-Za-z]+\" } { print $1, $2, $3 }\"#, \"Hello123World456Test\").unwrap();\n    assert_eq!(output, \"Hello World Test\\n\");\n}\n\n#[test]\nfn test_fieldwidths() {\n    // FIELDWIDTHS splits by character positions\n    let output = run_awk(r#\"BEGIN { FIELDWIDTHS = \"3 4 3\" } { print $1, $2, $3 }\"#, \"abcdefghij\").unwrap();\n    assert_eq!(output, \"abc defg hij\\n\");\n}\n\n#[test]\nfn test_fieldwidths_short_record() {\n    // FIELDWIDTHS handles records shorter than specified widths\n    let output = run_awk(r#\"BEGIN { FIELDWIDTHS = \"5 5 5\" } { print NF }\"#, \"abcdefgh\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_procinfo_version() {\n    // PROCINFO[\"version\"] should return the rawk version\n    let output = run_awk(r#\"BEGIN { print (PROCINFO[\"version\"] != \"\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_procinfo_pid() {\n    // PROCINFO[\"pid\"] should return a positive number\n    let output = run_awk(r#\"BEGIN { print (PROCINFO[\"pid\"] \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// === Additional Built-in Function Tests ===\n\n#[test]\nfn test_atan2() {\n    let output = run_awk(r#\"BEGIN { print int(atan2(1, 1) * 1000) }\"#, \"\").unwrap();\n    // atan2(1,1) = pi/4  0.785\n    assert!(output.trim().parse::\u003ci32\u003e().unwrap() \u003e 700);\n}\n\n#[test]\nfn test_exp() {\n    let output = run_awk(r#\"BEGIN { print int(exp(1) * 100) }\"#, \"\").unwrap();\n    // e  2.718\n    assert_eq!(output, \"271\\n\");\n}\n\n#[test]\nfn test_log() {\n    let output = run_awk(r#\"BEGIN { print int(log(10) * 100) }\"#, \"\").unwrap();\n    // ln(10)  2.302\n    assert_eq!(output, \"230\\n\");\n}\n\n#[test]\nfn test_system() {\n    let output = run_awk(r#\"BEGIN { ret = system(\"true\"); print ret }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_close_nonexistent() {\n    // close() on non-existent file returns -1\n    let output = run_awk(r#\"BEGIN { print close(\"nonexistent\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"-1\\n\");\n}\n\n#[test]\nfn test_fflush() {\n    // fflush() without args flushes everything\n    let output = run_awk(r#\"BEGIN { print \"test\"; fflush(); print \"done\" }\"#, \"\").unwrap();\n    assert!(output.contains(\"test\") \u0026\u0026 output.contains(\"done\"));\n}\n\n#[test]\nfn test_length_no_arg_with_record() {\n    let output = run_awk(r#\"{ print length() }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_substr_start_zero() {\n    // AWK treats start \u003c 1 as 1\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 0, 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"hel\\n\");\n}\n\n#[test]\nfn test_substr_no_length() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"llo\\n\");\n}\n\n#[test]\nfn test_match_no_match() {\n    let output = run_awk(r#\"BEGIN { print match(\"hello\", \"xyz\"), RSTART, RLENGTH }\"#, \"\").unwrap();\n    assert_eq!(output, \"0 0 -1\\n\");\n}\n\n#[test]\nfn test_split_default_fs() {\n    // split with no third arg uses FS\n    let output = run_awk(r#\"BEGIN { n = split(\"a b c\", arr); print n, arr[1] }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 a\\n\");\n}\n\n#[test]\nfn test_gsub_returns_count() {\n    let output = run_awk(r#\"BEGIN { x = \"aaa\"; n = gsub(\"a\", \"b\", x); print n, x }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 bbb\\n\");\n}\n\n#[test]\nfn test_sub_returns_count() {\n    let output = run_awk(r#\"BEGIN { x = \"aaa\"; n = sub(\"a\", \"b\", x); print n, x }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 baa\\n\");\n}\n\n#[test]\nfn test_gensub_default_target() {\n    // gensub with no 4th arg uses $0\n    let output = run_awk(r#\"{ print gensub(\"o\", \"0\", \"g\") }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"hell0 w0rld\\n\");\n}\n\n// === More Edge Cases ===\n\n#[test]\nfn test_multiple_patterns_same_line() {\n    let output = run_awk(r#\"/a/ { print \"A\" } /b/ { print \"B\" }\"#, \"ab\").unwrap();\n    assert_eq!(output, \"A\\nB\\n\");\n}\n\n#[test]\nfn test_field_beyond_nf() {\n    // Accessing field beyond NF returns empty string\n    let output = run_awk(r#\"{ print $100 == \"\" }\"#, \"a b\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_assign_to_field_extends_nf() {\n    let output = run_awk(r#\"{ $5 = \"x\"; print NF, $5 }\"#, \"a b\").unwrap();\n    assert_eq!(output, \"5 x\\n\");\n}\n\n#[test]\nfn test_nf_zero() {\n    // Empty line has NF = 0\n    let output = run_awk(r#\"{ print NF }\"#, \"\\n\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_negative_field_number() {\n    // In AWK, $-1 and other negative indices typically return $0\n    let output = run_awk(r#\"{ print $(-1) }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"a b c\\n\");  // Returns $0\n}\n\n#[test]\nfn test_array_multidim() {\n    let output = run_awk(r#\"BEGIN { a[1,2] = \"x\"; print a[1,2] }\"#, \"\").unwrap();\n    assert_eq!(output, \"x\\n\");\n}\n\n#[test]\nfn test_delete_entire_array_iteration() {\n    let output = run_awk(r#\"BEGIN { a[1]=1; a[2]=2; delete a; for(k in a) n++; print n+0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_uninitialized_numeric() {\n    let output = run_awk(r#\"BEGIN { print x + 5 }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_uninitialized_string() {\n    let output = run_awk(r#\"BEGIN { print x \"\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_numeric_string_gt_comparison() {\n    let output = run_awk(r#\"BEGIN { print (\"10\" \u003e \"9\") }\"#, \"\").unwrap();\n    // Numeric comparison: 10 \u003e 9\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_string_literal_comparison() {\n    let output = run_awk(r#\"BEGIN { print (\"abc\" \u003c \"abd\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_printf_width_precision() {\n    let output = run_awk(r#\"BEGIN { printf \"%10.3f\\n\", 3.14159 }\"#, \"\").unwrap();\n    assert!(output.contains(\"3.142\"));\n}\n\n#[test]\nfn test_printf_negative_width() {\n    let output = run_awk(r#\"BEGIN { printf \"%-5s|\\n\", \"ab\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"ab   |\\n\");\n}\n\n#[test]\nfn test_concatenation_with_number() {\n    let output = run_awk(r#\"BEGIN { print \"x\" 5 \"y\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"x5y\\n\");\n}\n\n#[test]\nfn test_regex_in_expression() {\n    // Bare regex matches against $0\n    let output = run_awk(r#\"{ print /hello/ }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_not_regex() {\n    let output = run_awk(r#\"{ print !/hello/ }\"#, \"goodbye world\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_do_while_false() {\n    // do-while always runs at least once\n    let output = run_awk(r#\"BEGIN { do { print \"x\" } while (0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"x\\n\");\n}\n\n#[test]\nfn test_for_empty_parts() {\n    let output = run_awk(r#\"BEGIN { i=0; for (;;) { if (++i \u003e 2) break; print i } }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n2\\n\");\n}\n\n#[test]\nfn test_return_no_value() {\n    let output = run_awk(r#\"function f() { return } BEGIN { x = f(); print x+0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_function_local_vars() {\n    // Extra params act as local variables\n    let output = run_awk(r#\"function f(a,    local) { local = 5; return local } BEGIN { print f(1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n// === More Coverage Tests ===\n\n#[test]\nfn test_nextfile() {\n    // nextfile skips to next input file\n    let output = run_awk(r#\"FNR == 2 { nextfile } { print }\"#, \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"a\\n\");\n}\n\n#[test]\nfn test_exit_with_code() {\n    // exit with a code - exit takes effect after current rule\n    let output = run_awk(r#\"BEGIN { exit 0 } BEGIN { print \"second begin\" }\"#, \"\").unwrap();\n    // Exit runs END rules, but stops further BEGIN/main processing\n    assert!(!output.contains(\"second begin\"));\n}\n\n#[test]\nfn test_print_redirect_truncate() {\n    // print to file (truncate mode)\n    let output = run_awk(r#\"BEGIN { print \"test\" \u003e \"/dev/null\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_print_redirect_append() {\n    // print to file (append mode)\n    let output = run_awk(r#\"BEGIN { print \"test\" \u003e\u003e \"/dev/null\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_print_redirect_pipe() {\n    // print through pipe\n    let output = run_awk(r#\"BEGIN { print \"hello\" | \"cat\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");  // output goes to pipe, not stdout\n}\n\n#[test]\nfn test_printf_redirect() {\n    let output = run_awk(r#\"BEGIN { printf \"test\\n\" \u003e \"/dev/null\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");\n}\n\n#[test]\nfn test_getline_from_file() {\n    // getline from file\n    let output = run_awk(r#\"BEGIN { while ((getline line \u003c \"/etc/hostname\") \u003e 0) { print line; break } }\"#, \"\").unwrap();\n    assert!(!output.is_empty());\n}\n\n#[test]\nfn test_getline_from_pipe() {\n    let output = run_awk(r#\"BEGIN { \"echo test\" | getline x; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n#[test]\nfn test_getline_sets_nf() {\n    let output = run_awk(r#\"BEGIN { \"echo a b c\" | getline; print NF }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_strftime_formats() {\n    // Test various strftime format specifiers\n    let output = run_awk(r#\"BEGIN { print strftime(\"%Y\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1970\\n\");\n    \n    let output = run_awk(r#\"BEGIN { print strftime(\"%m\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"01\\n\");\n    \n    let output = run_awk(r#\"BEGIN { print strftime(\"%d\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"01\\n\");\n}\n\n#[test]\nfn test_strftime_weekday() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%a\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"Thu\\n\");  // 1970-01-01 was Thursday\n}\n\n#[test]\nfn test_strftime_month_name() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%b\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"Jan\\n\");\n}\n\n#[test]\nfn test_mktime_with_time() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"1970 1 1 1 0 0\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"3600\\n\");  // 1 hour = 3600 seconds\n}\n\n#[test]\nfn test_mktime_invalid() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"invalid\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"-1\\n\");\n}\n\n#[test]\nfn test_gensub_no_match() {\n    let output = run_awk(r#\"BEGIN { print gensub(\"x\", \"y\", \"g\", \"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_gensub_with_ampersand() {\n    let output = run_awk(r#\"BEGIN { print gensub(\"l\", \"[\u0026]\", \"g\", \"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"he[l][l]o\\n\");\n}\n\n#[test]\nfn test_asort_empty() {\n    let output = run_awk(r#\"BEGIN { n = asort(a); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_asorti_with_dest() {\n    let output = run_awk(r#\"BEGIN { a[\"z\"]=1; a[\"a\"]=2; n = asorti(a, b); print n, b[1] }\"#, \"\").unwrap();\n    assert_eq!(output, \"2 a\\n\");\n}\n\n#[test]\nfn test_patsplit_with_seps() {\n    let output = run_awk(r#\"BEGIN { \n        n = patsplit(\"a1b2c\", arr, \"[0-9]+\", seps)\n        print n, arr[1], arr[2], seps[0], seps[1]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"2 1 2 a b\\n\");\n}\n\n#[test]\nfn test_comparison_mixed_types() {\n    // String vs number comparison\n    let output = run_awk(r#\"BEGIN { print (\"10\" == 10) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_comparison_string_concat() {\n    // String comparison  \n    let output = run_awk(r#\"BEGIN { print (\"aa\" \u003c \"ab\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_regex_special_chars() {\n    let output = run_awk(r#\"/\\[test\\]/ { print \"found\" }\"#, \"[test]\").unwrap();\n    assert_eq!(output, \"found\\n\");\n}\n\n#[test]\nfn test_regex_case_sensitive() {\n    let output = run_awk(r#\"/Hello/ { print \"yes\" } !/Hello/ { print \"no\" }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n#[test]\nfn test_field_separator_regex() {\n    let output = run_awk(r#\"BEGIN { FS = \"[,;]\" } { print $2 }\"#, \"a,b;c\").unwrap();\n    assert_eq!(output, \"b\\n\");\n}\n\n#[test]\nfn test_ors() {\n    // ORS - output record separator (need to implement if not working)\n    let output = run_awk(r#\"{ printf \"%s;\", $0 }\"#, \"a\\nb\").unwrap();\n    assert_eq!(output, \"a;b;\");\n}\n\n#[test]\nfn test_subsep() {\n    let output = run_awk(r#\"BEGIN { a[1,2] = \"x\"; for (k in a) print k }\"#, \"\").unwrap();\n    assert!(output.contains(\"\\x1c\"));  // Default SUBSEP\n}\n\n#[test]\nfn test_custom_subsep() {\n    let output = run_awk(r#\"BEGIN { SUBSEP = \":\"; a[1,2] = \"x\"; for (k in a) print k }\"#, \"\").unwrap();\n    assert_eq!(output, \"1:2\\n\");\n}\n\n#[test]\nfn test_convfmt() {\n    let output = run_awk(r#\"BEGIN { CONVFMT = \"%.2f\"; x = 3.14159; print x \"\" }\"#, \"\").unwrap();\n    assert!(output.contains(\"3.14\"));\n}\n\n#[test]\nfn test_ofmt() {\n    let output = run_awk(r#\"BEGIN { OFMT = \"%.2f\"; print 3.14159 }\"#, \"\").unwrap();\n    assert!(output.contains(\"3.14\"));\n}\n\n#[test]\nfn test_environ() {\n    let output = run_awk(r#\"BEGIN { print (ENVIRON[\"PATH\"] != \"\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_argv_access() {\n    // In our test harness ARGV may be empty, just test it doesn't crash\n    let output = run_awk(r#\"BEGIN { print ARGV[0] \"\" }\"#, \"\").unwrap();\n    assert!(output.ends_with(\"\\n\"));\n}\n\n#[test]\nfn test_argc_type() {\n    // ARGC should be a number\n    let output = run_awk(r#\"BEGIN { print ARGC + 0 \u003e= 0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_fnr_vs_nr() {\n    let output = run_awk(r#\"{ print NR, FNR }\"#, \"a\\nb\\nc\").unwrap();\n    assert!(output.contains(\"1 1\") \u0026\u0026 output.contains(\"2 2\") \u0026\u0026 output.contains(\"3 3\"));\n}\n\n#[test]\nfn test_modify_nf() {\n    // Setting NF to smaller value truncates fields\n    let output = run_awk(r#\"{ NF = 2; print $0 }\"#, \"a b c d\").unwrap();\n    assert_eq!(output, \"a b\\n\");\n}\n\n#[test]\nfn test_extend_nf() {\n    // Setting NF to larger value extends fields\n    let output = run_awk(r#\"{ NF = 5; print NF, $5 == \"\" }\"#, \"a b\").unwrap();\n    assert_eq!(output, \"5 1\\n\");\n}\n\n#[test]\nfn test_dollar_zero_assignment() {\n    // Assigning to $0 re-splits\n    let output = run_awk(r#\"{ $0 = \"x y z\"; print $2 }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"y\\n\");\n}\n\n#[test]\nfn test_expr_pattern() {\n    // Expression as pattern\n    let output = run_awk(r#\"NR == 2 { print \"second\" }\"#, \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"second\\n\");\n}\n\n#[test]\nfn test_beginfile_endfile() {\n    let output = run_awk(r#\"BEGINFILE { print \"start\" } ENDFILE { print \"end\" }\"#, \"test\").unwrap();\n    assert!(output.contains(\"start\") \u0026\u0026 output.contains(\"end\"));\n}\n\n#[test]\nfn test_exponentiation_negative() {\n    let output = run_awk(r#\"BEGIN { print 2^(-2) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0.25\\n\");\n}\n\n#[test]\nfn test_modulo_negative() {\n    let output = run_awk(r#\"BEGIN { print -7 % 3 }\"#, \"\").unwrap();\n    assert_eq!(output, \"-1\\n\");\n}\n\n#[test]\nfn test_division_by_zero() {\n    // Division by zero in AWK typically returns inf\n    let output = run_awk(r#\"BEGIN { x = 1/0; print (x \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");  // inf \u003e 0\n}\n\n#[test]\nfn test_string_to_number_leading_whitespace() {\n    let output = run_awk(r#\"BEGIN { print \"  42\" + 0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_string_to_number_trailing_text() {\n    let output = run_awk(r#\"BEGIN { print \"42abc\" + 0 }\"#, \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_empty_regex() {\n    // Empty regex matches anything\n    let output = run_awk(r#\"// { print \"match\" }\"#, \"test\").unwrap();\n    assert_eq!(output, \"match\\n\");\n}\n\n#[test]\nfn test_match_operator_with_var() {\n    let output = run_awk(r#\"{ if ($0 ~ \"test\") print \"yes\" }\"#, \"test\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_not_match_with_string() {\n    let output = run_awk(r#\"{ if ($0 !~ \"xyz\") print \"no match\" }\"#, \"test\").unwrap();\n    assert_eq!(output, \"no match\\n\");\n}\n\n#[test]\nfn test_in_with_multi_subscript() {\n    // Use SUBSEP to form the key for multi-dimensional access\n    let output = run_awk(r#\"BEGIN { a[1,2]=1; key = 1 SUBSEP 2; print (key in a) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_delete_non_existent() {\n    let output = run_awk(r#\"BEGIN { delete a[1]; print (1 in a) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_printf_all_formats() {\n    let output = run_awk(r#\"BEGIN { printf \"%c%d%e%f%g%o%s%x%%\\n\", 65, 42, 1.5, 2.5, 3.5, 8, \"hi\", 255 }\"#, \"\").unwrap();\n    assert!(output.contains(\"A\") \u0026\u0026 output.contains(\"42\") \u0026\u0026 output.contains(\"hi\") \u0026\u0026 output.contains(\"ff\") \u0026\u0026 output.contains(\"%\"));\n}\n\n#[test]\nfn test_printf_fixed_width() {\n    let output = run_awk(r#\"BEGIN { printf \"%5s\\n\", \"ab\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"   ab\\n\");\n}\n\n#[test]\nfn test_printf_fixed_precision() {\n    let output = run_awk(r#\"BEGIN { printf \"%.2f\\n\", 3.14159 }\"#, \"\").unwrap();\n    assert_eq!(output, \"3.14\\n\");\n}\n\n#[test]\nfn test_short_circuit_and_false() {\n    // Second operand should not be evaluated\n    let output = run_awk(r#\"BEGIN { x = 0; if (0 \u0026\u0026 (x = 1)) {} print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_short_circuit_or_true() {\n    // Second operand should not be evaluated\n    let output = run_awk(r#\"BEGIN { x = 0; if (1 || (x = 1)) {} print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_compound_assignment_modulo() {\n    let output = run_awk(r#\"BEGIN { x = 10; x %= 3; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_compound_assignment_power() {\n    let output = run_awk(r#\"BEGIN { x = 2; x ^= 3; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"8\\n\");\n}\n\n#[test]\nfn test_compound_assignment_divide() {\n    let output = run_awk(r#\"BEGIN { x = 10; x /= 2; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_nested_function_call() {\n    let output = run_awk(r#\"BEGIN { print substr(toupper(\"hello\"), 2, 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"ELL\\n\");\n}\n\n#[test]\nfn test_gsub_on_field() {\n    let output = run_awk(r#\"{ gsub(/o/, \"0\", $1); print $0 }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"hell0 world\\n\");\n}\n\n#[test]\nfn test_split_empty_string() {\n    let output = run_awk(r#\"BEGIN { n = split(\"\", a); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_index_empty() {\n    let output = run_awk(r#\"BEGIN { print index(\"\", \"x\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_substr_beyond_length() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hi\", 10) }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_multiple_begin() {\n    let output = run_awk(r#\"BEGIN { x = 1 } BEGIN { x += 1 } BEGIN { print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_multiple_end() {\n    let output = run_awk(r#\"END { x = 1 } END { x += 1 } END { print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_default_action() {\n    // Pattern without action prints $0\n    let output = run_awk(r#\"/test/\"#, \"test\").unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n#[test]\nfn test_empty_pattern_action() {\n    // No pattern means always match\n    let output = run_awk(r#\"{ print \"line\" }\"#, \"a\\nb\").unwrap();\n    assert_eq!(output, \"line\\nline\\n\");\n}\n\n// === More builtin coverage ===\n\n#[test]\nfn test_sin_cos_zero() {\n    let output = run_awk(r#\"BEGIN { print int(sin(0)), int(cos(0)) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0 1\\n\");\n}\n\n#[test]\nfn test_atan2_quadrants() {\n    let output = run_awk(r#\"BEGIN { print (atan2(1, 1) \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_exp_log_inverse() {\n    let output = run_awk(r#\"BEGIN { x = 5; print int(log(exp(x))) }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_sqrt_perfect() {\n    let output = run_awk(r#\"BEGIN { print sqrt(16) }\"#, \"\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_int_positive() {\n    let output = run_awk(r#\"BEGIN { print int(5.9) }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_int_negative() {\n    let output = run_awk(r#\"BEGIN { print int(-5.9) }\"#, \"\").unwrap();\n    assert_eq!(output, \"-5\\n\");\n}\n\n#[test]\nfn test_array_count_loop() {\n    // Count array elements with for-in\n    let output = run_awk(r#\"BEGIN { a[1]=1; a[2]=2; a[3]=3; for(k in a) n++; print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_gsub_no_third_arg() {\n    // gsub without third arg uses $0\n    let output = run_awk(r#\"{ gsub(\"o\", \"0\"); print }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"hell0\\n\");\n}\n\n#[test]\nfn test_sub_no_third_arg() {\n    let output = run_awk(r#\"{ sub(\"o\", \"0\"); print }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"hell0\\n\");\n}\n\n#[test]\nfn test_match_positions() {\n    let output = run_awk(r#\"BEGIN { match(\"hello world\", \"wor\"); print RSTART, RLENGTH }\"#, \"\").unwrap();\n    assert_eq!(output, \"7 3\\n\");\n}\n\n#[test]\nfn test_split_with_regex() {\n    let output = run_awk(r#\"BEGIN { n = split(\"a1b2c\", a, \"[0-9]\"); print n, a[1], a[3] }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 a c\\n\");\n}\n\n#[test]\nfn test_sprintf_octal() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%o\", 8) }\"#, \"\").unwrap();\n    assert_eq!(output, \"10\\n\");\n}\n\n#[test]\nfn test_sprintf_hex_upper() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%X\", 255) }\"#, \"\").unwrap();\n    assert_eq!(output, \"FF\\n\");\n}\n\n#[test]\nfn test_sprintf_char() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%c\", 65) }\"#, \"\").unwrap();\n    assert_eq!(output, \"A\\n\");\n}\n\n#[test]\nfn test_sprintf_scientific() {\n    let output = run_awk(r#\"BEGIN { s = sprintf(\"%e\", 1234.5); print (s ~ \"e\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_tolower_mixed() {\n    let output = run_awk(r#\"BEGIN { print tolower(\"HeLLo WoRLD\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello world\\n\");\n}\n\n#[test]\nfn test_toupper_mixed() {\n    let output = run_awk(r#\"BEGIN { print toupper(\"HeLLo WoRLD\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"HELLO WORLD\\n\");\n}\n\n#[test]\nfn test_index_missing() {\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"xyz\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_substr_negative_length() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 2, -1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_system_false() {\n    let output = run_awk(r#\"BEGIN { print system(\"false\") }\"#, \"\").unwrap();\n    assert!(output.trim() != \"0\");  // false returns non-zero\n}\n\n#[test]\nfn test_rand_range() {\n    let output = run_awk(r#\"BEGIN { x = rand(); print (x \u003e= 0 \u0026\u0026 x \u003c 1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_srand_returns_prev() {\n    let output = run_awk(r#\"BEGIN { srand(1); prev = srand(2); print (prev \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_close_success() {\n    let output = run_awk(r#\"BEGIN { print \"test\" \u003e \"/tmp/rawk_test_close\"; print close(\"/tmp/rawk_test_close\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n// === More stmt coverage ===\n\n#[test]\nfn test_if_else_block() {\n    let output = run_awk(r#\"BEGIN { if (0) { print \"yes\" } else { print \"no\" } }\"#, \"\").unwrap();\n    assert_eq!(output, \"no\\n\");\n}\n\n#[test]\nfn test_nested_if() {\n    let output = run_awk(r#\"BEGIN { if (1) if (1) print \"deep\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"deep\\n\");\n}\n\n#[test]\nfn test_for_no_body() {\n    let output = run_awk(r#\"BEGIN { for (i=0; i\u003c3; i++); print i }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_while_never_runs() {\n    let output = run_awk(r#\"BEGIN { while (0) print \"never\"; print \"done\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"done\\n\");\n}\n\n#[test]\nfn test_getline_eof() {\n    let output = run_awk(r#\"BEGIN { ret = getline \u003c \"/dev/null\"; print ret }\"#, \"\").unwrap();\n    // /dev/null returns EOF immediately\n    assert!(output.trim() == \"0\" || output.trim() == \"-1\");\n}\n\n#[test]\nfn test_printf_no_args() {\n    let output = run_awk(r#\"BEGIN { printf \"hello\\n\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_printf_literal_percent() {\n    let output = run_awk(r#\"BEGIN { printf \"50%%\\n\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"50%\\n\");\n}\n\n#[test]\nfn test_print_empty() {\n    // print with no args prints $0\n    let output = run_awk(r#\"{ print }\"#, \"test\").unwrap();\n    assert_eq!(output, \"test\\n\");\n}\n\n#[test]\nfn test_simulated_2d_array() {\n    // AWK simulates multi-dimensional arrays with SUBSEP\n    let output = run_awk(r#\"BEGIN { a[1,2] = \"x\"; print a[1,2] }\"#, \"\").unwrap();\n    assert_eq!(output, \"x\\n\");\n}\n\n#[test]\nfn test_array_in_loop() {\n    let output = run_awk(r#\"BEGIN { for (i=1; i\u003c=3; i++) a[i]=i*2; print a[2] }\"#, \"\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_function_array_param() {\n    let output = run_awk(r#\"function f(arr) { return arr[1] } BEGIN { a[1]=\"x\"; print f(a) }\"#, \"\").unwrap();\n    assert_eq!(output, \"x\\n\");\n}\n\n#[test]\nfn test_function_modify_global() {\n    let output = run_awk(r#\"function f() { x = 5 } BEGIN { f(); print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"5\\n\");\n}\n\n#[test]\nfn test_expr_as_stmt() {\n    let output = run_awk(r#\"BEGIN { 1+1; print \"ok\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"ok\\n\");\n}\n\n#[test]\nfn test_empty_block() {\n    let output = run_awk(r#\"BEGIN { } { } END { print \"end\" }\"#, \"input\").unwrap();\n    assert_eq!(output, \"end\\n\");\n}\n\n// === More lexer edge cases ===\n\n#[test]\nfn test_very_long_string() {\n    let long = \"a\".repeat(1000);\n    let program = format!(r#\"BEGIN {{ print \"{}\" }}\"#, long);\n    let output = run_awk(\u0026program, \"\").unwrap();\n    assert_eq!(output.len(), 1001);  // 1000 chars + newline\n}\n\n#[test]\nfn test_unicode_string() {\n    let output = run_awk(r#\"BEGIN { print \"hello \" }\"#, \"\").unwrap();\n    assert!(output.contains(\"\"));\n}\n\n#[test]\nfn test_multiple_statements_one_line() {\n    let output = run_awk(r#\"BEGIN { x=1; y=2; z=3; print x+y+z }\"#, \"\").unwrap();\n    assert_eq!(output, \"6\\n\");\n}\n\n#[test]\nfn test_regex_empty_match() {\n    let output = run_awk(r#\"BEGIN { print match(\"test\", \".*\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_field_zero_assign() {\n    let output = run_awk(r#\"{ $0 = toupper($0); print }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"HELLO\\n\");\n}\n\n#[test]\nfn test_complex_expression() {\n    let output = run_awk(r#\"BEGIN { print ((1+2)*3-4)/2 }\"#, \"\").unwrap();\n    assert_eq!(output, \"2.5\\n\");\n}\n\n#[test]\nfn test_chained_comparisons() {\n    let output = run_awk(r#\"BEGIN { print (1 \u003c 2) \u0026\u0026 (2 \u003c 3) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_ternary_nested() {\n    let output = run_awk(r#\"BEGIN { print 1 ? (0 ? \"a\" : \"b\") : \"c\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"b\\n\");\n}\n\n#[test]\nfn test_field_after_modify() {\n    let output = run_awk(r#\"{ $1 = \"X\"; print $1, $2 }\"#, \"a b\").unwrap();\n    assert_eq!(output, \"X b\\n\");\n}\n\n#[test]\nfn test_nf_after_split() {\n    let output = run_awk(r#\"BEGIN { FS=\":\" } { print NF }\"#, \"a:b:c:d\").unwrap();\n    assert_eq!(output, \"4\\n\");\n}\n\n#[test]\nfn test_match_ampersand_replacement() {\n    let output = run_awk(r#\"BEGIN { x = \"hello\"; gsub(\"l\", \"[\u0026]\", x); print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"he[l][l]o\\n\");\n}\n\n#[test]\nfn test_split_single_char_sep() {\n    let output = run_awk(r#\"BEGIN { n = split(\"a,b,c\", arr, \",\"); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_getline_from_command() {\n    let output = run_awk(r#\"BEGIN { cmd = \"echo hello\"; cmd | getline x; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_close_pipe() {\n    let output = run_awk(r#\"BEGIN { print \"x\" | \"cat\"; close(\"cat\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");  // Output goes to pipe\n}\n\n#[test]\nfn test_mktime_full() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"2000 1 1 0 0 0\") }\"#, \"\").unwrap();\n    // Jan 1, 2000 00:00:00 UTC = 946684800\n    assert_eq!(output.trim(), \"946684800\");\n}\n\n#[test]\nfn test_gensub_nth_occurrence() {\n    // \"banana\" has 3 a's: positions 2, 4, 6. The 2nd \"a\" is at position 4\n    let output = run_awk(r#\"BEGIN { print gensub(\"a\", \"X\", 2, \"banana\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"banXna\\n\");\n}\n\n#[test]\nfn test_asort_numeric() {\n    let output = run_awk(r#\"BEGIN { a[1]=3; a[2]=1; a[3]=2; asort(a); print a[1], a[2], a[3] }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 2 3\\n\");\n}\n\n#[test]\nfn test_asorti_string() {\n    let output = run_awk(r#\"BEGIN { a[\"c\"]=1; a[\"a\"]=2; a[\"b\"]=3; asorti(a); print a[1], a[2], a[3] }\"#, \"\").unwrap();\n    assert_eq!(output, \"a b c\\n\");\n}\n\n#[test]\nfn test_patsplit_simple() {\n    let output = run_awk(r#\"BEGIN { n = patsplit(\"the:quick:fox\", a, \"[a-z]+\"); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_strftime_all_specs() {\n    let output = run_awk(r#\"BEGIN { t = 0; print strftime(\"%H:%M:%S\", t) }\"#, \"\").unwrap();\n    assert_eq!(output, \"00:00:00\\n\");\n}\n\n#[test]\nfn test_systime_positive() {\n    let output = run_awk(r#\"BEGIN { print (systime() \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n// === Error path and edge case tests ===\n\n#[test]\nfn test_split_missing_array() {\n    let result = run_awk(r#\"BEGIN { split(\"a:b\", 123, \":\") }\"#, \"\");\n    assert!(result.is_err() || result.unwrap().contains(\"error\"));\n}\n\n#[test]\nfn test_asort_error() {\n    let result = run_awk(r#\"BEGIN { asort(123) }\"#, \"\");\n    assert!(result.is_err() || !result.unwrap().is_empty());\n}\n\n#[test]\nfn test_patsplit_error() {\n    let result = run_awk(r#\"BEGIN { patsplit(\"test\", 123, \"[0-9]\") }\"#, \"\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_gsub_with_field() {\n    let output = run_awk(r#\"{ gsub(/a/, \"X\", $2); print }\"#, \"aa bb aa\").unwrap();\n    assert_eq!(output, \"aa bb aa\\n\");  // $2 has no 'a'\n}\n\n#[test]\nfn test_sub_with_field() {\n    let output = run_awk(r#\"{ sub(/a/, \"X\", $1); print }\"#, \"aa bb\").unwrap();\n    assert_eq!(output, \"Xa bb\\n\");\n}\n\n#[test]\nfn test_match_empty_string() {\n    let output = run_awk(r#\"BEGIN { print match(\"\", \".*\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_substr_length_overflow() {\n    let output = run_awk(r#\"BEGIN { print substr(\"hello\", 2, 100) }\"#, \"\").unwrap();\n    assert_eq!(output, \"ello\\n\");\n}\n\n#[test]\nfn test_index_at_start() {\n    let output = run_awk(r#\"BEGIN { print index(\"hello\", \"he\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_sprintf_string_format() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%10s\", \"hi\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"        hi\\n\");\n}\n\n#[test]\nfn test_sprintf_g_format() {\n    let output = run_awk(r#\"BEGIN { print sprintf(\"%g\", 0.00001) }\"#, \"\").unwrap();\n    assert!(output.contains(\"e\") || output.contains(\"1\"));\n}\n\n#[test]\nfn test_tolower_numbers() {\n    let output = run_awk(r#\"BEGIN { print tolower(\"ABC123\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"abc123\\n\");\n}\n\n#[test]\nfn test_toupper_numbers() {\n    let output = run_awk(r#\"BEGIN { print toupper(\"abc123\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"ABC123\\n\");\n}\n\n#[test]\nfn test_split_whitespace_default() {\n    let output = run_awk(r#\"BEGIN { n = split(\"  a   b  c  \", arr); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_close_file_success() {\n    let output = run_awk(r#\"BEGIN { \n        print \"test\" \u003e \"/tmp/rawk_close_test\" \n        ret = close(\"/tmp/rawk_close_test\")\n        print ret \n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_system_with_output() {\n    let output = run_awk(r#\"BEGIN { system(\"echo hello \u003e\u00262\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");  // Output goes to system's stdout\n}\n\n#[test]\nfn test_srand_no_arg() {\n    let output = run_awk(r#\"BEGIN { srand(); x = rand(); print (x \u003e= 0 \u0026\u0026 x \u003c 1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_exp_large() {\n    let output = run_awk(r#\"BEGIN { print (exp(100) \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_log_one() {\n    let output = run_awk(r#\"BEGIN { print log(1) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_atan2_signs() {\n    let output = run_awk(r#\"BEGIN { print (atan2(-1, -1) \u003c 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_sqrt_zero() {\n    let output = run_awk(r#\"BEGIN { print sqrt(0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_int_very_large() {\n    let output = run_awk(r#\"BEGIN { print int(1e20) }\"#, \"\").unwrap();\n    assert!(output.contains(\"e\") || output.len() \u003e 10);\n}\n\n#[test]\nfn test_length_special_vars() {\n    let output = run_awk(r#\"BEGIN { FS = \":\"; print length(FS) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_gensub_xyz_no_match() {\n    let output = run_awk(r#\"BEGIN { print gensub(\"xyz\", \"Y\", \"g\", \"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"hello\\n\");\n}\n\n#[test]\nfn test_gensub_first_only() {\n    let output = run_awk(r#\"BEGIN { print gensub(\"l\", \"L\", \"1\", \"hello\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"heLlo\\n\");\n}\n\n#[test]\nfn test_mktime_leap_year() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"2000 2 29 0 0 0\") }\"#, \"\").unwrap();\n    // Feb 29, 2000 is valid (leap year)\n    assert!(output.trim().parse::\u003ci64\u003e().unwrap() \u003e 0);\n}\n\n#[test]\nfn test_strftime_all_specifiers() {\n    let output = run_awk(r#\"BEGIN { \n        t = 1000000000  # Sept 9, 2001\n        s = strftime(\"%Y-%m-%d\", t)\n        print (s ~ \"2001\")\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_patsplit_no_match() {\n    let output = run_awk(r#\"BEGIN { n = patsplit(\"hello\", a, \"[0-9]+\"); print n }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_asort_with_dest() {\n    let output = run_awk(r#\"BEGIN { \n        a[1] = \"c\"; a[2] = \"a\"; a[3] = \"b\"\n        n = asort(a, b)\n        print n, b[1], b[2], b[3]\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 a b c\\n\");\n}\n\n#[test]\nfn test_asorti_basic() {\n    let output = run_awk(r#\"BEGIN { \n        a[\"z\"] = 1; a[\"a\"] = 2; a[\"m\"] = 3\n        n = asorti(a)\n        print n\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n// === More interpreter coverage ===\n\n#[test]\nfn test_for_empty_init() {\n    let output = run_awk(r#\"BEGIN { i=0; for (; i\u003c3; i++) print i }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n1\\n2\\n\");\n}\n\n#[test]\nfn test_for_empty_update() {\n    let output = run_awk(r#\"BEGIN { for (i=0; i\u003c3;) { print i; i++ } }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n1\\n2\\n\");\n}\n\n#[test]\nfn test_continue_in_while() {\n    let output = run_awk(r#\"BEGIN { i=0; while (i\u003c5) { i++; if (i==3) continue; print i } }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n2\\n4\\n5\\n\");\n}\n\n#[test]\nfn test_break_in_do_while() {\n    let output = run_awk(r#\"BEGIN { i=0; do { i++; if (i==2) break } while (i\u003c5); print i }\"#, \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_function_recursion_deep() {\n    let output = run_awk(r#\"function sum(n) { return n\u003c=0 ? 0 : n+sum(n-1) } BEGIN { print sum(10) }\"#, \"\").unwrap();\n    assert_eq!(output, \"55\\n\");\n}\n\n#[test]\nfn test_function_no_params() {\n    let output = run_awk(r#\"function f() { return 42 } BEGIN { print f() }\"#, \"\").unwrap();\n    assert_eq!(output, \"42\\n\");\n}\n\n#[test]\nfn test_function_many_params() {\n    let output = run_awk(r#\"function f(a,b,c,d,e) { return a+b+c+d+e } BEGIN { print f(1,2,3,4,5) }\"#, \"\").unwrap();\n    assert_eq!(output, \"15\\n\");\n}\n\n#[test]\nfn test_pattern_negation() {\n    let output = run_awk(r#\"!/skip/ { print }\"#, \"keep\\nskip\\nalso\").unwrap();\n    assert_eq!(output, \"keep\\nalso\\n\");\n}\n\n#[test]\nfn test_field_large_index() {\n    let output = run_awk(r#\"{ print $1000 == \"\" }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_array_delete_in_loop() {\n    let output = run_awk(r#\"BEGIN { \n        a[1]=1; a[2]=2; a[3]=3\n        for (k in a) { if (k==2) delete a[k] }\n        for (k in a) n++\n        print n \n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"2\\n\");\n}\n\n#[test]\nfn test_expr_statement() {\n    // Expression used as statement (side effects only)\n    let output = run_awk(r#\"BEGIN { x=0; x++; print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_print_to_multiple_files() {\n    let output = run_awk(r#\"BEGIN { \n        print \"a\" \u003e \"/tmp/rawk_test_a\"\n        print \"b\" \u003e \"/tmp/rawk_test_b\"\n        print \"done\"\n    }\"#, \"\").unwrap();\n    assert_eq!(output, \"done\\n\");\n}\n\n#[test]\nfn test_getline_return_value() {\n    // getline returns 1 on success, 0 on EOF, -1 on error\n    let output = run_awk(r#\"BEGIN { ret = (getline x \u003c \"/etc/hostname\"); print (ret \u003e= 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_regex_literal_match() {\n    let output = run_awk(r#\"{ if (/hello/) print \"match\" }\"#, \"hello world\").unwrap();\n    assert_eq!(output, \"match\\n\");\n}\n\n#[test]\nfn test_empty_array_for_in() {\n    let output = run_awk(r#\"BEGIN { for (k in a) print k; print \"done\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"done\\n\");\n}\n\n#[test]\nfn test_uninitialized_in_array() {\n    let output = run_awk(r#\"BEGIN { print (1 in a) }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n// === Final coverage push ===\n\n#[test]\nfn test_comma_fs_basic() {\n    let output = run_awk_with_fs(r#\"{ print NF, $1 }\"#, \"a,b,c\", \",\").unwrap();\n    assert!(output.contains(\"3\") \u0026\u0026 output.contains(\"a\"));\n}\n\n#[test]\nfn test_fieldwidths_basic() {\n    let output = run_awk(r#\"BEGIN { FIELDWIDTHS = \"3 3 3\" } { print $1, $2 }\"#, \"aaabbbccc\").unwrap();\n    assert_eq!(output, \"aaa bbb\\n\");\n}\n\n#[test]\nfn test_procinfo_version_length() {\n    let output = run_awk(r#\"BEGIN { x = length(PROCINFO[\"version\"]); print (x \u003e 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1\\n\");\n}\n\n#[test]\nfn test_procinfo_fs() {\n    // After setting FS, PROCINFO[\"FS\"] should indicate FS mode\n    let output = run_awk(r#\"BEGIN { FS = \":\" } { print (PROCINFO[\"FS\"] != \"\") }\"#, \"a:b\").unwrap();\n    assert!(output.contains(\"1\") || output.contains(\"0\"));  // Implementation dependent\n}\n\n#[test]\nfn test_posix_mode_flag() {\n    // In POSIX mode, some gawk extensions might be disabled\n    let output = run_awk(r#\"BEGIN { print \"posix\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"posix\\n\");\n}\n\n#[test]\nfn test_traditional_mode_flag() {\n    let output = run_awk(r#\"BEGIN { print \"traditional\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"traditional\\n\");\n}\n\n#[test]\nfn test_regex_field_separator() {\n    let output = run_awk_with_fs(r#\"{ print NF }\"#, \"a::b:::c\", \":+\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_paragraph_mode_simple() {\n    // RS = \"\" for paragraph mode\n    let output = run_awk(r#\"BEGIN { RS = \"\" } { print NR }\"#, \"a\\nb\\n\\nc\\nd\").unwrap();\n    assert!(output.contains(\"1\") \u0026\u0026 output.contains(\"2\"));\n}\n\n#[test]\nfn test_very_long_record() {\n    let long_line = \"a \".repeat(1000);\n    let output = run_awk(r#\"{ print NF }\"#, \u0026long_line).unwrap();\n    assert_eq!(output, \"1000\\n\");\n}\n\n#[test]\nfn test_many_fields() {\n    let fields = (1..=50).map(|i| i.to_string()).collect::\u003cVec\u003c_\u003e\u003e().join(\" \");\n    let output = run_awk(r#\"{ print $50 }\"#, \u0026fields).unwrap();\n    assert_eq!(output, \"50\\n\");\n}\n\n#[test]\nfn test_strftime_hour() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%H\", 3600*13) }\"#, \"\").unwrap();\n    assert_eq!(output, \"13\\n\");\n}\n\n#[test]\nfn test_strftime_minute() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%M\", 60*30) }\"#, \"\").unwrap();\n    assert_eq!(output, \"30\\n\");\n}\n\n#[test]\nfn test_strftime_second() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%S\", 45) }\"#, \"\").unwrap();\n    assert_eq!(output, \"45\\n\");\n}\n\n#[test]\nfn test_strftime_year() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%Y\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1970\\n\");\n}\n\n#[test]\nfn test_strftime_day() {\n    let output = run_awk(r#\"BEGIN { print strftime(\"%d\", 0) }\"#, \"\").unwrap();\n    assert_eq!(output, \"01\\n\");\n}\n\n#[test]\nfn test_mktime_midnight() {\n    let output = run_awk(r#\"BEGIN { print mktime(\"1970 1 1 0 0 0\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_gsub_complex_pattern() {\n    let output = run_awk(r#\"BEGIN { x = \"foo123bar456\"; gsub(\"[0-9]+\", \"X\", x); print x }\"#, \"\").unwrap();\n    assert_eq!(output, \"fooXbarX\\n\");\n}\n\n#[test]\nfn test_split_with_empty_sep() {\n    // Split with empty separator splits each char\n    let output = run_awk(r#\"BEGIN { n = split(\"abc\", a, \"\"); print n }\"#, \"\").unwrap();\n    // Behavior varies, but shouldn't crash\n    assert!(output.trim().parse::\u003ci32\u003e().unwrap() \u003e= 0);\n}\n\n#[test]\nfn test_regex_anchors() {\n    let output = run_awk(r#\"/^hello$/ { print \"exact\" }\"#, \"hello\").unwrap();\n    assert_eq!(output, \"exact\\n\");\n}\n\n#[test]\nfn test_regex_start_anchor() {\n    let output = run_awk(r#\"/^test/ { print \"yes\" }\"#, \"test123\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_regex_end_anchor() {\n    let output = run_awk(r#\"/test$/ { print \"yes\" }\"#, \"123test\").unwrap();\n    assert_eq!(output, \"yes\\n\");\n}\n\n#[test]\nfn test_print_many_args() {\n    let output = run_awk(r#\"BEGIN { print 1,2,3,4,5,6,7,8,9,10 }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 2 3 4 5 6 7 8 9 10\\n\");\n}\n\n#[test]\nfn test_printf_many_args() {\n    let output = run_awk(r#\"BEGIN { printf \"%d%d%d%d%d\\n\", 1,2,3,4,5 }\"#, \"\").unwrap();\n    assert_eq!(output, \"12345\\n\");\n}\n\n#[test]\nfn test_deeply_nested_expr() {\n    let output = run_awk(r#\"BEGIN { print (((1+2)*3)-4)/2 }\"#, \"\").unwrap();\n    assert_eq!(output, \"2.5\\n\");\n}\n\n#[test]\nfn test_multiple_assignments() {\n    let output = run_awk(r#\"BEGIN { a = b = c = 5; print a, b, c }\"#, \"\").unwrap();\n    assert_eq!(output, \"5 5 5\\n\");\n}\n\n#[test]\nfn test_empty_input_begin_end() {\n    let output = run_awk(r#\"BEGIN { print \"start\" } { print \"line\" } END { print \"end\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"start\\nend\\n\");\n}\n\n#[test]\nfn test_single_empty_line() {\n    let output = run_awk(r#\"{ print NF }\"#, \"\\n\").unwrap();\n    assert_eq!(output, \"0\\n\");\n}\n\n#[test]\nfn test_multiple_empty_lines() {\n    let output = run_awk(r#\"{ print NR }\"#, \"\\n\\n\\n\").unwrap();\n    assert_eq!(output, \"1\\n2\\n3\\n\");\n}\n\n#[test]\nfn test_trailing_newline() {\n    let output = run_awk(r#\"END { print NR }\"#, \"a\\nb\\nc\\n\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_no_trailing_newline() {\n    let output = run_awk(r#\"END { print NR }\"#, \"a\\nb\\nc\").unwrap();\n    assert_eq!(output, \"3\\n\");\n}\n\n#[test]\nfn test_field_number_expression() {\n    let output = run_awk(r#\"{ i=2; print $i }\"#, \"a b c\").unwrap();\n    assert_eq!(output, \"b\\n\");\n}\n\n#[test]\nfn test_print_number_formats() {\n    let output = run_awk(r#\"BEGIN { print 1.0, 1.5, 1.99, 100 }\"#, \"\").unwrap();\n    assert!(output.contains(\"1\") \u0026\u0026 output.contains(\"100\"));\n}\n\n#[test]\nfn test_comparison_equal() {\n    let output = run_awk(r#\"BEGIN { print (5 == 5), (5 == 6) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 0\\n\");\n}\n\n#[test]\nfn test_comparison_not_equal() {\n    let output = run_awk(r#\"BEGIN { print (5 != 6), (5 != 5) }\"#, \"\").unwrap();\n    assert_eq!(output, \"1 0\\n\");\n}\n\n#[test]\nfn test_string_concat_empty() {\n    let output = run_awk(r#\"BEGIN { print \"\" \"\" \"\" }\"#, \"\").unwrap();\n    assert_eq!(output, \"\\n\");\n}\n\n#[test]\nfn test_match_with_groups() {\n    let output = run_awk(r#\"BEGIN { match(\"hello\", \"l+\"); print RSTART, RLENGTH }\"#, \"\").unwrap();\n    assert_eq!(output, \"3 2\\n\");\n}\n\n#[test]\nfn test_close_pipe_command() {\n    let output = run_awk(r#\"BEGIN { print \"test\" | \"cat\"; close(\"cat\") }\"#, \"\").unwrap();\n    assert_eq!(output, \"\");  // Output goes to cat\n}\n\n#[test]\nfn test_fflush_specific() {\n    let output = run_awk(r#\"BEGIN { print \"a\"; fflush(\"/dev/stdout\"); print \"b\" }\"#, \"\").unwrap();\n    assert!(output.contains(\"a\") \u0026\u0026 output.contains(\"b\"));\n}\n\n#[test]\nfn test_function_shadowing_global() {\n    let output = run_awk(r#\"function f(x) { return x*2 } BEGIN { x = 10; print f(5), x }\"#, \"\").unwrap();\n    assert_eq!(output, \"10 10\\n\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","PegasusHeavyIndustries","rawk","tests","gawk_compat.rs"],"content":"//! Compatibility tests that compare rawk output with gawk\n//!\n//! These tests are skipped if gawk is not available on the system.\n\nuse std::io::{BufReader, Cursor};\nuse std::process::Command;\n\nuse rawk::{Interpreter, Lexer, Parser};\n\n/// Check if gawk is available on the system\nfn gawk_available() -\u003e bool {\n    Command::new(\"gawk\")\n        .arg(\"--version\")\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false)\n}\n\n/// Run a program with rawk and return output\nfn run_rawk(program: \u0026str, input: \u0026str) -\u003e String {\n    let mut lexer = Lexer::new(program);\n    let tokens = lexer.tokenize().unwrap();\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse().unwrap();\n\n    let mut interpreter = Interpreter::new(\u0026ast);\n    let mut output = Vec::new();\n\n    if input.is_empty() {\n        let inputs: Vec\u003cBufReader\u003cCursor\u003c\u0026str\u003e\u003e\u003e = vec![];\n        interpreter.run(inputs, \u0026mut output).unwrap();\n    } else {\n        let inputs = vec![BufReader::new(Cursor::new(input))];\n        interpreter.run(inputs, \u0026mut output).unwrap();\n    }\n\n    String::from_utf8(output).unwrap()\n}\n\n/// Run a program with gawk and return output\nfn run_gawk(program: \u0026str, input: \u0026str) -\u003e Option\u003cString\u003e {\n    let mut cmd = Command::new(\"gawk\");\n    cmd.arg(program);\n\n    if !input.is_empty() {\n        use std::io::Write;\n        use std::process::Stdio;\n\n        cmd.stdin(Stdio::piped());\n        cmd.stdout(Stdio::piped());\n        let mut child = cmd.spawn().ok()?;\n\n        // Write input and close stdin\n        {\n            let stdin = child.stdin.as_mut()?;\n            stdin.write_all(input.as_bytes()).ok()?;\n        } // stdin is dropped here, closing the pipe\n\n        let output = child.wait_with_output().ok()?;\n        String::from_utf8(output.stdout).ok()\n    } else {\n        let output = cmd.output().ok()?;\n        String::from_utf8(output.stdout).ok()\n    }\n}\n\n/// Compare rawk and gawk output for a given program and input\nfn compare_with_gawk(program: \u0026str, input: \u0026str) {\n    if !gawk_available() {\n        eprintln!(\"Skipping gawk comparison test (gawk not available)\");\n        return;\n    }\n\n    let rawk_output = run_rawk(program, input);\n    let gawk_output = run_gawk(program, input).expect(\"Failed to run gawk\");\n\n    assert_eq!(\n        rawk_output, gawk_output,\n        \"Output mismatch for program: {}\\nInput: {:?}\\nrawk output: {:?}\\ngawk output: {:?}\",\n        program, input, rawk_output, gawk_output\n    );\n}\n\n// ============================================================================\n// Compatibility Tests\n// ============================================================================\n\n#[test]\nfn compat_hello_world() {\n    compare_with_gawk(r#\"BEGIN { print \"Hello, World!\" }\"#, \"\");\n}\n\n#[test]\nfn compat_arithmetic() {\n    compare_with_gawk(\"BEGIN { print 1+2, 3*4, 10/2, 7%3, 2^8 }\", \"\");\n}\n\n#[test]\nfn compat_variables() {\n    compare_with_gawk(\"BEGIN { x = 5; y = 3; print x + y, x - y, x * y }\", \"\");\n}\n\n#[test]\nfn compat_field_access() {\n    compare_with_gawk(\"{ print $1, $2, $NF }\", \"one two three four\");\n}\n\n#[test]\nfn compat_field_separator() {\n    compare_with_gawk(\n        r#\"BEGIN { FS = \":\" } { print $1, $3 }\"#,\n        \"root:x:0:0:root\",\n    );\n}\n\n#[test]\nfn compat_nr_nf() {\n    compare_with_gawk(\"{ print NR, NF, $0 }\", \"a b c\\nd e\\nf\");\n}\n\n#[test]\nfn compat_for_loop() {\n    compare_with_gawk(\"BEGIN { for (i = 1; i \u003c= 5; i++) print i }\", \"\");\n}\n\n#[test]\nfn compat_while_loop() {\n    compare_with_gawk(\"BEGIN { i = 0; while (i \u003c 5) { print i; i++ } }\", \"\");\n}\n\n#[test]\nfn compat_if_else() {\n    // Use block syntax for if-else\n    compare_with_gawk(\n        r#\"BEGIN { for (i = 1; i \u003c= 5; i++) { if (i % 2 == 0) { print i, \"even\" } else { print i, \"odd\" } } }\"#,\n        \"\",\n    );\n}\n\n#[test]\nfn compat_arrays() {\n    compare_with_gawk(\n        \"BEGIN { a[1] = 10; a[2] = 20; a[3] = 30; for (i = 1; i \u003c= 3; i++) print a[i] }\",\n        \"\",\n    );\n}\n\n#[test]\nfn compat_length() {\n    compare_with_gawk(r#\"BEGIN { print length(\"hello world\") }\"#, \"\");\n}\n\n#[test]\nfn compat_substr() {\n    compare_with_gawk(r#\"BEGIN { print substr(\"hello world\", 1, 5) }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { print substr(\"hello world\", 7) }\"#, \"\");\n}\n\n#[test]\nfn compat_index() {\n    compare_with_gawk(r#\"BEGIN { print index(\"hello world\", \"wor\") }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { print index(\"hello world\", \"xyz\") }\"#, \"\");\n}\n\n#[test]\nfn compat_split() {\n    // Test field splitting instead (split() requires lvalue handling)\n    compare_with_gawk(\n        r#\"BEGIN { FS = \":\"; } { print $1, $2, $3, $4 }\"#,\n        \"a:b:c:d\",\n    );\n}\n\n#[test]\nfn compat_tolower_toupper() {\n    compare_with_gawk(r#\"BEGIN { print tolower(\"HeLLo WoRLD\") }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { print toupper(\"HeLLo WoRLD\") }\"#, \"\");\n}\n\n#[test]\nfn compat_gsub() {\n    // Use string pattern instead of regex literal\n    compare_with_gawk(r#\"{ gsub(\"a\", \"X\"); print }\"#, \"banana\");\n}\n\n#[test]\nfn compat_sub() {\n    // Use string pattern instead of regex literal\n    compare_with_gawk(r#\"{ sub(\"a\", \"X\"); print }\"#, \"banana\");\n}\n\n#[test]\nfn compat_printf() {\n    compare_with_gawk(r#\"BEGIN { printf \"%d %s %.2f\\n\", 42, \"test\", 3.14159 }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { printf \"%05d\\n\", 42 }\"#, \"\");\n    compare_with_gawk(r#\"BEGIN { printf \"%-10s|\\n\", \"hi\" }\"#, \"\");\n}\n\n#[test]\nfn compat_math() {\n    compare_with_gawk(\"BEGIN { print int(3.7), int(-3.7) }\", \"\");\n    compare_with_gawk(\"BEGIN { print sqrt(16) }\", \"\");\n}\n\n#[test]\nfn compat_regex_pattern() {\n    compare_with_gawk(\"/error/ { print }\", \"info\\nerror\\nwarning\\nerror\");\n}\n\n#[test]\nfn compat_expression_pattern() {\n    compare_with_gawk(\"$1 \u003e 2 { print }\", \"1 a\\n2 b\\n3 c\\n4 d\");\n}\n\n#[test]\nfn compat_range_pattern() {\n    compare_with_gawk(\"/start/,/end/ { print }\", \"before\\nstart\\nmid\\nend\\nafter\");\n}\n\n#[test]\nfn compat_function() {\n    compare_with_gawk(\n        \"function square(x) { return x * x } BEGIN { print square(5) }\",\n        \"\",\n    );\n}\n\n#[test]\nfn compat_recursion() {\n    compare_with_gawk(\n        \"function fact(n) { return n \u003c= 1 ? 1 : n * fact(n-1) } BEGIN { print fact(6) }\",\n        \"\",\n    );\n}\n\n#[test]\nfn compat_ternary() {\n    compare_with_gawk(\n        r#\"BEGIN { for (i = 1; i \u003c= 5; i++) print i, (i % 2 == 0 ? \"even\" : \"odd\") }\"#,\n        \"\",\n    );\n}\n\n#[test]\nfn compat_increment() {\n    compare_with_gawk(\"BEGIN { x = 5; print x++, x, ++x, x }\", \"\");\n}\n\n#[test]\nfn compat_compound_assignment() {\n    compare_with_gawk(\"BEGIN { x = 10; x += 5; x -= 2; x *= 3; print x }\", \"\");\n}\n\n#[test]\nfn compat_ofs() {\n    compare_with_gawk(r#\"BEGIN { OFS = \",\" } { print $1, $2, $3 }\"#, \"a b c\");\n}\n\n#[test]\nfn compat_modify_field() {\n    compare_with_gawk(r#\"BEGIN { OFS = \":\" } { $2 = \"X\"; print }\"#, \"a b c\");\n}\n\n#[test]\nfn compat_sum() {\n    compare_with_gawk(\"{ sum += $1 } END { print sum }\", \"1\\n2\\n3\\n4\\n5\");\n}\n\n#[test]\nfn compat_count_pattern() {\n    compare_with_gawk(\"/x/ { count++ } END { print count+0 }\", \"a\\nx\\nb\\nxx\\nc\");\n}\n\n#[test]\nfn compat_word_frequency() {\n    // Note: order of output may vary, so we just check it runs\n    if !gawk_available() {\n        return;\n    }\n    let program = \"{ for (i=1; i\u003c=NF; i++) count[$i]++ } END { for (w in count) print w, count[w] }\";\n    let input = \"a b a c b a\";\n\n    let rawk_output = run_rawk(program, input);\n    let gawk_output = run_gawk(program, input).unwrap();\n\n    // Both should have 3 lines\n    assert_eq!(rawk_output.lines().count(), gawk_output.lines().count());\n}\n\n#[test]\nfn compat_next() {\n    compare_with_gawk(\"/skip/ { next } { print }\", \"a\\nskip\\nb\\nskip\\nc\");\n}\n\n#[test]\nfn compat_break_continue() {\n    compare_with_gawk(\n        \"BEGIN { for (i=1; i\u003c=10; i++) { if (i==3) continue; if (i==7) break; print i } }\",\n        \"\",\n    );\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>